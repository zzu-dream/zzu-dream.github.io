<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>nginx学习</title>
    <url>/2021/07/11/Nginx/iOS%E7%BC%96%E7%A8%8B%E4%B9%A0%E6%83%AF%E4%B8%8E%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先在开发前确定好需求 对需求点分析 </span><br><span class="line">1、对感觉不太合理的地方 提出来或者有自己的建议 </span><br><span class="line">把不合理的地方阉割在开发开始之前（做愉快编程）</span><br><span class="line">2、分析接口 做开发前的进一步预判</span><br></pre></td></tr></table></figure>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><h3 id="学习外部地址"><a href="#学习外部地址" class="headerlink" title="学习外部地址"></a>学习外部地址</h3><p><a href="http://liuyanwei.jumppo.com/2016/02/29/iOS-objc-styleguide.html">刘彦玮博客总结</a><br> <a href="https://github.com/oa414/objc-zen-book-cn/">objc禅翻译</a><br> <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-objc-styleguide/contents/">Google 开源项目风格指南 - objc</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Android编码规范</title>
    <url>/2018/06/11/android/android-code-style/</url>
    <content><![CDATA[<p><a href="https://github.com/tianshaojie/android-code-style">Android编码规范</a></p>
<p><a href="https://github.com/tianshaojie/AndroidFine">Android快速开发框架</a></p>
<p><a href="https://github.com/tianshaojie/android-modularization">Android组件化设计思路</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>Android编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio平台下无线调试</title>
    <url>/2018/06/11/android/Android%20Studio%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/JJ583500596/article/details/75081462">Android Studio平台下无线调试</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2018/06/11/android/android%E4%B9%8B%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h3><p>泛型，大概的意思是指没有指定具体的类型的类或方法，以泛型的形式传入一个类中或方法中，在Java编程(Android编程)里面使用一对尖括号和一个大写字母表示，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型方法，类型参数位于返回类型之前或void之前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E [] arr, E x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(E val:arr)&#123;</span><br><span class="line">      <span class="keyword">if</span>(x.equal(val))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="泛型-（-extends-T和-super-T）"><a href="#泛型-（-extends-T和-super-T）" class="headerlink" title="泛型 （? extends T和? super T）"></a>泛型 （? extends T和? super T）</h3><p><a href="https://blog.csdn.net/android_bar/article/details/81486161">泛型 （? extends T和? super T）</a></p>
<? extends T>和<? super T>是泛型中的“通配符（Wildcards）”和“边界（Bounds）”的概念。

* <? extends T>：上界通配符（Upper Bounds Wildcards）
* <? super T>：    下界通配符（Lower Bounds Wildcards）
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>android学习(2014、11、14)</title>
    <url>/2018/06/11/android/android%E5%AD%A6%E4%B9%A0(2014-11-14)/</url>
    <content><![CDATA[<!--2014、11、14-->

<h3 id="java中的匿名内部类总结"><a href="#java中的匿名内部类总结" class="headerlink" title="java中的匿名内部类总结"></a>java中的匿名内部类总结</h3><p>匿名内部类也就是没有名字的内部类<br>正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写<br>但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口(只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口)</p>
<pre><code class="java">
 sample1：Thread t = new Thread() &#123;
            public void run() &#123;
                for (int i = 1; i &lt;= 5; i++) &#123;
                    System.out.print(i + &quot; &quot;);
                &#125;
            &#125;
        &#125;;
        t.start();
sample2：Runnable r = new Runnable() &#123;
            public void run() &#123;
                for (int i = 1; i &lt;= 5; i++) &#123;
                    System.out.print(i + &quot; &quot;);
                &#125;
            &#125;
        &#125;;
        Thread t = new Thread(r);
        t.start();
        
</code></pre>
<h3 id="Android中常常使用shape来定义控件的一些显示属性-比如：button，cell的backround"><a href="#Android中常常使用shape来定义控件的一些显示属性-比如：button，cell的backround" class="headerlink" title="Android中常常使用shape来定义控件的一些显示属性(比如：button，cell的backround)"></a>Android中常常使用shape来定义控件的一些显示属性(比如：button，cell的backround)</h3><pre><code class="java">
http://kofi1122.blog.51cto.com/2815761/521605
   &lt;shape&gt;
            &lt;!-- 实心 --&gt;
            &lt;solid android:color=&quot;#ff9d77&quot;/&gt;
            &lt;!-- 渐变 --&gt;
            &lt;gradient
                android:startColor=&quot;#ff8c00&quot;
                android:endColor=&quot;#FFFFFF&quot;
                android:angle=&quot;270&quot; /&gt;
            &lt;!-- 描边 --&gt;
            &lt;stroke
                android:width=&quot;2dp&quot;
                android:color=&quot;#dcdcdc&quot; /&gt;
            &lt;!-- 圆角 --&gt;
            &lt;corners
                android:radius=&quot;2dp&quot; /&gt;
            &lt;padding
                android:left=&quot;10dp&quot;
                android:top=&quot;10dp&quot;
                android:right=&quot;10dp&quot;
                android:bottom=&quot;10dp&quot; /&gt;
        &lt;/shape&gt;
        
</code></pre>
<p>solid：实心，就是填充的意思<br>android:color指定填充的颜色<br>gradient：渐变<br>android:startColor和android:endColor分别为起始和结束颜色，ndroid:angle是渐变角度，必须为45的整数倍。<br>另外渐变默认的模式为android:type=”linear”，即线性渐变，可以指定渐变为径向渐变，android:type=”radial”，径向渐变需要指定半径  android:gradientRadius=”50”。<br>stroke：描边<br>android:width=”2dp” 描边的宽度，android:color 描边的颜色。<br>我们还可以把描边弄成虚线的形式，设置方式为：<br>android:dashWidth=”5dp”<br>android:dashGap=”3dp”<br>其中android:dashWidth表示’-‘这样一个横线的宽度，android:dashGap表示之间隔开的距离。 </p>
<h3 id="SharedPreferences的使用"><a href="#SharedPreferences的使用" class="headerlink" title="SharedPreferences的使用"></a>SharedPreferences的使用</h3><p>存：SharedPreferences settings = getSharedPreferences(“SharedInstance”, 0);<br>        settings.edit().putString(“name”, editView.getText().toString()).commit();<br>取：  //获取一个 SharedPreferences 对象<br>        SharedPreferences settings = getSharedPreferences(“SharedInstance”, 0);<br>          //取出保存的NAME，取出改字段名的值，不存在则创建默认为空<br>            String name = settings.getString(“name”, “”); </p>
<h3 id="corners：圆角"><a href="#corners：圆角" class="headerlink" title="corners：圆角"></a>corners：圆角</h3><p>android:radius为角的弧度，值越大角越圆。<br>我们还可以把四个角设定成不同的角度，方法为：</p>
<pre><code class="java">
&lt;corners 
        android:topRightRadius=&quot;20dp&quot;    右上角
        android:bottomLeftRadius=&quot;20dp&quot;    右下角
        android:topLeftRadius=&quot;1dp&quot;    左上角
        android:bottomRightRadius=&quot;0dp&quot;    左下角
 /&gt;
 
</code></pre>
<p>这里有个地方需要注意，bottomLeftRadius是右下角，而不是左下角，这个有点郁闷，不过不影响使用，记得别搞错了就行。<br>还有网上看到有人说设置成0dp无效，不过我在测试中发现是可以的，我用的是2.2，可能修复了这个问题吧，如果无效的话那就只能设成1dp了。<br>padding：间隔<br>这个就不用多说了，XML布局文件中经常用到。<br>大体的就是这样，以下是一个使用的具体示例：用在Selector中作为Button的背景，分别定义了按钮的一般状态、获得焦点状态和按下时的状态，具体代码如下：<br>使用地方：</p>
<pre><code class="java">
&lt;Button
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;TestShapeButton&quot;
    android:background=&quot;@drawable/button_selector&quot;
    /&gt;
    
</code></pre>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>android学习(2014、11、17)</title>
    <url>/2018/06/11/android/android%E5%AD%A6%E4%B9%A0(2014-11-17)/</url>
    <content><![CDATA[<!--2014、11、17-->

<p>1、<a href="http://www.blogjava.net/action/articles/17339.html">http://www.blogjava.net/action/articles/17339.html</a> 快捷键大全<br>2、dp、sp和px的区别<br>看到有很多网友不太理解dp、sp和px的区别：现在这里介绍一下dp和sp。dp也就是dip。这个和sp基本类似。如果设置表示长度、高度等属性时可 以使用dp 或sp。但如果设置字体，需要使用sp。dp是与密度无关，sp除了与密度无关外，还与scale无关。如果屏幕密度为160，这时dp和sp和px是一 样的。1dp=1sp=1px，但如果使用px作单位，如果屏幕大小不变（假设还是3.2寸），而屏幕密度变成了320。那么原来TextView的宽度 设成160px，在密度为320的3.2寸屏幕里看要比在密度为160的3.2寸屏幕上看短了一半。但如果设置成160dp或160sp的话。系统会自动 将width属性值设置成320px的。也就是160 * 320 / 160。其中320 / 160可称为密度比例因子。也就是说，如果使用dp和sp，系统会根据屏幕密度的变化自动进行转换。</p>
<h3 id="checkBox的使用"><a href="#checkBox的使用" class="headerlink" title="checkBox的使用"></a>checkBox的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CheckBox checkBox1 = (CheckBox)findViewById(R.id.checkBox1);</span><br><span class="line">checkBox1.setOnCheckedChangeListener(<span class="keyword">new</span> CompoundButton.OnCheckedChangeListener() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCheckedChanged</span><span class="params">(CompoundButton buttonView, <span class="keyword">boolean</span> isChecked)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">if</span>(isChecked)&#123;</span><br><span class="line">            Log.v(<span class="string">&quot;CheckBox&quot;</span>,<span class="string">&quot;你选择了-&quot;</span> + buttonView.getText());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Log.v(<span class="string">&quot;CheckBox&quot;</span>,<span class="string">&quot;你取消选择了-&quot;</span>+ buttonView.getText());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="RadioGroup的使用"><a href="#RadioGroup的使用" class="headerlink" title="RadioGroup的使用"></a>RadioGroup的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RadioGroup radioGroup = (RadioGroup) findViewById(R.id.radioGroup);</span><br><span class="line">radioGroup.setOnCheckedChangeListener(<span class="keyword">new</span> OnCheckedChangeListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCheckedChanged</span><span class="params">(RadioGroup group, <span class="keyword">int</span> checkedId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> radioButtonId = group.getCheckedRadioButtonId();</span><br><span class="line">        Log.v(<span class="string">&quot;RadioGroup&quot;</span>, <span class="string">&quot;onCheckedChanged==id=&quot;</span> + checkedId</span><br><span class="line">                + radioButtonId);</span><br><span class="line">        <span class="comment">// 根据ID获取RadioButton的实例</span></span><br><span class="line">        RadioButton rb = (RadioButton) SecondActivity.<span class="keyword">this</span></span><br><span class="line">                .findViewById(radioButtonId);</span><br><span class="line">        <span class="comment">// 更新文本内容，以符合选中项</span></span><br><span class="line">        textView1.setText(<span class="string">&quot;您的性别是：&quot;</span> + rb.getText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Bundle的使用"><a href="#Bundle的使用" class="headerlink" title="Bundle的使用"></a>Bundle的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putString(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        bundle.putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;狗子&quot;</span>);</span><br><span class="line">        bundle.putString(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;12&quot;</span>);</span><br><span class="line">        bundle.putString(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">        String name = bundle.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        Log.v(<span class="string">&quot;Bundle&quot;</span>,<span class="string">&quot;bundle.string=&quot;</span>+ bundle.toString()+<span class="string">&quot;名字：&quot;</span>+name);</span><br><span class="line"><span class="comment">//bundle.string=Bundle[&#123;gender=男, age=12, city=上海, name=狗子&#125;]名字：狗子</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Android-RelativeLayout-属性"><a href="#Android-RelativeLayout-属性" class="headerlink" title="Android RelativeLayout 属性"></a>Android RelativeLayout 属性</h3><p>// 相对于给定ID控件<br>android:layout_above 将该控件的底部置于给定ID的控件之上;<br>android:layout_below 将该控件的底部置于给定ID的控件之下;<br>android:layout_toLeftOf    将该控件的右边缘与给定ID的控件左边缘对齐;<br>android:layout_toRightOf  将该控件的左边缘与给定ID的控件右边缘对齐;</p>
<p>android:layout_alignBaseline  将该控件的baseline与给定ID的baseline对齐;<br>android:layout_alignTop        将该控件的顶部边缘与给定ID的顶部边缘对齐;<br>android:layout_alignBottom   将该控件的底部边缘与给定ID的底部边缘对齐;<br>android:layout_alignLeft        将该控件的左边缘与给定ID的左边缘对齐;<br>android:layout_alignRight      将该控件的右边缘与给定ID的右边缘对齐;<br>// 相对于父组件<br>android:layout_alignParentTop      如果为true,将该控件的顶部与其父控件的顶部对齐;<br>android:layout_alignParentBottom 如果为true,将该控件的底部与其父控件的底部对齐;<br>android:layout_alignParentLeft      如果为true,将该控件的左部与其父控件的左部对齐;<br>android:layout_alignParentRight    如果为true,将该控件的右部与其父控件的右部对齐;<br>// 居中<br>android:layout_centerHorizontal 如果为true,将该控件的置于水平居中;<br>android:layout_centerVertical     如果为true,将该控件的置于垂直居中;<br>android:layout_centerInParent   如果为true,将该控件的置于父控件的中央;<br>// 指定移动像素<br>android:layout_marginTop      上偏移的值;<br>android:layout_marginBottom 下偏移的值;<br>android:layout_marginLeft 　　左偏移的值;<br>android:layout_marginRight 　 右偏移的值;</p>
<!--2014、11、18-->  

<h3 id="下拉列表框-Spinner的使用"><a href="#下拉列表框-Spinner的使用" class="headerlink" title="下拉列表框 Spinner的使用"></a>下拉列表框 Spinner的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myTextView = (TextView) findViewById(R.id.TextView_city);</span><br><span class="line">        mySpinner = (Spinner) findViewById(R.id.Spinner_city);</span><br><span class="line">        adapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>,</span><br><span class="line">                android.R.layout.simple_spinner_item, citys);</span><br><span class="line">        <span class="comment">// 为适配器设置下拉列表下拉时的菜单样式。</span></span><br><span class="line">        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);</span><br><span class="line">        <span class="comment">// 将适配器添加到下拉列表上</span></span><br><span class="line">        mySpinner.setAdapter(adapter);</span><br><span class="line">        mySpinner.setOnItemSelectedListener(<span class="keyword">new</span> OnItemSelectedListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemSelected</span><span class="params">(AdapterView&lt;?&gt; parent, View view,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                myTextView.setText(<span class="string">&quot;您的选择是：&quot;</span> + adapter.getItem(position));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNothingSelected</span><span class="params">(AdapterView&lt;?&gt; parent)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                <span class="comment">// myTextView.setText(&quot;NONE&quot;);</span></span><br><span class="line">                <span class="comment">// parent.setVisibility(View.VISIBLE);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">```  </span><br><span class="line">       </span><br><span class="line">### 类名.<span class="keyword">this</span> 的使用</span><br><span class="line"></span><br><span class="line">我们会用到一些内部类和匿名类。当在匿名类中用<span class="keyword">this</span>时，这个<span class="keyword">this</span>则指的是匿名类或内部类本身。这时如果我们要使用外部类的方法和变量的话，则应该加上外部类的类名。</span><br><span class="line"></span><br><span class="line">### GridView 使用方式</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">GridView gridView = (GridView) findViewById(R.id.gridview);</span><br><span class="line">        gridView.setAdapter(<span class="keyword">new</span> ImageAdapter(<span class="keyword">this</span>));</span><br><span class="line">        gridView.setOnItemClickListener(<span class="keyword">new</span> OnItemClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View view,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                Toast.makeText(GridViewActivity.<span class="keyword">this</span>, mThumbIds[position], Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">```  </span><br><span class="line">       </span><br><span class="line">### 代码法设置背景颜色</span><br><span class="line"></span><br><span class="line">ImageView设置背景颜色</span><br><span class="line">ImageView.setBackgroundColor(android.graphics.Color.parseColor(<span class="string">&quot;#ffffff&quot;</span>));</span><br><span class="line">ImageView.setBackgroundColor(Color.RED);</span><br><span class="line">ImageView.setBackgroundColor(Color.rgb(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">### Android广播机制</span><br><span class="line"></span><br><span class="line">BroadcastReceiver用于接收程序（包括用户开发的程序和系统内建的程序）所发出的Broadcast Intent，与应用程序启动Activity、Service相同的是，程序启动BroadcastReceiver也只需要两步。</span><br><span class="line"><span class="number">1</span>）创建需要启动的BroadcastReceiver的Intent。</span><br><span class="line"><span class="number">2</span>）调用Context的sendBroadcast()或sendOrderedBroadcast()方法来启动指定BroadcastReceiver。</span><br><span class="line">内部类的方式</span><br><span class="line"></span><br><span class="line">#### 注册</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">&#123;</span><br><span class="line">    myBroadCast = <span class="keyword">new</span> MyBroadCast();</span><br><span class="line">        IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">        filter.addAction(ACTION_INTENT_TEST);</span><br><span class="line">        registerReceiver(myBroadCast, filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="内部类实现"><a href="#内部类实现" class="headerlink" title="内部类实现"></a>内部类实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBroadCast</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyBroadCast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.v(<span class="string">&quot;BROADCAST_TAG&quot;</span>, <span class="string">&quot;myBroadCast&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO 处理接收到得广播</span></span><br><span class="line">            Log.v(<span class="string">&quot;BROADCAST_TAG&quot;</span>, <span class="string">&quot;onReceive===1111111&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(ThirdActivity.ACTION_INTENT_TEST);</span><br><span class="line">                   sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<h4 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册"></a>取消注册</h4><p> java<br>    @Override<br>    protected void onDestroy() {<br>        super.onDestroy();<br>        unregisterReceiver(myBroadCast);<br>    }</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>android学习</title>
    <url>/2018/06/11/android/android%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!--2014、11、12-->

<h3 id="Android-之-fill-parent-、wrap-content-、match-parent属性"><a href="#Android-之-fill-parent-、wrap-content-、match-parent属性" class="headerlink" title="Android 之 fill_parent 、wrap_content 、match_parent属性"></a>Android 之 fill_parent 、wrap_content 、match_parent属性</h3><p><code>fill_parent</code> 设置一个顶部布局或控件为<br><code>fill_parent</code>将强制性让它布满整个屏幕。<br><code>wrap_content</code> 设置一个视图的尺寸为<br><code>wrap_content</code>将强制性地使视图扩展以显示全部内容</p>
<h3 id="在程序中输出日志-使用-android-util-Log-类"><a href="#在程序中输出日志-使用-android-util-Log-类" class="headerlink" title="在程序中输出日志, 使用 android.util.Log 类."></a>在程序中输出日志, 使用 android.util.Log 类.</h3><p>该类提供了若干静态方法<br>Log.v(String tag, String msg);<br>Log.d(String tag, String msg);<br>Log.i(String tag, String msg);<br>Log.w(String tag, String msg);<br>Log.e(String tag, String msg);<br>分别对应 Verbose, Debug, Info, Warning,Error.<br>tag是一个标识,可以是任意字符串,通常可以使用类名+方法名, 主要是用来在查看日志时提供一个筛选条件.<br>程序运行后 并不会在 ide的控制台内输出任何信息.<br>如果要后查看日志 请使用<br>adb logcat  </p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>command + shift + f 格式化代码 ，option + / 提示，option + 上下键 移动某行代码，option + command + 上下键，option + command + s  弹出菜单功能页，Ctrl+1 快速修复(最经典的快捷键,就不用多说了)</p>
<h3 id="layout文件夹里新建xml命名"><a href="#layout文件夹里新建xml命名" class="headerlink" title="layout文件夹里新建xml命名"></a>layout文件夹里新建xml命名</h3><p>必须都是小写</p>
<h3 id="完成A跳转到B操作：要在AndroidMainifest-xml的文件里面"><a href="#完成A跳转到B操作：要在AndroidMainifest-xml的文件里面" class="headerlink" title="完成A跳转到B操作：要在AndroidMainifest.xml的文件里面"></a>完成A跳转到B操作：要在AndroidMainifest.xml的文件里面</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> &lt;activity</span><br><span class="line">            android:name=<span class="string">&quot;com.example.sample1.新加入的类名字”</span></span><br><span class="line"><span class="string">            android:label=“页面的标题” &gt;</span></span><br><span class="line"><span class="string"> &lt;/activity&gt;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">```     </span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">AndroidManifest.xml是Android应用程序中最重要的文件之一。它是Android程序的全局配置文件，是每个 android程序中必须的文件。它位于我们开发的应用程序的根目录下，描述了package中的全局数据，包括package中暴露的组件 （activities, services, 等等），以及他们各自的实现类，各种能被处理的数据和启动位置等重要信息。</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;!--2014、11、13--&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 布局Layout管理</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[布局](http://www.cnblogs.com/mengdd/archive/2012/12/19/2825382.html)  </span></span><br><span class="line"><span class="string"> 　</span></span><br><span class="line"><span class="string"> 　　布局即是指Activity中组件的呈现方式，即组件大小、间距和对齐方式等。  </span></span><br><span class="line"><span class="string">　　Android提供了两种创建布局的方式：  </span></span><br><span class="line"><span class="string">　　　　1.在XML配置文件中声明（推荐）。  </span></span><br><span class="line"><span class="string">　　　　2.在程序中通过代码直接实例化布局及其组件。  </span></span><br><span class="line"><span class="string">在Android中常见的布局方式：  </span></span><br><span class="line"><span class="string">线性布局（LinearLayout）：按照垂直或者水平方向布局组件。  </span></span><br><span class="line"><span class="string">　　帧布局（FrameLayout）：组件从屏幕的左上角坐标布局组件。  </span></span><br><span class="line"><span class="string">　　表格布局（TableLayout）：按照行列方式布局组件。  </span></span><br><span class="line"><span class="string">　　相对布局（RelativeLayout）：相对其他组件的布局方式。  </span></span><br><span class="line"><span class="string">　　绝对布局（AbsoluteLayout）：按照绝对坐标来布局组件。（已废）。  </span></span><br><span class="line"><span class="string">2、一个ListView通常有两个职责。  </span></span><br><span class="line"><span class="string">（1）将数据填充到布局。  </span></span><br><span class="line"><span class="string">（2）处理用户的选择点击等操作。  </span></span><br><span class="line"><span class="string">第一点很好理解，ListView就是实现这个功能的。第二点也不难做到，在后面的学习中读者会发现，这非常简单。  </span></span><br><span class="line"><span class="string">一个ListView的创建需要3个元素。  </span></span><br><span class="line"><span class="string">（1）ListView中的每一列的View。  </span></span><br><span class="line"><span class="string">（2）填入View的数据或者图片等。  </span></span><br><span class="line"><span class="string">（3）连接数据与ListView的适配器。  </span></span><br><span class="line"><span class="string">3、关于List&lt;E&gt;的用法  </span></span><br><span class="line"><span class="string">List l=new List();  </span></span><br><span class="line"><span class="string"> 现在这样，如果你想放得是User类，就这样new:  </span></span><br><span class="line"><span class="string"> List &lt;User&gt; l=new List &lt;User&gt;();  </span></span><br><span class="line"><span class="string"> 这样编译器就可以帮你监督，如果你往里面放其他类对象，就会报错咯。  </span></span><br><span class="line"><span class="string"> 当然好处就是你拿出来就是User类对象，不用再强制转换了。比如过去：  </span></span><br><span class="line"><span class="string"> User u=(User)l.get(1);  </span></span><br><span class="line"><span class="string"> 现在就可以：  </span></span><br><span class="line"><span class="string"> User u=l.get(1);  </span></span><br><span class="line"><span class="string">4、ArrayList &amp;&amp; HashMap 的使用 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">``` java</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> 	ArrayList&lt;HashMap&lt;String,String&gt;&gt; list=new ArrayList&lt;HashMap&lt;String,String&gt;&gt;();  </span></span><br><span class="line"><span class="string">        HashMap&lt;String,String&gt; map1= new HashMap&lt;String,String&gt;();  </span></span><br><span class="line"><span class="string">        HashMap&lt;String,String&gt; map2= new HashMap&lt;String,String&gt;();  </span></span><br><span class="line"><span class="string">        HashMap&lt;String,String&gt; map3= new HashMap&lt;String,String&gt;();  </span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">        map1.put(&quot;</span>user<span class="string">&quot;, &quot;</span>zhang<span class="string">&quot;);  </span></span><br><span class="line"><span class="string">        map1.put(&quot;</span>id<span class="string">&quot;, &quot;</span><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span><span class="string">&quot;);  </span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">        map2.put(&quot;</span>user<span class="string">&quot;, &quot;</span>wang<span class="string">&quot;);  </span></span><br><span class="line"><span class="string">        map2.put(&quot;</span>id<span class="string">&quot;, &quot;</span><span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span><span class="string">&quot;);  </span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">        list.add(map1);  </span></span><br><span class="line"><span class="string">        list.add(map2);  </span></span><br><span class="line"><span class="string">        list.add(map3); </span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Log.v(&quot;</span>ArrayList==HashMap===:<span class="string">&quot;, list.toString());</span></span><br><span class="line"><span class="string">        </span></span><br></pre></td></tr></table></figure>

<h3 id="AlertDialog-的使用"><a href="#AlertDialog-的使用" class="headerlink" title="AlertDialog 的使用"></a>AlertDialog 的使用</h3><pre><code class="java">         
         Builder alertDialog = new AlertDialog.Builder(this);
         alertDialog.setTitle(&quot;标题&quot;);// 设置标题
         alertDialog.setMessage(&quot;一个消息框&quot;);// 设置消息
         alertDialog.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123;
             
             @Override
             public void onClick(DialogInterface dialog, int which) &#123;
                 // toast 的用法
                 Toast.makeText(getApplicationContext(), &quot;你选择了确定&quot;,
                         Toast.LENGTH_SHORT).show();
             &#125;
         &#125;);
         alertDialog.show();
         
</code></pre>
<h3 id="Button-的使用-通过具体的id-找到某个控件"><a href="#Button-的使用-通过具体的id-找到某个控件" class="headerlink" title="Button 的使用: 通过具体的id 找到某个控件"></a>Button 的使用: 通过具体的id 找到某个控件</h3><pre><code class="java">        // 给按钮加上点击事件
        clickMeButton.setOnClickListener(new OnClickListener() &#123;
            @Override
            public void onClick(View v) &#123;
                Log.v(&quot;click&quot;, &quot;=======clickButton=======&quot;);
                // 跳转到SecondActivity页面
                Intent intent = new Intent();
                intent.setClass(MainActivity.this, SecondActivity.class);
                startActivity(intent);
            &#125;
        &#125;);
        
</code></pre>
<h3 id="dp是虚拟像素，在不同的像素密度的设备上会自动适配，比如"><a href="#dp是虚拟像素，在不同的像素密度的设备上会自动适配，比如" class="headerlink" title="dp是虚拟像素，在不同的像素密度的设备上会自动适配，比如:"></a>dp是虚拟像素，在不同的像素密度的设备上会自动适配，比如:</h3><p>在320x480分辨率，像素密度为160,1dp=1px<br>在480x800分辨率，像素密度为240,1dp=1.5px<br>计算公式:1dp*像素密度/160 = 实际像素数<br>px（像素）：屏幕上的点。<br>dp（与密度无关的像素）：一种基于屏幕密度的抽象单位。在每英寸160点的显示器上，1dp = 1px。<br>尽量使用dp作为空间大小单位，sp作为和文字相关大小单位 </p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>android学习(2014、11、19)</title>
    <url>/2018/06/11/android/android%E5%AD%A6%E4%B9%A02014-11-19/</url>
    <content><![CDATA[<!--2014、11、19-->
<p>1、fragment的使用<br>Fragment必须是依存与Activity而存在的<br><a href="http://blog.csdn.net/lmj623565791/article/details/37970961">http://blog.csdn.net/lmj623565791/article/details/37970961</a><br>找fragment的方法：<br>LeftFragment fragment = (LeftFragment) getFragmentManager().findFragmentById(R.id.left_fragment);<br>2、Java关键字final、static使用总结</p>
<p>一、final<br>　根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。<br>final类不能被继承，没有子类，final类中的方法默认是final的。<br>final方法不能被子类的方法覆盖，但可以被继承。<br>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。<br>final不能用于修饰构造方法。<br>注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。<br>1、final类<br>　final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。<br>2、final方法<br>如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。<br>使用final方法的原因有二：<br>第一、把方法锁定，防止任何继承类修改它的意义和实现。<br>第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="comment">// TODO 自动生成方法存根 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;f1&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//无法被子类覆盖的方法 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;f2&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;f3&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;f4&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">Test1</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;Test1父类方法f1被覆盖!&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">Test2 t=<span class="keyword">new</span> Test2(); </span><br><span class="line">t.f1(); </span><br><span class="line">t.f2(); <span class="comment">//调用从父类继承过来的final方法 </span></span><br><span class="line">t.f3(); <span class="comment">//调用从父类继承过来的方法 </span></span><br><span class="line"><span class="comment">//t.f4(); //调用失败，无法从父类继承获得 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>3、final变量（常量）<br>　用final修饰的成员变量表示常量，值一旦给定就无法改变！<br>　final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。<br>　从下面的例子中可以看出，一旦给final变量初值后，值就不能再改变了。<br>　另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.leizhimin; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String S=<span class="string">&quot;final实例变量S&quot;</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> A=<span class="number">100</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> B=<span class="number">90</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> C=<span class="number">80</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> D=<span class="number">70</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> E; <span class="comment">//final空白,必须在初始化对象的时候赋初值 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; </span><br><span class="line">E=x; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">Test3 t=<span class="keyword">new</span> Test3(<span class="number">2</span>); </span><br><span class="line"><span class="comment">//t.A=101; //出错,final变量的值一旦给定就无法改变 </span></span><br><span class="line"><span class="comment">//t.B=91; //出错,final变量的值一旦给定就无法改变 </span></span><br><span class="line"><span class="comment">//t.C=81; //出错,final变量的值一旦给定就无法改变 </span></span><br><span class="line"><span class="comment">//t.D=71; //出错,final变量的值一旦给定就无法改变 </span></span><br><span class="line">System.out.println(t.A); </span><br><span class="line">System.out.println(t.B); </span><br><span class="line">System.out.println(t.C); <span class="comment">//不推荐用对象方式访问静态字段 </span></span><br><span class="line">System.out.println(t.D); <span class="comment">//不推荐用对象方式访问静态字段 </span></span><br><span class="line">System.out.println(Test3.C); </span><br><span class="line">System.out.println(Test3.D); </span><br><span class="line"><span class="comment">//System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. </span></span><br><span class="line">System.out.println(t.E); </span><br><span class="line">Test3 t1=<span class="keyword">new</span> Test3(<span class="number">3</span>); </span><br><span class="line">System.out.println(t1.E); <span class="comment">//final空白变量E依据对象的不同而不同 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123; </span><br><span class="line">System.out.println(<span class="keyword">new</span> Test3(<span class="number">1</span>).A); </span><br><span class="line">System.out.println(Test3.C); </span><br><span class="line">System.out.println(Test3.D); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> a; <span class="comment">//final空白,在需要的时候才赋值 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> b=<span class="number">4</span>; <span class="comment">//局部常量--final用于局部变量的情形 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> c; <span class="comment">//final空白,一直没有给赋值. </span></span><br><span class="line">a=<span class="number">3</span>; </span><br><span class="line"><span class="comment">//a=4; 出错,已经给赋过值了. </span></span><br><span class="line"><span class="comment">//b=2; 出错,已经给赋过值了. </span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>4、final参数<br>当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="keyword">new</span> Test4().f1(<span class="number">2</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span></span>&#123; </span><br><span class="line"><span class="comment">//i++; //i是final类型的,值不允许改变的. </span></span><br><span class="line">System.out.print(i); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>二、static<br>　static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。<br>　被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。<br>　用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。<br>　static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用–废话），但是不能在其他类中通过类名来直接引用，这一点很重要。实际上你需要搞明白，private是访问权限限定，static表示不要实例化就可以使用，这样就容易理解多了。static前面加上其它访问权限关键字的效果也以此类推。<br>　static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：<br>类名.静态方法名(参数列表…)<br>类名.静态变量名<br>　用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块（用处非常大，呵呵）。<br>1、static变量<br>　按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：<br>　对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。<br>　对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。<br>2、静态方法<br>　静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！<br>　因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。<br>3、static代码块<br>　static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。例如：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> b; </span><br><span class="line"><span class="keyword">static</span>&#123; </span><br><span class="line">Test5.a=<span class="number">3</span>; </span><br><span class="line">System.out.println(a); </span><br><span class="line">Test5 t=<span class="keyword">new</span> Test5(); </span><br><span class="line">t.f(); </span><br><span class="line">t.b=<span class="number">1000</span>; </span><br><span class="line">System.out.println(t.b); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">static</span>&#123; </span><br><span class="line">Test5.a=<span class="number">4</span>; </span><br><span class="line">System.out.println(a); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="comment">// TODO 自动生成方法存根 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">static</span>&#123; </span><br><span class="line">Test5.a=<span class="number">5</span>; </span><br><span class="line">System.out.println(a); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;hhahhahah&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>3<br>hhahhahah<br>1000<br>4<br>5<br>　利用静态代码块可以对一些static变量进行赋值，最后再看一眼这些例子，都一个static的main方法，这样JVM在运行main方法的时候可以直接调用而不用创建实例。<br>4、static和final一块用表示什么<br>static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！<br>对于变量，表示一旦给值就不可修改，并且通过类名可以访问。<br>对于方法，表示不可覆盖，并且可以通过类名直接访问。</p>
<p>【自己补充的】<br>5、static还可以修饰内部类，普通类是不允许声明为静态的，只有内部类才可以。被static修饰的内部类可以直接作为一个普通类来使用，而不需实例化一个外部类<br>例如有个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestInner</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在main中实例化StaticInnerClass的代码是这样写<br>new TestInner.StaticInnerClass();<br>而实例化InnerClass则必须写成<br>TestInner testInner = new TestInner();<br>testInner.new InnerClass();<br>所以要注意了哦！<br>而且呢，在InnerClass里面已经无法再声明static innner class了，因为The member type inner cannot be declared static; static types can only be declared in static or top level types  </p>
<!--11.28-->
<p>抽象类 abstract class<br>     包含抽象方法的类，叫抽象类。而抽象的概念就是抽象出共同属性：成员变量和方法。所以抽象类可以有private等多种权限的成员变量和非abstract的成员方法。当然抽象方法是一定要有的。<br>    抽象类是用于单一继承的，不能实例化。而继承类一定要实现抽象方法，因为抽象方法在抽象类里是没有实现行为的，访问权限只能是public。而非抽象方法则可以赋予方法的默认行为，访问权限可以多种，但需要考虑非抽象方法是否需要被继承类访问。<br>接口 interface<br>     接口，用于多重继承，也不能实例化。只能包含static final的成员变量，不过在interface中一般不定义成员变量。而成员方法在接口里只能是抽象方法，访问权限只能是public。<br><a href="http://android.blog.51cto.com/268543/385282/">http://android.blog.51cto.com/268543/385282/</a> </p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>dart</title>
    <url>/2018/06/11/dart%20&amp;%20flutter/dart/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/av52490605?from=search&seid=17339603939810978479">Dart Flutter教程</a></p>
<h2 id="dart"><a href="#dart" class="headerlink" title="dart"></a>dart</h2><p><strong>安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew tap dart-lang/dart</span><br><span class="line">brew install dart</span><br></pre></td></tr></table></figure>
<p><strong>开发工具：</strong><br><code>vscode</code> 安装插件 <code>dart</code> 和 <code>code runner</code></p>
]]></content>
      <categories>
        <category>dart</category>
      </categories>
      <tags>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh</title>
    <url>/2018/06/11/git/git%20%E4%B9%8B%20ssh/</url>
    <content><![CDATA[<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>你拥有了一个 GitHub 账号之后，就可以自由的 clone 或者下载其他项目，也可以创建自己的项目，但是你没法提交代码。仔细想想也知道，肯定不可能随意就能提交代码的，如果随意可以提交代码，那么 GitHub 上的项目岂不乱了套了，所以提交代码之前一定是需要某种授权的，而 GitHub 上一般都是基于 SSH 授权的。<br>那么什么是 SSH 呢？ 简单点说，SSH是一种网络协议，用于计算机之间的加密登录。目前是每一台 Linux 电脑的标准配置。而大多数 Git 服务器都会选择使用 SSH 公钥来进行授权，所以想要在 GitHub 提交代码的第一步就是要先添加 SSH key 配置。</p>
<h3 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h3><p>Linux 与 Mac 都是默认安装了 SSH ，而 Windows 系统安装了 Git Bash 应该也是带了 SSH 的。大家可以在终端（win下在 Git Bash 里）输入 ssh 检测是否已安装。</p>
<p>紧接着输入 <code>ssh-keygen -t rsa</code> 或者<code>（ssh-keygen -t rsa -C “邮箱名&quot;）</code> ，什么意思呢？就是指定 rsa 算法生成密钥，接着连续三个回车键（不需要输入密码），然后就会生成两个文件 <code>id_rsa</code> 和 <code>id_rsa.pub</code> ，而 <code>id_rsa</code> 是密钥，<code>id_rsa.pub</code> 就是公钥。这两文件默认分别在如下目录里生成：<br><code>Linux/Mac</code> 系统 在<code> ~/.ssh</code> 下，win系统在 <code>/c/Documents and Settings/username/.ssh</code> 下，都是隐藏文件，相信你们有办法查看的。<br>接下来要做的是把 <code>id_rsa.pub </code>的内容添加到 GitHub 上，这样你本地的 <code>id_rsa</code> 密钥跟 GitHub 上的 <code>id_rsa.pub</code> 公钥进行配对，授权成功才可以提交代码。</p>
<h3 id="GitHub-上添加-SSH-key"><a href="#GitHub-上添加-SSH-key" class="headerlink" title="GitHub 上添加 SSH key"></a>GitHub 上添加 SSH key</h3><p>第一步先在 GitHub 上的设置页面，点击最左侧 SSH and GPG keys ：</p>
<h3 id="怎么查看-id-rsa-pub-文件的内容？"><a href="#怎么查看-id-rsa-pub-文件的内容？" class="headerlink" title="怎么查看 id_rsa.pub 文件的内容？"></a>怎么查看 id_rsa.pub 文件的内容？</h3><p>Linux/Mac 用户执行以下命令：<br>cd ~/.ssh<br>cat id_rsa.pub</p>
<h3 id="测试是否ok"><a href="#测试是否ok" class="headerlink" title="测试是否ok"></a>测试是否ok</h3><p>SSH key 添加成功之后，输入 ssh -T <a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#111;&#109;">&#x67;&#105;&#116;&#64;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#111;&#109;</a> 进行测试</p>
<p><a href="http://stormzhang.com/github/2016/06/04/learn-github-from-zero4/">ssh向GITHUB 提交代码</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>git 如何删除缓存的远程分支列表.md</title>
    <url>/2018/06/11/git/git%20%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></p>
<h2 id="列出远程分支"><a href="#列出远程分支" class="headerlink" title="列出远程分支"></a>列出远程分支</h2><p>使用git 部署代码，<pre> git branch -a </pre> 里面列出的很多远程的分支，其实都是已经被删除了的。</p>
<h2 id="删除缓存的远程分支列表"><a href="#删除缓存的远程分支列表" class="headerlink" title="删除缓存的远程分支列表"></a>删除缓存的远程分支列表</h2><p>用此命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote prune origin</span><br><span class="line">or</span><br><span class="line">git fetch -p   </span><br></pre></td></tr></table></figure>
<p>即可解决</p>
<h2 id="列出提交个数"><a href="#列出提交个数" class="headerlink" title="列出提交个数"></a>列出提交个数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rev-list --count HEAD</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git删除缓存远程分支</tag>
      </tags>
  </entry>
  <entry>
    <title>git项目中的常用功能</title>
    <url>/2018/06/11/git/git%20%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h3 id="列出提交个数-主要用来设置项目build号"><a href="#列出提交个数-主要用来设置项目build号" class="headerlink" title="列出提交个数   主要用来设置项目build号"></a>列出提交个数   主要用来设置项目build号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rev-list --count HEAD</span><br></pre></td></tr></table></figure>

<h3 id="获得两个版本间所有变更的文件列表"><a href="#获得两个版本间所有变更的文件列表" class="headerlink" title="获得两个版本间所有变更的文件列表"></a>获得两个版本间所有变更的文件列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff 6962e097c87bcbd937eb59d94f9f79b9a709455d   </span><br><span class="line">c02e20f5ad5eb1a675b6b3d30fed5b66f309871c --stat &gt; log.txt -p</span><br></pre></td></tr></table></figure>

<h3 id="查看某个文件的修改历史"><a href="#查看某个文件的修改历史" class="headerlink" title="查看某个文件的修改历史"></a>查看某个文件的修改历史</h3><p><code>git log -p filePath/fileName.m </code></p>
<h3 id="使用-pull-rebase-操作替代-merge"><a href="#使用-pull-rebase-操作替代-merge" class="headerlink" title="使用 pull rebase 操作替代 merge"></a>使用 pull rebase 操作替代 merge</h3><p>　　如果你工作的团队正工作在同一个分支，那么你所要做的获取/合并或经常拉取。分支合并的 git 记录与合并提交时提示功能分支被并入主干。但在多个团队成员工作的同一分支的情况下，经常合并导致在日志中多个合并的消息引起混乱。所以你可以使用 pull rebase，以保持历史信息清除了无用合并的消息。</p>
<p><code>git config branch.BRANCH_NAME_HERE.rebase true</code></p>
<p>　　此外，您可以配置一个特定的分支总是衍合：</p>
<p><code>git pull --rebase </code></p>
<h3 id="gc-命令"><a href="#gc-命令" class="headerlink" title="gc 命令"></a>gc 命令</h3><p>“垃圾回收”是一个很亲切的功能。让我们开始吧：<br><code>$ git gc --prune=now</code><br>现在，重新检视一下仓库的大小，发现确实有效啊：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/info/packs</span><br><span class="line">.git/objects/pack/pack-9d75315485cb7bfbf51ce5c94a4535da99b58dbb.idx</span><br><span class="line">.git/objects/pack/pack-9d75315485cb7bfbf51ce5c94a4535da99b58dbb.pack</span><br><span class="line">$</span><br><span class="line">$ du -ah    # 此处略去了无关输出</span><br><span class="line">4.0K    ./.git/objects/pack/pack-9d75315485cb7bfbf51ce5c94a4535da99b58dbb.idx</span><br><span class="line"> 52M    ./.git/objects/pack/pack-9d75315485cb7bfbf51ce5c94a4535da99b58dbb.pack</span><br><span class="line"> 77M    ./bigfile</span><br><span class="line">130M    .</span><br></pre></td></tr></table></figure>

<h3 id="cherry-pick用法"><a href="#cherry-pick用法" class="headerlink" title="cherry-pick用法"></a>cherry-pick用法</h3><p>使用场景：在branch1开发，进行多个提交，这是切换到branch2，想把之前branch1分支提交的commit都复制过来。</p>
<p>单个<code>commit</code>只需要<code>git cherry-pick commitid</code></p>
<p>多个<code>commit</code> 只需要<code>git cherry-pick commitid1..commitid100</code></p>
<p>注意，不包含第一个<code>commitid</code> ， 即  <code>git cherry-pick (commitid1..commitid100]</code></p>
<h3 id="Git更新远程分支列表"><a href="#Git更新远程分支列表" class="headerlink" title="Git更新远程分支列表"></a>Git更新远程分支列表</h3><p><code>git remote update origin --prune</code></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git删除缓存远程分支</tag>
      </tags>
  </entry>
  <entry>
    <title>git 本地仓库 更换远程仓库</title>
    <url>/2018/06/11/git/git%20%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%20%E6%9B%B4%E6%8D%A2%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></p>
<h2 id="git修改远程仓库地址的三种方法"><a href="#git修改远程仓库地址的三种方法" class="headerlink" title="git修改远程仓库地址的三种方法"></a>git修改远程仓库地址的三种方法</h2><h3 id="直接命令修改"><a href="#直接命令修改" class="headerlink" title="直接命令修改"></a>直接命令修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote set-url origin [url]</span><br></pre></td></tr></table></figure>

<h3 id="命令，先删除后设新地址"><a href="#命令，先删除后设新地址" class="headerlink" title="命令，先删除后设新地址"></a>命令，先删除后设新地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git remote rm origin </span><br><span class="line">git remote add origin [url]</span><br></pre></td></tr></table></figure>

<h3 id="直接修改配置文件"><a href="#直接修改配置文件" class="headerlink" title="直接修改配置文件"></a>直接修改配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件位置：git/config </span><br><span class="line">config</span><br><span class="line"></span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = false</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">    symlinks = false</span><br><span class="line">    ignorecase = true</span><br><span class="line">[gui]</span><br><span class="line">    wmstate = normal</span><br><span class="line">    geometry = 841x483+225+101 189 218</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = git@github.com:project.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br></pre></td></tr></table></figure>

<h3 id="补充：如果用sourcetree的话可以直接修改远程仓库地址"><a href="#补充：如果用sourcetree的话可以直接修改远程仓库地址" class="headerlink" title="补充：如果用sourcetree的话可以直接修改远程仓库地址"></a>补充：如果用sourcetree的话可以直接修改远程仓库地址</h3>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>更换远程仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>初始化git仓库项目.md</title>
    <url>/2018/06/11/git/%E5%88%9D%E5%A7%8B%E5%8C%96git%E4%BB%93%E5%BA%93%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></p>
<h1 id="Command-line-instructions-命令行指令"><a href="#Command-line-instructions-命令行指令" class="headerlink" title="Command line instructions 命令行指令"></a>Command line instructions 命令行指令</h1><h2 id="Git-global-setup"><a href="#Git-global-setup" class="headerlink" title="Git global setup"></a>Git global setup</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">git config --global user.email &quot;xxx@email.com&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Create-a-new-repository"><a href="#Create-a-new-repository" class="headerlink" title="Create a new repository"></a>Create a new repository</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@git.jd.com:xxx/yyy.git</span><br><span class="line">cd JDViewKitDoc</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;add README&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="Existing-folder"><a href="#Existing-folder" class="headerlink" title="Existing folder"></a>Existing folder</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd existing_folder</span><br><span class="line">git init</span><br><span class="line">git remote add origin git@git.jd.com:xxx/yyy.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h2 id="Existing-Git-repository"><a href="#Existing-Git-repository" class="headerlink" title="Existing Git repository"></a>Existing Git repository</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd existing_repo</span><br><span class="line">git remote add origin git@git.jd.com:xxx/yyy.git</span><br><span class="line">git push -u origin --all</span><br><span class="line">git push -u origin --tags</span><br></pre></td></tr></table></figure>

<h2 id="问题解决方案"><a href="#问题解决方案" class="headerlink" title="问题解决方案"></a>问题解决方案</h2><h3 id="fatal-refusing-to-merge-unrelated-histories-解决方案"><a href="#fatal-refusing-to-merge-unrelated-histories-解决方案" class="headerlink" title="fatal: refusing to merge unrelated histories 解决方案"></a>fatal: refusing to merge unrelated histories 解决方案</h3><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>可以使用 rebase 的方式来进行合并。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull --rebase origin master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd</span><br><span class="line">mkdir rebaseTmp</span><br><span class="line">cd rebaseTmp</span><br><span class="line">echo &quot;hello a line&quot; &gt; tmp.txt</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Local first commit&quot;</span><br><span class="line">git remote add origin  https://github.com/HustLion/java_console_log4j.git</span><br><span class="line">git pull --rebase origin master</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>git gitignore的设置</title>
    <url>/2018/06/11/git/%E6%B7%BB%E5%8A%A0%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="在项目中添加-gitignore文件"><a href="#在项目中添加-gitignore文件" class="headerlink" title="在项目中添加.gitignore文件"></a>在项目中添加.gitignore文件</h3><blockquote>
<p>.gitignore文件可以直接从 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 上面下载，里面包含了各个语言对应的.gitignore文件</p>
</blockquote>
<h3 id="配置添加所需要忽略的文件或者文件类型"><a href="#配置添加所需要忽略的文件或者文件类型" class="headerlink" title="配置添加所需要忽略的文件或者文件类型"></a>配置添加所需要忽略的文件或者文件类型</h3><blockquote>
<p>使用命令vim .gitignore打开.gitignore文件，回车后 添加和修改要忽略的文件</p>
</blockquote>
<h3 id="将-gitignore文件提交到仓库"><a href="#将-gitignore文件提交到仓库" class="headerlink" title="将.gitignore文件提交到仓库"></a>将.gitignore文件提交到仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .gitignore</span><br><span class="line">git commit -m &quot;添加项目忽略文件&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交.gitignore文件的目的主要是保证其他开发者提交的时候也会自动筛选掉不需要的文件，因为已提交到仓库的文件再设置.gitignore文件中忽略是无效的，需要先将其移除版本控制后，.gitignore文件才会生效。具体方法见下文。</p>
</blockquote>
<h3 id="关于-git-将文件或文件夹移除版本控制"><a href="#关于-git-将文件或文件夹移除版本控制" class="headerlink" title="关于 git 将文件或文件夹移除版本控制"></a>关于 git 将文件或文件夹移除版本控制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm -r -n --cached &quot;bin/&quot; //-n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。</span><br><span class="line">git rm -r --cached  &quot;bin/&quot;      //最终执行命令. </span><br><span class="line">git commit -m&quot; remove bin folder all file out of control&quot;    //提交</span><br><span class="line">git push    //提交到远程服务器</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果是要忽略一种类型的文件（如.DS_Store文件），将bin/换成*.DS_Store即可。</p>
</blockquote>
<h3 id="设置Git全局忽略文件方法"><a href="#设置Git全局忽略文件方法" class="headerlink" title="设置Git全局忽略文件方法"></a>设置Git全局忽略文件方法</h3><p>配置全局忽略文件的我们就不必给每一个项目添加单独的忽略文件<br>1、 进入用户目录下，将第一步中配置好的.gitignore文件拷贝到用户目录下，将这个文件改个名字，名字随意，自己好认就行<br>2、 执行命令git config –global core.excludesfile ~/.gitignore_globalxxxx</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>命令git config –global core.excludesfile ~/.gitignore_globalaaaa的效果其实就是修改了在用户目录下的.gitconfig文件</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title>weex compile + 访问</title>
    <url>/2018/06/11/vue%20&amp;%20weex/weex%20compile%20+%20%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h2 id="本地启的服务测试（访问地址）："><a href="#本地启的服务测试（访问地址）：" class="headerlink" title="本地启的服务测试（访问地址）："></a>本地启的服务测试（访问地址）：</h2><p><a href="http://xxxx/jsTest/PromotionHome.js">http://xxxx/jsTest/PromotionHome.js</a></p>
<blockquote>
<p>xxxx/jsTest 本地服务地址 + 存放js的目录</p>
</blockquote>
<h2 id="vue到js文件编译拷贝两步骤："><a href="#vue到js文件编译拷贝两步骤：" class="headerlink" title="vue到js文件编译拷贝两步骤："></a>vue到js文件编译拷贝两步骤：</h2><p>weex compile PromotionHome.vue PromotionHome.js<br>cp PromotionHome.js /Library/WebServer/Documents/jsTest</p>
]]></content>
      <categories>
        <category>weex</category>
      </categories>
      <tags>
        <tag>weex 编译</tag>
      </tags>
  </entry>
  <entry>
    <title>weex 工作原理</title>
    <url>/2018/06/11/vue%20&amp;%20weex/weex%20%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="weex-工作原理"><a href="#weex-工作原理" class="headerlink" title="weex 工作原理"></a>weex 工作原理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transformer 会把 template, style, script 都转换成一段段 json 或者 js，</span><br><span class="line">这样客户端只接收并运行js，不必同时解析html/css这些语法，并且这些js还会继续进行</span><br><span class="line">数据监听和绑定，然后生成最终的virtual dom 再发送给 native端进行渲染。</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/yongbolv/images/master/weexframework.png"></p>
<h2 id="weex-主要就是做了三件事"><a href="#weex-主要就是做了三件事" class="headerlink" title="weex 主要就是做了三件事"></a>weex 主要就是做了三件事</h2><ol>
<li>在服务端用 Transformer 工具把 Vue 代码转换成 Js Bundle。</li>
<li>在客户端运行Js Framework 的 JavaScript 引擎，解释执行Js Bundle生成Virtual DOM。</li>
<li>在客户端设计一套 JS Bridge，能使IOS端（或者Android端）的Object-C语言（或Java语言）与Javascript语言相互调用，把Virtual Dom转换为DOM，渲染到页面。H5端直接和Js Framework 通讯，不需要Js Bridge。<br>如下为Virtual DOM 渲染为Dom的过程：<br><img src="https://raw.githubusercontent.com/yongbolv/images/master/virtualdom.png"></li>
</ol>
<h2 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECMAScript：定义了JavaScript语言的标准</span><br><span class="line">JavaScriptCore：应用在在wekit内核内的js引擎，浏览器有Safari。</span><br><span class="line">V8: 应用在chromium内的js引擎，浏览器有Chrome。</span><br><span class="line">JS引擎的作用都是解释和执行JavaScript代码。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有关JavaScript引擎解析的内容请查看  <a href="http://www.uml.org.cn/codeNorms/201306063.asp">JavaScriptCore解析</a></p>
<p>有关JavaScriptCore和V8的内容请查看：<a href="http://blog.csdn.net/milado_nju/article/details/22101681">JavaScript引擎</a></p>
<h2 id="怎么开始搭建个weex项目"><a href="#怎么开始搭建个weex项目" class="headerlink" title="怎么开始搭建个weex项目"></a>怎么开始搭建个weex项目</h2><p>相对比较简单看官方吧。<br>weex相关工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node.js</span><br><span class="line">weex-toolkit</span><br><span class="line">Weex Playground App</span><br></pre></td></tr></table></figure>

<h2 id="相关论坛"><a href="#相关论坛" class="headerlink" title="相关论坛"></a>相关论坛</h2><p><a href="https://github.com/weexteam/article/issues">weex 文章</a><br><a href="https://github.com/weexteam/article/issues/50">weex 调试</a><br><a href="http://alibaba.github.io/weex/doc/">weex 文档：</a><br><a href="http://www.kmhaoshuai.com/#!/articles/use-vuex-in-weex">weex中使用数据流工具Vuex实践</a><br><a href="http://lvyongbo.net/2016/09/27/weex%E6%8A%80%E6%9C%AF%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%C2%A0https://gitter.im/weexteam/cn?utm_source=share-link&utm_medium=link&utm_campaign=share-link">weex交流室</a></p>
]]></content>
      <categories>
        <category>weex</category>
      </categories>
      <tags>
        <tag>weex 工作原理</tag>
      </tags>
  </entry>
  <entry>
    <title>weex 开发坑点</title>
    <url>/2018/06/11/vue%20&amp;%20weex/weex%20%E5%9D%91%E7%82%B9/</url>
    <content><![CDATA[<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">0、div 执行v-for循环的时候 要设置动态宽 自动撑满在iOS上有问题</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(itemProduct,index) in productList&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;height:sliderHeight,width:brandItemBgWidth&#125;&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">style</span>=<span class="string">&quot;align-items: center;justify-content: center;&quot;</span>&gt;</span></span><br><span class="line">1、<span class="tag">&lt;<span class="name">text</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">text</span>&gt;</span>  该标签一定要写在一行否则native展示不对</span><br><span class="line">2、作为子组件里面的数据源一定要 这样写</span><br><span class="line">data: function () &#123; &#125;   必须加上function 不能做省略</span><br><span class="line">3、引入组件或者工具类</span><br><span class="line">  import PromotionWishLampItemView from &#x27;./PromotionWishLampItemView.vue’</span><br><span class="line"> import Util from &#x27;./PromotionUtil.js&#x27;</span><br><span class="line">4、引入的子组件要注册</span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        PromotionWishLampItemView</span><br><span class="line">    &#125;,&#125;</span><br><span class="line">5、控件属性进行双向绑定用v-bind 缩写是冒号 :</span><br><span class="line">6、例如生命周期函数created、mounted和methods是并列的函数体，methods存放自定义函数</span><br><span class="line">7、 foreach不支持直接break</span><br><span class="line">//                                _wishLamps.forEach(function (item, index) &#123;</span><br><span class="line">//////                                    foreach不支持直接break</span><br><span class="line">//                                &#125;);</span><br><span class="line">8、给某个对象添加属性并赋值的方式</span><br><span class="line">    if (typeof item.itemStyle == &#x27;undefined&#x27;) &#123;</span><br><span class="line">        console.log(&#x27;注册中 =====&#x27;);</span><br><span class="line">        //全局注册</span><br><span class="line">        Vue.set(item, &quot;itemStyle&quot;, &quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">9、数组剪切前四个（n个）的方案</span><br><span class="line">    _proList.slice(0, 4);</span><br><span class="line">10、数组添加对象的方式</span><br><span class="line">     _this.productList.push(wishLampDict);</span><br><span class="line">11、css style双向绑定要用花括号</span><br><span class="line">    :style=&quot;&#123;height:brandItemCurveHeight,width:brandItemWidth&#125;”</span><br><span class="line">12、json转化成能打印的字符串</span><br><span class="line">var str = JSON.stringify(result);</span><br><span class="line">console.log(&#x27;qryExclusiveDiscount-backData:&#x27; + str);</span><br><span class="line">13、通过某个比例scale计算字体大小 如果不是整形在android上显示有问题 </span><br><span class="line">this.contentFontSize = Math.round(26 * scale);</span><br><span class="line">14、通过某个比例scale计算字体大小 如果不是整形在android上显示有问题   通过向上取整显示个别有问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过向下取整 Math.floor </span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>weex</category>
      </categories>
      <tags>
        <tag>weex 坑点</tag>
      </tags>
  </entry>
  <entry>
    <title>如何判断代码运行在DEBUG还是RELEASE模式下？</title>
    <url>/2018/06/11/iOS/%20%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9C%A8DEBUG%E8%BF%98%E6%98%AFRELEASE%E6%A8%A1%E5%BC%8F%E4%B8%8B/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<p>首先确定下项目的 Build Settings 是否已经设置过宏定义 DEBUG，如何看呢？<br>点击 Build Settings ，然后在搜索框里输入‘macros’</p>
<p><img src="/images/debug.png"></p>
<blockquote>
<p>如果已经设置过，在 Preprocessor Macros 的 Debug 后面会有 DEBUG=1，如果没有，就手动设置下。<br>接下来就可以这样做了</p>
</blockquote>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">//do sth.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">//do sth.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://stackoverflow.com/a/9063682">http://stackoverflow.com/a/9063682</a></p>
<p>一般Apple已经为我们设置好了 DEBUG 的宏定义，所以，我们只要让 NSLog 在 DEBUG 模式下失效就好了，这样能让我们的程序运行起来更加稳定，同时我们也可以继续使用正规的 NSLog。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//put this in prefix.pch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> NSLog</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSLog(args, ...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>Category中的方法为什么会覆盖原来类中的方法？</title>
    <url>/2018/06/11/iOS/Category%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%A6%86%E7%9B%96%E5%8E%9F%E6%9D%A5%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="深入了解Category"><a href="#深入了解Category" class="headerlink" title="深入了解Category"></a>深入了解<code>Category</code></h3><p>我们都知道<code>OC</code>代码执行时会先转成<code>C\C++</code>代码，<code>OC</code>对象转成对应的结构体；<br><code>Category</code>对应的结构体我们可以通过将分类的<code>.m文件转成c++</code>文件查看：<br><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc xxxxx.m</code><br>即可生成对应的<code>.cpp</code>文件；<br>在<code>.cpp</code>文件中搜索<code>Category_t</code>可以看到<code>Category</code>对应的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct _category_t &#123;</span><br><span class="line">const char *name;</span><br><span class="line">struct _class_t *cls;</span><br><span class="line">const struct _method_list_t *instance_methods;</span><br><span class="line">const struct _method_list_t *class_methods;</span><br><span class="line">const struct _protocol_list_t *protocols;</span><br><span class="line">const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过观察结构体我们可以发现分类对应的结构体中有存储实例方法的列表、存储类方法的列表、存储协议的和属性的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过源码分析可知：系统是在运行时将分类中对应的实例方法、类方法等插入到了原来类或元类的方法列表中，且是在列表的前 </span><br><span class="line">边！所以，方法调用时通过isa去对应的类或元类的列表中查找对应的方法时先查到的是分类中的方法！查到后就直接调用不在继</span><br><span class="line">续查找。这即是’覆盖’的本质！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="存在多个分类，调用谁？"><a href="#存在多个分类，调用谁？" class="headerlink" title="存在多个分类，调用谁？"></a>存在多个分类，调用谁？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当有多个分类时，会调用哪个分类中的方法呢？</span><br><span class="line"></span><br><span class="line">这个是与编译顺序有关，最后编译的分类中对应的信息会在整合在类或元类对应列表的最前边。所以是调用最后编译的分类中的</span><br><span class="line">方法！可以查看Build Phases -&gt;Complie Source 中的编译顺序！</span><br></pre></td></tr></table></figure>


<p><a href="https://www.jianshu.com/p/dd57c39a5e4c">Category中的方法为什么会覆盖原来类中的方法？</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>lldb指令</title>
    <url>/2020/06/01/iOS/LLDB/</url>
    <content><![CDATA[<h4 id="p、po-打印值"><a href="#p、po-打印值" class="headerlink" title="p、po 打印值"></a>p、po 打印值</h4><p>打印相关的命令有：p、po。<br>p 和 po 的区别在于使用 po 只会输出对应的值，而 p 则会返回值的类型以及命令结果的引用名。</p>
<p>po：输出值<br>p：输出值+值类型+引用名+内存地址(xcode中有内存地址，其它平台不确定)<br>除此之外，p还隐藏了一个有意思的功能，常量的进制转换:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//默认打印为10进制</span><br><span class="line">(lldb) p 100</span><br><span class="line">(int) $8 = 100</span><br><span class="line">//转16进制</span><br><span class="line">(lldb) p/x 100</span><br><span class="line">(int) $9 = 0x00000064</span><br><span class="line">//转8进制</span><br><span class="line">(lldb) p/o 100</span><br><span class="line">(int) $10 = 0144</span><br><span class="line">//转二进制</span><br><span class="line">(lldb) p/t 100</span><br><span class="line">(int) $2 = 0b00000000000000000000000001100100</span><br></pre></td></tr></table></figure>

<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、dyld</span><br><span class="line">2、镜像，可执行文件，Mach-O，data，text</span><br><span class="line">3、符号表，符号</span><br><span class="line">4、共享存储</span><br><span class="line">5、符号动态绑定</span><br><span class="line">6、image list 镜像列表</span><br><span class="line">7、dis -s 地址 查看汇编</span><br><span class="line">8、register read x1 读取寄存器</span><br><span class="line">9、po (SEL) 读取寄存器显示的地址     会具体显示调用的方法</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>lldb</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>NSRunloop工作原理和相关应用</title>
    <url>/2018/06/11/iOS/NSRunloop%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="NSRunloop与程序运行"><a href="#NSRunloop与程序运行" class="headerlink" title="NSRunloop与程序运行"></a>NSRunloop与程序运行</h3><p>　　　那么具体什么是NSRunLoop呢?其实NSRunLoop的本质是一个消息机制的处理模式。让我们首先来看一下程序的入口——main.m文件，一个ios程序启动后，只有短短的十行代码居然能保持整个应用程序一直运行而没有退出，是不是有点意思？程序之所以没有直接退出是因为UIApplicationMain这个函数内部默认启动了一个跟主线程相关的NSRunloop对象，而UIApplicationMain这个函数一直执行没有返回就保存程序一直运行的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　文章之初我们暂且将NSRunloop理解为实现这样功能的一段代码 , 这可以帮助我们更好的理解NSRunloop处理事件的过程(实际上远比这复杂的多：）)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">  BOOL runnning =YES;</span><br><span class="line">   do&#123;</span><br><span class="line">        ...</span><br><span class="line">       //处理各种操作 各种事件</span><br><span class="line">       ...</span><br><span class="line">      &#125;while(running);</span><br><span class="line">  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面用官方提供的一幅非常经典的图片，来认识NSRunloop循环处理时间的流程。</p>
<p><img src="http://www.cocoachina.com/cms/uploads/allimg/120703/4064_120703135151_1.png"><br>通过所有的“消息”都被添加到了<code>NSRunLoop</code>中去，而在这里这些消息并分为<code>input source</code>和<code>Timer source</code> 并在循环中检查是不是有事件需要发生，如果需要那么就调用相应的函数处理。由此形成了运行-&gt;检测-&gt;休眠 -&gt;运行 的循环状态。</p>
<p><a href="https://www.cnblogs.com/ruihaha/p/5813819.html">NSRunloop工作原理和相关应用</a></p>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>UIView与核心动画对比</title>
    <url>/2018/06/11/iOS/UIView%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p><a href="https://lianshumin.gitbooks.io/ocnotesii/content/03-UI%E8%BF%9B%E9%98%B6/11-%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB.html">核心动画</a></p>
<p><a href="https://lianshumin.gitbooks.io/ocnotesii/content/03-UI%E8%BF%9B%E9%98%B6/iOS%E5%8A%A8%E7%94%BB%E7%AF%87-1-UIView%E6%B8%90%E5%8F%98%E5%8A%A8%E7%94%BB.html">UIView渐变动画</a></p>
<p><a href="https://www.kancloud.cn/manual/ios/97760">iOS核心动画高级技巧</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode中和symbols有关的几个设置</title>
    <url>/2018/06/11/iOS/Xcode%E4%B8%AD%E5%92%8Csymbols%E6%9C%89%E5%85%B3%E7%9A%84%E5%87%A0%E4%B8%AA%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>在iOS开发中 特别是有framework打包的时候  经常遇到包比较大的问题。下面就来开下Xcode中和symbols有关的几个设置。</p>
<p><a href="https://www.jianshu.com/p/11710e7ab661">简书地址</a></p>
<p>Generate Debug Symbols 修改为NO后 能减少包的大小 但是debug功能就不能使用了</p>
<p>-<br><img src="https://img-blog.csdn.net/20150202124656301"><br><a href="https://www.cnblogs.com/jasontec/p/9601631.html">iOS可执行文件瘦身方法</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode中如何去掉默认的Main.storyboard</title>
    <url>/2018/06/11/iOS/Xcode%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8E%BB%E6%8E%89%E9%BB%98%E8%AE%A4%E7%9A%84Main.storyboard/</url>
    <content><![CDATA[<p>xcode 6取消了 Empty Application 模板来创建一个工程，创建出来的有工程多了Main.storyboard，默认加载Main.storyboard，但是有很多人还想用代码来实现UI的布局，去除Main.storyboard的有三步：</p>
<p><strong>修改</strong>  </p>
<ul>
<li><p>首先如图打开工程下面Supporting Files下面的Info.plist</p>
<p>  <code>Main storyboard file base name</code>删除这一行</p>
</li>
</ul>
<ul>
<li>其次找到工程的TAGETS/General/Deployment Info 删除Main。</li>
</ul>
<ul>
<li>经过上面两步算是删除了工程对Main.storyboard的依赖，但是运行工程后会发现是黑屏</li>
</ul>
<p>在AppDelegate中的- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 中添加以下代码即可解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</span><br><span class="line"> self.window.backgroundColor = [UIColor whiteColor];</span><br><span class="line">[self.window makeKeyAndVisible];</span><br></pre></td></tr></table></figure>

<p><strong>报错</strong>  </p>
<p>程序运行会提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Application windows are expected to have a root view controller at the end of application launch</span><br></pre></td></tr></table></figure>
<p><strong>解决方案</strong> </p>
<p>意思是应用程序期望拥有一个根控制器（RootViewController）<br>修改上面的代码，随便添加了一个控制器，程序就不抱错了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</span><br><span class="line">    self.window.backgroundColor = [UIColor whiteColor];</span><br><span class="line"></span><br><span class="line">    UITabBarController *tbc = [[UITabBarController alloc] init];</span><br><span class="line"></span><br><span class="line">    self.window.rootViewController = tbc;</span><br><span class="line"></span><br><span class="line">    [self.window makeKeyAndVisible];</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS之block</title>
    <url>/2018/06/11/iOS/iOS%20Block/</url>
    <content><![CDATA[<h4 id="1-block的定义：void-a"><a href="#1-block的定义：void-a" class="headerlink" title="1.block的定义：void(^a)()=^(){};"></a>1.block的定义：void(^a)()=^(){};</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">=前面：</span><br><span class="line">    <span class="keyword">void</span>:返回值类型；</span><br><span class="line">    ()():语法结构，第一个括号里面是block名字,第二个括号里面是参数列表，和c或java中参数列表写法一样；例如：<span class="keyword">int</span> i,<span class="keyword">char</span> c...</span><br><span class="line">    ^:脱字符，block标识</span><br><span class="line">    a:block名称，就像函数名，对象实例化名称，说白了就是一个名字；</span><br><span class="line">=号后面：</span><br><span class="line">    ^是block标识；</span><br><span class="line">    ()参数列表，当没有参数时，可以省略，但是“=”前面的()参数列表不能省略；</span><br><span class="line">    &#123;&#125;要执行的代码放在这里面，最后加“;”</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS之GCD</title>
    <url>/2018/06/11/iOS/iOS%20GCD/</url>
    <content><![CDATA[<p><a href="https://www.aliyun.com/jiaocheng/topic_13551.html">阿里云GCD</a></p>
<p><em>===============关于GCD的一些好用的函数===============</em></p>
<h4 id="一次性代码-多用于单例"><a href="#一次性代码-多用于单例" class="headerlink" title="一次性代码(多用于单例)"></a>一次性代码(多用于单例)</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;  </span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;;onceToken, ^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;once&quot;</span>); </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<h4 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h4><ul>
<li>perform</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以在运行时调用方法</span></span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)selector</span><br><span class="line"><span class="comment">//可带一个参数</span></span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)selector withObject:(<span class="keyword">id</span>)object</span><br><span class="line"><span class="comment">//可带两个参数</span></span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)selector withObject:(<span class="keyword">id</span>)object withObject:(<span class="keyword">id</span>)object</span><br><span class="line"><span class="comment">//可延时执行方法</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)selector withObject:(<span class="keyword">id</span>)argument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay</span><br><span class="line"><span class="comment">//可放到另一个线程中执行</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)selector onThread:(<span class="built_in">NSThread</span> *)thread withObject:(<span class="keyword">id</span>)argument waitUntilDone:(<span class="built_in">BOOL</span>)wait</span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)selector withObject:(<span class="keyword">id</span>)argument waitUntilDone:(<span class="built_in">BOOL</span>)wait</span><br><span class="line"> </span><br><span class="line"><span class="comment">//延后执行方法的两种实现方式：</span></span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(doSomething) withObject:<span class="literal">nil</span> afterDelay:<span class="number">5.0</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>GCD方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123;</span><br><span class="line">    [self doSomething];</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//把任务放在主线程执行的两种方式</span><br><span class="line">[self performSlectorOnMainThread:@selector(doSomething) withObject:nil waitUntilDone:NO];</span><br><span class="line"> </span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [self doSomething];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>1、</strong>performSelector系列方法在内存管理方面容易有疏失。它无法确定将要执行的选择子具体是什么，因而ARC编译器也就无法插入适当的内存管理方法。<br><strong>2、</strong>performSelector系列方法所能处理的选择子太过局限了，选择子的返回值类型及发送给方法的参数个数都受到限制。<br><strong>3、</strong>如果想把任务放在另一个线程上执行，那么最好不要用performSelector系列方法，而是应该把任务封装到块里，然后调用GCD的相关方法来实现。</p>
<h4 id="栅栏函数"><a href="#栅栏函数" class="headerlink" title="栅栏函数"></a>栅栏函数</h4><p>关键函数<code>dispatch_barrier_async </code> </p>
<ul>
<li>作用:只有当栅栏函数执行完毕后才能执行后面的函数</li>
<li>需求:使用栅栏函数规定线程执行顺序</li>
<li>注意:栅栏函数不能使用全局并发队列(否则没有意义)</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;download&quot;</span>, DISPATCH_QUEUE_CONCURRENT); </span><br><span class="line">   <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;task1 -- %zd -- %@&quot;</span>, i, [<span class="built_in">NSThread</span> currentThread]);&#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   dispatch_barrier_async(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;+++++++ barrier ++++++++&quot;</span>);</span><br><span class="line"></span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;task2 -- %zd -- %@&quot;</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><p>关键函数 <code>dispatch_apply</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_apply(<span class="number">6</span>, queue, ^(size_t index) &#123; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%zd------%@&quot;</span>,index, [<span class="built_in">NSThread</span> currentThread]); </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS JavaScriptCore使用</title>
    <url>/2018/06/11/iOS/iOS%20JavaScriptCore%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="iOS-JavaScriptCore使用"><a href="#iOS-JavaScriptCore使用" class="headerlink" title="iOS JavaScriptCore使用"></a>iOS JavaScriptCore使用</h3><p>JavaScriptCore是iOS7引入的新功能，JavaScriptCore可以理解为一个浏览器的运行内核，使用JavaScriptCore可以使用native代码（这里主要指objectiveC和swift）与js代码进行相互的调用，本文主要从几个方面进行了解。</p>
<ul>
<li>native调用js代码</li>
<li>js调用native代码</li>
<li>异常处理</li>
<li>JavaScriptCore和webView的结合使用</li>
</ul>
<p>要使用JavaScriptCore，首先我们需要引入它的头文件 <code>#import &lt;JavaScriptCore/JavaScriptCore.h&gt;</code><br>这个头里面引入了几个重要的对象</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;JSContext.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;JSValue.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;JSManagedValue.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;JSVirtualMachine.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;JSExport.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>JSContext是JavaScript的运行上下文，他主要作用是执行js代码和注册native方法接口</li>
<li>JSValue是JSContext执行后的返回结果，他可以是任何js类型（比如基本数据类型和函数类型，对象类型等），并且都有对象的方法转换为native对象。</li>
<li>JSManagedValue是JSValue的封装，用它可以解决js和原声代码之间循环引用的问题</li>
<li>JSVirtualMachine 管理JS运行时和管理js暴露的native对象的内存</li>
<li>JSExport是一个协议，通过实现它可以完成把一个native对象暴漏给js</li>
</ul>
<h3 id="native调用js代码"><a href="#native调用js代码" class="headerlink" title="native调用js代码"></a>native调用js代码</h3><p>先看下面常见的三种情况，之间执行js代码、执行文件或网络中的js代码、注册js方法再利用JSValue调用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接执行js代码</span></span><br><span class="line">- (<span class="keyword">void</span>)evaluateScript &#123;</span><br><span class="line">    <span class="comment">//定义一个js并执行函数</span></span><br><span class="line">    JSValue *exeFunction1 = [<span class="keyword">self</span>.jsContext evaluateScript:<span class="string">@&quot;function hi()&#123; return &#x27;hi&#x27; &#125;; hi()&quot;</span>];</span><br><span class="line">    <span class="comment">//执行一个闭包js</span></span><br><span class="line">    JSValue *exeFunction2 = [<span class="keyword">self</span>.jsContext evaluateScript:<span class="string">@&quot;(function()&#123; return &#x27;hi&#x27; &#125;)()&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行一段js文件中的代码</span></span><br><span class="line"><span class="comment">//更多的应用场景使用网络或者本地文件加载一段js代码，充分利用其灵活性</span></span><br><span class="line">- (<span class="keyword">void</span>)evaluateScriptFromJSFile &#123;</span><br><span class="line">    <span class="built_in">NSString</span> * path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;core&quot;</span> ofType:<span class="string">@&quot;js&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> * html = [<span class="built_in">NSString</span> stringWithContentsOfFile:path encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line">    JSValue *constructor = [<span class="keyword">self</span>.jsContext evaluateScript:html];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册js方法，然后在利用JSValue调用</span></span><br><span class="line">- (<span class="keyword">void</span>)regiestJSFunction &#123;</span><br><span class="line">    <span class="comment">//注册一个函数</span></span><br><span class="line">    [<span class="keyword">self</span>.jsContext evaluateScript:<span class="string">@&quot;var hello = function()&#123; return &#x27;hello&#x27; &#125;&quot;</span>];</span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    JSValue *value1 = [<span class="keyword">self</span>.jsContext evaluateScript:<span class="string">@&quot;hello()&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册一个匿名函数</span></span><br><span class="line">    JSValue *jsFunction = [<span class="keyword">self</span>.jsContext evaluateScript:<span class="string">@&quot; (function()&#123; return &#x27;hello objc&#x27; &#125;)&quot;</span>];</span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    JSValue *value2 = [jsFunction callWithArguments:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几个重要的地方需要说明。</p>
<h3 id="jsContext执行evaluateScript方法后的返回值类型"><a href="#jsContext执行evaluateScript方法后的返回值类型" class="headerlink" title="jsContext执行evaluateScript方法后的返回值类型"></a>jsContext执行evaluateScript方法后的返回值类型</h3><p>对于native来说，返回的类型都是JSValue，这是Native对js执行对象的统一封装类型，实际上他对应的js类型不同会导致它的使用方法也不相同，常见的类型比如返回数值类型和返回一个函数。<br>如果是返回数值类型，JSValue也对应了一组转换的API可以把JSValue转换成任何对于的native对象，例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)toArray;</span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)toDictionary;</span><br><span class="line">- (<span class="built_in">NSDate</span> *)toDate;</span><br><span class="line">- (<span class="built_in">NSString</span> *)toString;</span><br><span class="line">- (<span class="built_in">NSNumber</span> *)toNumber;</span><br><span class="line">- (uint32_t)toUInt32;</span><br><span class="line">- (<span class="keyword">id</span>)toObject;</span><br></pre></td></tr></table></figure>

<p>… 还有很多就不一一列举<br>如果返回的是一个函数类型，这可以使用 <code>jsvalue callWithArguments</code>方法进行js函数调用，例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册一个匿名函数</span></span><br><span class="line"> JSValue *jsFunction = [<span class="keyword">self</span>.jsContext evaluateScript:<span class="string">@&quot; (function() &#123; return &#x27;hello objc&#x27; &#125;)&quot;</span>];</span><br><span class="line"> <span class="comment">//调用</span></span><br><span class="line"> JSValue *value2 = [jsFunction callWithArguments:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>js是非常美妙的，主要这里的js是一段闭包代码，主要看下面两段代码的区别</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(function() &#123; <span class="keyword">return</span> <span class="string">&#x27;hello objc&#x27;</span> &#125;)</span><br><span class="line">function() &#123; <span class="keyword">return</span> <span class="string">&#x27;hello objc&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>第一行是一个闭包，在js中执行这段代码会返回一个函数，而第二行是定义一个函数，执行第二行的结果是定义了一个匿名函数，但是执行结果无返回值。<br>所以执行下面这段代码时省略了()，那么jsFunction的值就会为空了，很多移动端研发工程师不熟悉js代码很容易出现这样的错误。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">JSValue *jsFunction = [<span class="keyword">self</span>.jsContext evaluateScript:<span class="string">@&quot; (function() &#123; return &#x27;hello objc&#x27; &#125;)&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>当然如果我们在运行时中定义一个函数，后面也是可以调用的，只是不是使用callWithArguments方法了，示例如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.jsContext evaluateScript:<span class="string">@&quot;var hello = function()&#123; return &#x27;hello&#x27; &#125;&quot;</span>];  </span><br><span class="line"></span><br><span class="line"> JSValue *value1 = [<span class="keyword">self</span>.jsContext evaluateScript:<span class="string">@&quot;hello()&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>执行后的结果就是value1或得到一个string类型的值：“hello”</p>
<h3 id="js调用native代码"><a href="#js调用native代码" class="headerlink" title="js调用native代码"></a>js调用native代码</h3><p>js调用native代码之前需要native先注册接口，使用jsContext[“方法名”]就可以注册，后面是一个闭包，闭包可以定义函数参数，也可以使用 [JSContext currentArguments] 方法获取到所有函数调用的参数<br>看一段例子：<br>//注册js方法给Native调用</p>
<ul>
<li>(void)regiestNativeFunction {<br>  //注册一个objc方法给js调用<br>  self.jsContext[@”log”] = ^(NSString *msg){<pre><code>  NSLog(@&quot;js:msg:%@&quot;,msg);
</code></pre>
  };<br>  //另一种方式，利用currentArguments获取参数<br>  self.jsContext[@”log”] = ^() {<pre><code>  NSArray *args = [JSContext currentArguments];
  for (id obj in args) &#123; NSLog(@&quot;%@&quot;,obj); &#125;
</code></pre>
  };  //使用js调用objc<br>  [self.jsContext evaluateScript:@”log(‘hello,i am js side’)”];<br>}<br>block使用仍然需要注意循环引用的问题，所以在block中可以使用JSContext的静态方法 <code>+ (JSContext *)currentContext</code> 获取到context<br>初次之外，JSContext还可以获取到更多的内容，比如：<br>currentCallee<br>currentThis<br>currentArguments<br>globalObject<br>callee和this都是js中的对象，callee简单的说就是调用函数的对象，this类似于native中的self。<br>当然，jsContext中下标不仅仅可以放函数，也可以放对象和数值，对于熟悉js代码的人也不会觉得奇怪，因为js中基本上不太区分对象，函数的概念，对象和函数都是一样的东西。<br>除了使用jsContext下标方法暴露js对象以外，还可以使用JSExprot协议去把objc复杂对象转换成JSValue并暴露给js对象</li>
</ul>
<h3 id="JSExport对象的用法"><a href="#JSExport对象的用法" class="headerlink" title="JSExport对象的用法"></a>JSExport对象的用法</h3><p>1: 首先自定义个协议继承自JSExprot，并定义需要暴露给js的属性和方法，比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">JSPersonProtocol</span> &lt;<span class="title">JSExport</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *data;</span><br><span class="line">- (<span class="built_in">NSString</span> *)whatYouName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>2: 新建一个native对象，实现协议和方法,比如：<br>.h</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span>&lt;<span class="title">JSPersonProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)<span class="built_in">NSString</span> *name;</span><br><span class="line">- (<span class="built_in">NSString</span> *)whatYouName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>.m</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *)whatYouName &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@&quot;my name is liuyanwei&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@&quot;liuyanwei&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)useJSExprot &#123;</span><br><span class="line">    Person *p = [[Person alloc]init];</span><br><span class="line">    <span class="keyword">self</span>.jsContext[<span class="string">@&quot;person&quot;</span>] = p;</span><br><span class="line">    JSValue *value = [<span class="keyword">self</span>.jsContext evaluateScript:<span class="string">@&quot;person.whatYouName()&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后的结果就是，value的值为：my name is liuyanwei</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册js错误处理</span></span><br><span class="line">- (<span class="keyword">void</span>)jsExceptionHandler &#123;</span><br><span class="line">    <span class="keyword">self</span>.jsContext.exceptionHandler = ^(JSContext *con, JSValue *exception) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, exception);</span><br><span class="line">        con.exception = exception;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JavaScriptCore和UIWebView的结合使用"><a href="#JavaScriptCore和UIWebView的结合使用" class="headerlink" title="JavaScriptCore和UIWebView的结合使用"></a>JavaScriptCore和UIWebView的结合使用</h3><p>上面的代码都是基于JSContext的，如果声明了一个UIWebView，也可以使用UIWebView获取到JSContext对象，就可以使用JavaScriptCore的Api了，在UIWebView中获取JSContext的方法是：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">JSContext *context=[webView valueForKeyPath:<span class="string">@&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>不过遗憾的是WKWebView目前我还没有找到获取JSContext的方法，如果有知道的朋友也希望能联系我。</p>
<h3 id="JSVirtualMachine"><a href="#JSVirtualMachine" class="headerlink" title="JSVirtualMachine"></a>JSVirtualMachine</h3><p>在创建jscontext的时候，可以传入一个JSVirtualMachine对象，如果没有传入这个对象，会新建一个JSVirtualMachine对象。<br>JSVirtualMachine主要有3个作用：<br>1: 支持js并发，多个VM之间的js操作是并发的 1：使用JSVirtualMachine初始化的多个context，可以共享jsvalue对象 2：解决循环引用问题</p>
<blockquote>
<p>注意，当我们 export 一个 OC 或 Swift object 到 JS 中时，不能在这个object 中存储对应的 JS values。这种行为会导致一个retain cycle，JSValue objects 持有他们对应的 JSContext 的强引用，JSContext 则持有export到JS的native object的强引用，即 native object(OC or Swift object) —&gt; JSValue —&gt; JSContext —&gt; native object<br>参考</p>
</blockquote>
<ul>
<li><a href="https://blog.csdn.net/colorapp/article/details/51059645">JavaScriptCore学习之JavaScriptCore</a></li>
<li><a href="http://blog.iderzheng.com/introduction-to-ios7-javascriptcore-framework/">iOS7新JavaScriptCore框架入门介绍</a></li>
</ul>
<p><a href="http://liuyanwei.jumppo.com/2016/04/03/iOS-JavaScriptCore.html">出自</a>  </p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS linkmap统计ipa包</title>
    <url>/2018/06/11/iOS/iOS%20linkmap%E7%BB%9F%E8%AE%A1ipa%E5%8C%85/</url>
    <content><![CDATA[<p>iOS APP编译后，除了一些<strong>资源文件</strong>，剩下的就是一个<strong>可执行文件</strong>，有时候项目大了，<strong>引入的库多了，可执行文件很大</strong>，想知道这个可执行文件的构成是怎样，里面的内容都是些什么，哪些库占用空间较高，可以用以下方法勘察：  </p>
<p>**1.**XCode开启编译选项<code>Write Link Map File</code><br><code>XCode -&gt; Project -&gt; Build Settings -&gt;</code> 搜<code>map -&gt; 把Write Link Map File</code>选项设为<code>yes</code>，并指定好<code>linkMap</code>的存储位置</p>
<p>**2.**编译后，到编译目录里找到该txt文件，文件名和路径就是上述的<code>Path to Link Map File</code><br>位于<code>~/Library/Developer/Xcode/DerivedData/XXX-eumsvrzbvgfofvbfsoqokmjprvuh/Build/Intermediates/XXX.build/Debug-iphoneos/XXX.build/</code><br>这个<code>LinkMap</code>里展示了整个可执行文件的全貌，列出了编译后的每一个.o目标文件的信息（包括静态链接库.a里的），以及每一个目标文件的代码段，数据段存储详情。</p>
<h3 id="在LinkMap里首先列出来的是目标文件列表："><a href="#在LinkMap里首先列出来的是目标文件列表：" class="headerlink" title="在LinkMap里首先列出来的是目标文件列表："></a>在LinkMap里首先列出来的是目标文件列表：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Object files:</span><br><span class="line">[ 0] linker synthesized</span><br><span class="line">[ 1] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator7.0.sdk/usr/lib/crt1.o</span><br><span class="line">[ 2] /Users/bang/Library/Developer/Xcode/DerivedData/yishu-eyzgphknrrzpevagadjtwpzzeqag/Build/Intermediates/yishu.build/Debug-iphonesimulator/yishu.build/Objects-normal/i386/TKPFileInfo.o</span><br><span class="line">...</span><br><span class="line">[280] /Users/bang/Downloads/yishu/yishu/Classes/lib/UMeng/MobClick/libMobClickLibrary.a(UMANJob.o)</span><br><span class="line">[281] /Users/bang/Downloads/yishu/yishu/Classes/lib/UMeng/MobClick/libMobClickLibrary.a(UMANWorker.o)</span><br><span class="line">[282] /Users/bang/Downloads/yishu/yishu/Classes/lib/UMeng/MobClick/libMobClickLibrary.a(MobClick.o)</span><br><span class="line">[283] /Users/bang/Downloads/yishu/yishu/Classes/lib/UMeng/MobClick/libMobClickLibrary.a(UMANLaunch.o)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前面中括号里的是这个文件的编号，后面会用到，像项目里引用到静态链接库libMobClickLibrary.a里的目标文件都会在这里列出来。</p>
<h3 id="接着是一个段表，描述各个段在最后编译成的可执行文件中的偏移位置及大小，包括了代码段（-TEXT，保存程序代码段编译后的机器码）和数据段（-DATA，保存变量值）"><a href="#接着是一个段表，描述各个段在最后编译成的可执行文件中的偏移位置及大小，包括了代码段（-TEXT，保存程序代码段编译后的机器码）和数据段（-DATA，保存变量值）" class="headerlink" title="接着是一个段表，描述各个段在最后编译成的可执行文件中的偏移位置及大小，包括了代码段（__TEXT，保存程序代码段编译后的机器码）和数据段（__DATA，保存变量值）"></a>接着是一个段表，描述各个段在最后编译成的可执行文件中的偏移位置及大小，包括了代码段（__TEXT，保存程序代码段编译后的机器码）和数据段（__DATA，保存变量值）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Sections:</span><br><span class="line"># Address   Size     Segment   Section</span><br><span class="line">0x00002740 0x00273890 __TEXT __text</span><br><span class="line">0x00275FD0 0x00000ADA __TEXT __symbol_stub</span><br><span class="line">0x00276AAC 0x00001222 __TEXT __stub_helper</span><br><span class="line">0x00277CCE 0x00019D9E __TEXT __objc_methname</span><br><span class="line">0x00291A70 0x00012847 __TEXT __cstring</span><br><span class="line">0x002A42B7 0x00001FC1 __TEXT __objc_classname</span><br><span class="line">0x002A6278 0x000046A7 __TEXT __objc_methtype</span><br><span class="line">0x002AA920 0x000061CE __TEXT __ustring</span><br><span class="line">0x002B0AF0 0x00000764 __TEXT __const</span><br><span class="line">0x002B1254 0x000028B8 __TEXT __gcc_except_tab</span><br><span class="line">0x002B3B0C 0x00004EBC __TEXT __unwind_info</span><br><span class="line">0x002B89C8 0x0003662C __TEXT __eh_frame</span><br><span class="line">0x002EF000 0x00000014 __DATA __program_vars</span><br><span class="line">0x002EF014 0x00000284 __DATA __nl_symbol_ptr</span><br><span class="line">0x002EF298 0x0000073C __DATA __la_symbol_ptr</span><br><span class="line">0x002EF9E0 0x000030A4 __DATA __const</span><br><span class="line">0x002F2A84 0x00000590 __DATA __objc_classlist</span><br><span class="line">0x002F3014 0x0000000C __DATA __objc_nlclslist</span><br><span class="line">0x002F3020 0x0000006C __DATA __objc_catlist</span><br><span class="line">0x002F308C 0x000000D8 __DATA __objc_protolist</span><br><span class="line">0x002F3164 0x00000008 __DATA __objc_imageinfo</span><br><span class="line">0x002F3170 0x0002BC80 __DATA __objc_const</span><br><span class="line">0x0031EDF0 0x00003A30 __DATA __objc_selrefs</span><br><span class="line">0x00322820 0x00000014 __DATA __objc_protorefs</span><br><span class="line">0x00322834 0x000006B8 __DATA __objc_classrefs</span><br><span class="line">0x00322EEC 0x00000394 __DATA __objc_superrefs</span><br><span class="line">0x00323280 0x000037C8 __DATA __objc_data</span><br><span class="line">0x00326A48 0x000096D0 __DATA __cfstring</span><br><span class="line">0x00330118 0x00001424 __DATA __objc_ivar</span><br><span class="line">0x00331540 0x00006080 __DATA __data</span><br><span class="line">0x003375C0 0x0000001C __DATA __common</span><br><span class="line">0x003375E0 0x000018E8 __DATA __bss</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首列是数据在文件的偏移位置，第二列是这一段占用大小，第三列是段类型，代码段和数据段，第四列是段名称。<br>每一行的数据都紧跟在上一行后面，如第二行<code>__symbol_stub</code>的地址<code>0x00275FD0</code>就是第一行<code>__text</code>的地址<code>0x00002740</code>加上大小<code>0x00273890</code>，整个可执行文件大致数据分布就是这样。<br>这里可以清楚看到各种类型的数据在最终可执行文件里占的比例，例如<code>__text</code>表示编译后的程序执行语句，<code>__data</code>表示已初始化的全局变量和局部静态变量，<code>__bss</code>表示未初始化的全局变量和局部静态变量，<code>__cstring</code>表示代码里的字符串常量，等等。</p>
<h3 id="接着就是按上表顺序，列出具体的按每个文件列出每个对应字段的位置和占用空间"><a href="#接着就是按上表顺序，列出具体的按每个文件列出每个对应字段的位置和占用空间" class="headerlink" title="接着就是按上表顺序，列出具体的按每个文件列出每个对应字段的位置和占用空间"></a>接着就是按上表顺序，列出具体的按每个文件列出每个对应字段的位置和占用空间</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Address Size File Name</span><br><span class="line">0x00002740 0x0000003E [ 1] start</span><br><span class="line">0x00002780 0x00000400 [ 2] +[TKPFileInfo parseWithDictionary:]</span><br><span class="line">0x00002B80 0x00000030 [ 2] -[TKPFileInfo fileID]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>同样首列是数据在文件的偏移地址，第二列是占用大小，第三列是所属文件序号，对应上述Object files列表，最后是名字。<br>例如第二行代表了文件序号为2（反查上面就是TKPFileInfo.o）的parseWithDictionary方法占用了1000byte大小。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>这个文件可以让你了解整个APP编译后的情况，也许从中可以发现一些异常，还可以用这个文件计算静态链接库在项目里占的大小，有时候我们在项目里链了很多第三方库，导致APP体积变大很多，我们想确切知道每个库占用了多大空间，可以给我们优化提供方向。LinkMap里有了每个目标文件每个方法每个数据的占用大小数据，所以只要写个脚本，就可以统计出每个.o最后的大小，属于一个.a静态链接库的.o加起来，就是这个库在APP里占用的空间大小。</p>
<h3 id="生成的linkmap文件path"><a href="#生成的linkmap文件path" class="headerlink" title="生成的linkmap文件path"></a>生成的linkmap文件path</h3><p>/Users/wenyongjun/Library/Developer/Xcode/DerivedData/JDViewKitProduct-cvqwuevthaoawvbqwonrghbfhnuz/Build/Intermediates.noindex/JDViewKitProduct.build/Debug-iphonesimulator/JDViewKitProduct.build/JDViewKitProduct-LinkMap-normal-x86_64.txt </p>
<p><a href="https://blog.csdn.net/zgzczzw/article/details/79855660">基于LinkMap分析iOSAPP各模块体积</a></p>
<p><a href="http://blog.cnbang.net/tech/2296/">iOS APP可执行文件的组成</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>OS 中的 armv7,armv7s,arm64,i386,x86_64 都是什么</title>
    <url>/2018/06/11/iOS/iOS%20%E4%B8%AD%E7%9A%84%20armv7,armv7s,arm64,i386,x86_64%20%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>在做静态库的时候以及引用静态库的时候经常会遇到一些关于真机模拟器不通用的情况，会报错找不到相应库导致编译失败，</p>
<p>这里简单记录一下各种设备支持的架构。</p>
<h4 id="iOS测试分为模拟器测试和真机测试，处理器分为32位处理器，和64位处理器"><a href="#iOS测试分为模拟器测试和真机测试，处理器分为32位处理器，和64位处理器" class="headerlink" title="iOS测试分为模拟器测试和真机测试，处理器分为32位处理器，和64位处理器"></a>iOS测试分为模拟器测试和真机测试，处理器分为32位处理器，和64位处理器</h4><h5 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h5><p>模拟器32位处理器测试需要i386架构，（iphone5,iphone5s以下的模拟器）</p>
<p>模拟器64位处理器测试需要x86_64架构，(iphone6以上的模拟器)</p>
<h5 id="真机"><a href="#真机" class="headerlink" title="真机"></a>真机</h5><p>真机32位处理器需要armv7,或者armv7s架构，（iphone4真机/armv7,      ipnone5,iphone5s真机/armv7s）</p>
<p>真机64位处理器需要arm64架构。(iphone6,iphone6p以上的真机)</p>
<p>project -&gt; target -&gt; building setting -&gt; Arhitectures 设置</p>
<h5 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h5><p>debug属性设置为no的时候，会编译支持所有架构的版本，编译的速度会变慢，设置为yes 的时候，只编译当前的architecture版本，编译速度快。</p>
<p>一般情况下，debug 设置为yes，release为no，这样发行版本能适应不同设备。</p>
<h5 id="用到的命令行查看或者合并"><a href="#用到的命令行查看或者合并" class="headerlink" title="用到的命令行查看或者合并"></a>用到的命令行查看或者合并</h5><p>静态库.a支持信息：<br>lipo -info .a文件  </p>
<p>两个静态库合并：<br> lipo -create 文件1  文件2  -output /Users/sunjianfei/Desktop/libPrint.a</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 加载http的方法</title>
    <url>/2018/06/11/iOS/iOS%20%E5%8A%A0%E8%BD%BDhttp%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在iOS 9的时候,默认非HTTS的网络是被禁止的,我们可以在info.plist文件中添加NSAppTransportSecurity字典,将NSAllowsArbitraryLoads设置为YES来禁用ATS</p>
<p><a href="https://www.jianshu.com/p/bee253cb4825">简书地址</a></p>
<p>解决方案一：</p>
<p>开启 NSAllowsArbitraryLoads 为 YES，然后提交时进行说明</p>
<p>解决方案二：</p>
<p>设置 NSExceptionDomains 属性来访问指定域名，然后提交时进行说明</p>
<p>解决方案三：</p>
<p>只针对网页浏览和视频播放的行为且为iOS 10及以上，设置NSAllowsArbitraryLoadsInWebContent为Yes。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 静态库和动态库</title>
    <url>/2018/06/11/iOS/iOS%20%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    <content><![CDATA[<h3 id="静态库和动态库的存在的形式"><a href="#静态库和动态库的存在的形式" class="headerlink" title="静态库和动态库的存在的形式"></a>静态库和动态库的存在的形式</h3><ul>
<li><p>静态库：以.a 和 .framework为文件后缀名。</p>
</li>
<li><p>动态库：以.tbd(之前叫.dylib) 和 .framework 为文件后缀名。（系统直接提供给我们的framework都是动态库！）</p>
</li>
</ul>
<p>理解：.a 是一个纯二进制文件，.framework 中除了有二进制文件之外还有资源文件。 .a ，要有 .h 文件以及资源文件配合， .framework 文件可以直接使用。总的来说，.a + .h + sourceFile = .framework。所以创建静态库最好还是用.framework的形式</p>
<h3 id="静态库和动态库的区别"><a href="#静态库和动态库的区别" class="headerlink" title="静态库和动态库的区别"></a>静态库和动态库的区别</h3><p>　<strong>不同点：</strong> </p>
<ul>
<li><p>静态库在链接时，会被完整的复制到可执行文件中，如果多个App都使用了同一个静态库，那么每个App都会拷贝一份，缺点是浪费内存。类似于定义一个基本变量，使用该基本变量是是新复制了一份数据，而不是原来定义的；</p>
</li>
<li><p>动态库不会复制，只有一份，程序运行时动态加载到内存中，系统只会加载一次，多个程序共用一份，节约了内存。类似于使用变量的内存地址一样，使用的是同一个变量；</p>
</li>
<li><p><em>共同点：</em>*</p>
</li>
<li><p>静态库和动态库都是闭源库，只能拿来满足某个功能的使用，不会暴露内部具体的代码信息</p>
<h3 id="从源代码到app"><a href="#从源代码到app" class="headerlink" title="从源代码到app"></a>从源代码到app</h3></li>
</ul>
<blockquote>
<p>当我们点击了 build 之后，做了什么事情呢？</p>
</blockquote>
<ul>
<li>预处理（Pre-process）：把宏替换，删除注释，展开头文件，产生 .i 文件。</li>
<li>编译（Compliling）：把之前的 .i 文件转换成汇编语言，产生 .s文件。</li>
<li>汇编（Asembly）：把汇编语言文件转换为机器码文件，产生 .o 文件。</li>
<li>链接（Link）：对.o文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件（同时也包括多个 .o 文件进行 link）。</li>
</ul>
<p><a href="https://www.cnblogs.com/junhuawang/p/7598236.html">引用</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发中 const,static,extern用法总结</title>
    <url>/2018/06/11/iOS/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%20const,static,extern%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>iOS开发中怎么使用const,static,extern3个关键字.</p>
</blockquote>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const的作用: const 是一个左结合的类型修饰符，它与其左侧的类型修饰符一起为一个类型修饰符,表示该类型只读.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">修饰基本变量</span><br><span class="line"><span class="comment">// 这两种写法是一样的，const只修饰右边的基本变量b</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">// b:只读变量</span></span><br><span class="line">   <span class="keyword">int</span> <span class="keyword">const</span> b = <span class="number">20</span>; <span class="comment">// b:只读变量</span></span><br><span class="line"></span><br><span class="line">修饰指针变量</span><br><span class="line"><span class="comment">// 两种方式一样</span></span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> *p1; <span class="comment">// *p1：只读 p1:只读</span></span><br><span class="line"> <span class="keyword">int</span> <span class="keyword">const</span> *p1; <span class="comment">// *p1：只读 p1:只读</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// const修饰指针变量p1</span></span><br><span class="line"> <span class="keyword">int</span> * <span class="keyword">const</span> p1; <span class="comment">// *p1:变量 p1:常量</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 第一个const修饰*p1 第二个const修饰 p1</span></span><br><span class="line"> <span class="comment">// 两种方式一样</span></span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p1; <span class="comment">// *p1：常量 p1：常量</span></span><br><span class="line"> <span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p1;  <span class="comment">// *p1：常量 p1：常量</span></span><br></pre></td></tr></table></figure>

<p>简言之:沿着<em>号划一条线，如果const位于</em>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static的作用:</p>
<p>修饰局部变量：<br>延长局部变量的生命周期。<br>局部变量只会生成一份内存,只会初始化一次。<br>修饰全局变量:<br>使其只能在本文件中访问。</p>
<h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>extern的作用: 声明和捕捉外部全局变量。<br>联合使用<br>static与const:声明一个静态的全局只读变量,(仅当前文件可访问且只读).</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>  <span class="built_in">NSString</span> * <span class="keyword">const</span> key = <span class="string">@&quot;name&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>extern与const组合:定义全局只读变量，多个文件共享。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">.h文件</span><br><span class="line"><span class="keyword">extern</span>  <span class="built_in">NSString</span> * <span class="keyword">const</span> king;</span><br><span class="line">.m文件</span><br><span class="line"><span class="built_in">NSString</span>  * <span class="keyword">const</span> king = <span class="string">@&quot;king&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://jatstar.cn/2016/01/10/const-static-extern/">来源const-static-extern</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发之位移枚举和按位或按位与运算</title>
    <url>/2018/06/11/iOS/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E4%BD%8D%E7%A7%BB%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%8C%89%E4%BD%8D%E6%88%96%E6%8C%89%E4%BD%8D%E4%B8%8E%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<blockquote>
<p>位移枚举(可复选的枚举) 使用位移实现选项变量</p>
</blockquote>
<h3 id="Autoresizing-的系统枚举UIViewAutoresizing-讲述"><a href="#Autoresizing-的系统枚举UIViewAutoresizing-讲述" class="headerlink" title="Autoresizing 的系统枚举UIViewAutoresizing 讲述"></a>Autoresizing 的系统枚举UIViewAutoresizing 讲述</h3><p>以下位移已经计算提前计算出来了二进制与十进制值为了方便下文使用</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>,<span class="built_in">UIViewAutoresizing</span>)&#123;    二进制值    十进制</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIViewAutoresizingNone</span>                 =<span class="number">0</span>,         <span class="number">00000000</span>  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>   =<span class="number">1</span>&lt;&lt;<span class="number">0</span>,    <span class="number">00000001</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleWidth</span>        =<span class="number">1</span>&lt;&lt;<span class="number">1</span>,    <span class="number">00000010</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>  =<span class="number">1</span>&lt;&lt;<span class="number">2</span>,    <span class="number">00000100</span>  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleTopMargin</span>    =<span class="number">1</span>&lt;&lt;<span class="number">3</span>,    <span class="number">00001000</span>  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleHeight</span>       =<span class="number">1</span>&lt;&lt;<span class="number">4</span>,    <span class="number">00010000</span>  <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span>=<span class="number">1</span>&lt;&lt;<span class="number">5</span>     <span class="number">00100000</span>  <span class="number">32</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用枚举定义选项,每个选项均可启用或禁用，使用上述方式来定义枚举值,每个枚举值所对应的二进制表示中，只有1个二进制位的值是1。用“按位或操作符”可组合多个选项</p>
<p>用 | 来隔开</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">aView.autoresizingMask=<span class="built_in">UIViewAutoresizingFlexibleTopMargin</span>|</span><br><span class="line">  <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>|  </span><br><span class="line">  <span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span>|  </span><br><span class="line">  <span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>;  </span><br></pre></td></tr></table></figure>

<p>而且每一个枚举对应的逻辑都会覆盖到</p>
<p>实例</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)todo:(<span class="built_in">UIViewAutoresizing</span>)type&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;UIViewAutoresizingNone&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//更严谨的写法</span></span><br><span class="line">    <span class="keyword">if</span>(type&amp;<span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span> ==   </span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;UIViewAutoresizingFlexibleLeftMargin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(type&amp;<span class="built_in">UIViewAutoresizingFlexibleWidth</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;UIViewAutoresizingFlexibleWidth&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(type&amp;<span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;UIViewAutoresizingFlexibleRightMargin&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(type&amp;<span class="built_in">UIViewAutoresizingFlexibleTopMargin</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;UIViewAutoresizingFlexibleTopMargin&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(type&amp;<span class="built_in">UIViewAutoresizingFlexibleHeight</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;UIViewAutoresizingFlexibleHeight&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(type&amp;<span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;UIViewAutoresizingFlexibleBottomMargin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)viewDidLoad&#123;</span><br><span class="line"></span><br><span class="line">    [superviewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> todo:<span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>|  </span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>|  </span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleHeight</span>];  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>  </span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>  </span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexibleHeight</span>  </span><br></pre></td></tr></table></figure>

<h3 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h3><p><code>1101（2）=1*2^0+0*2^1+1*2^2+1*2^3=1+0+4+8=13</code>转化成十进制要从右到左用二进制的每个数去乘以2的相应次方不过次方要从0开始</p>
<h4 id="位移位运算"><a href="#位移位运算" class="headerlink" title="位移位运算"></a>位移位运算</h4><p>如 <code>UIViewAutoresizingFlexibleHeight  = 1 &lt;&lt; 4</code>,</p>
<p>1.左移运算 1 &lt;&lt; 4<br>将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</p>
<p>1 转化为二进制为 :0000 0001</p>
<p>左移四位就为     :0001 0000</p>
<p>0001 0000 转化为十进制等于16</p>
<p>2.右移运算 90&gt;&gt;4<br>将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。操作数每右移一位，相当于该数除以2。</p>
<p>90转化为二进制为 :01011010</p>
<p>右移4位就是          :00000101</p>
<p>00000101  转化为十进制等于5</p>
<h4 id="按位或运算符（-）"><a href="#按位或运算符（-）" class="headerlink" title="按位或运算符（|）"></a>按位或运算符（|）</h4><p>运算规则：0|0=0；   0|1=1；   1|0=1；    1|1=1；即 ：参加运算的两个二进制对应数位只要有一个为1，其值为1。</p>
<p>例如</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> todo:<span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>|</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>|  </span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexibleHeight</span>];</span><br></pre></td></tr></table></figure>

<p>1.十进制1|4|16 转为二进制0000 0001 | 0000 0100 | 0001 0000  =  0001 0101,因此，1|4|16的十进制值得21</p>
<h4 id="按位与运算符（-amp-）"><a href="#按位与运算符（-amp-）" class="headerlink" title="按位与运算符（&amp;）"></a>按位与运算符（&amp;）</h4><p>参加运算的两个数据，按二进制位进行“与”运算。运算规则：0&amp;0=0;   0&amp;1=0;    1&amp;0=0;     1&amp;1=1;即：两对应数位同时为“1”，结果才为“1”，否则为0</p>
<p>1.十进制3&amp;5  转为二进制 0000 0011 &amp; 0000 0101 = 0000 0001   因此，3&amp;5的值得1</p>
<p>2.iOS在方法中的应用</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)todo:(<span class="built_in">UIViewAutoresizing</span>)type&#123;<span class="keyword">if</span> (type &amp; </span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span> )</span><br><span class="line"> &#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;UIViewAutoresizingFlexibleLeftMargin&quot;</span>);&#125;&#125;</span><br><span class="line"></span><br><span class="line">入参数type 为 <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>|</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>|</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexibleHeight</span></span><br></pre></td></tr></table></figure>

<p>上文知道结果是 0001 0101,十进制值得21 <code>UIViewAutoresizingFlexibleRightMargin为4</code></p>
<p>0001 0101 &amp;  <code>UIViewAutoresizingFlexibleRightMargin</code> =  0001 0101 &amp; 0000 0100  =21&amp;4 = 4 根据计算结果还是<code>UIViewAutoresizingFlexibleRightMargin</code>这个枚举</p>
<h3 id="在iOS中的总结"><a href="#在iOS中的总结" class="headerlink" title="在iOS中的总结"></a>在iOS中的总结</h3><p>如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。</p>
<p>用<code>NS_ENUM</code>与<code>NS_OPTIONS</code>宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。</p>
<p>在处理枚举类型的<code>switch</code>语句中不要实现<code>default</code>分支。这样的话，加入新枚举之后，编译器就会提示开发者：<code>switch</code>语句并未处理所有枚举。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS打包Framework真机和模拟器兼容合并版本</title>
    <url>/2018/06/11/iOS/iOS%E6%89%93%E5%8C%85Framework%E7%9C%9F%E6%9C%BA%E5%92%8C%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%85%BC%E5%AE%B9%E5%90%88%E5%B9%B6%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="查询framework支持哪些架构，命令为："><a href="#查询framework支持哪些架构，命令为：" class="headerlink" title="查询framework支持哪些架构，命令为："></a>查询framework支持哪些架构，命令为：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lipo -info XXXX.framework/XXXX</span><br></pre></td></tr></table></figure>
<h3 id="合并包"><a href="#合并包" class="headerlink" title="合并包"></a>合并包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> lipo -create XXXX.framework/XXXX-armv7 XXXX.framework/XXXX-arm64 -output XXXX.framework/XXXX</span><br><span class="line"></span><br><span class="line">lipo -create 【模拟器打包path】 【真机打包path】 -output 【导出兼容版本path】</span><br></pre></td></tr></table></figure>
<h3 id="一键打包shell脚本"><a href="#一键打包shell脚本" class="headerlink" title="一键打包shell脚本"></a>一键打包shell脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 使用方法 ###</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># bash get_framework.sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 填写要生成的包的名字</span></span><br><span class="line">FrameWorkName=<span class="string">&quot;JDViewKit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输出包的文件路径</span></span><br><span class="line">OutputDir=<span class="variable">$&#123;SRCROOT&#125;</span>/VKOutput</span><br><span class="line"><span class="comment"># Working dir will be deleted after the framework creation.</span></span><br><span class="line">buildDir=build</span><br><span class="line">DEVICE_DIR=<span class="variable">$&#123;buildDir&#125;</span>/Release-iphoneos</span><br><span class="line">SIMULATOR_DIR=<span class="variable">$&#123;buildDir&#125;</span>/Release-iphonesimulator/<span class="variable">$&#123;FrameWorkName&#125;</span>.framework</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译真机和模拟器的两种架构</span></span><br><span class="line"><span class="comment"># -configuration $&#123;CONFIGURATION&#125;</span></span><br><span class="line"><span class="comment"># Clean and Building both architectures.</span></span><br><span class="line"></span><br><span class="line">xcodebuild -configuration <span class="string">&quot;Release&quot;</span> -target <span class="string">&quot;<span class="variable">$&#123;FrameWorkName&#125;</span>&quot;</span> -sdk iphoneos clean build</span><br><span class="line">xcodebuild -configuration <span class="string">&quot;Release&quot;</span> -target <span class="string">&quot;<span class="variable">$&#123;FrameWorkName&#125;</span>&quot;</span> -sdk iphonesimulator clean build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把旧的输出文件包删除掉</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$&#123;OutputDir&#125;</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">sudo rm -rf <span class="string">&quot;<span class="variable">$&#123;OutputDir&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建输出包</span></span><br><span class="line">sudo mkdir -p <span class="string">&quot;<span class="variable">$&#123;OutputDir&#125;</span>&quot;</span></span><br><span class="line">sudo cp -R <span class="string">&quot;<span class="variable">$&#123;DEVICE_DIR&#125;</span>/&quot;</span> <span class="string">&quot;<span class="variable">$&#123;OutputDir&#125;</span>/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lipo工具合并通用包（(i386 + armv6/armv7)）</span></span><br><span class="line">sudo lipo -create <span class="string">&quot;<span class="variable">$&#123;DEVICE_DIR&#125;</span>/<span class="variable">$&#123;FrameWorkName&#125;</span>.framework/<span class="variable">$&#123;FrameWorkName&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;SIMULATOR_DIR&#125;</span>/<span class="variable">$&#123;FrameWorkName&#125;</span>&quot;</span> -output <span class="string">&quot;<span class="variable">$&#123;OutputDir&#125;</span>/<span class="variable">$&#123;FrameWorkName&#125;</span>.framework/<span class="variable">$&#123;FrameWorkName&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除build包  打开输出包文件夹</span></span><br><span class="line">sudo rm -r <span class="string">&quot;<span class="variable">$&#123;buildDir&#125;</span>&quot;</span></span><br><span class="line">open <span class="string">&quot;<span class="variable">$&#123;OutputDir&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS编程习惯与风格</title>
    <url>/2016/06/11/iOS/iOS%E7%BC%96%E7%A8%8B%E4%B9%A0%E6%83%AF%E4%B8%8E%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<h3 id="开发前"><a href="#开发前" class="headerlink" title="开发前"></a>开发前</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先在开发前确定好需求 对需求点分析 </span><br><span class="line">1、对感觉不太合理的地方 提出来或者有自己的建议 </span><br><span class="line">把不合理的地方阉割在开发开始之前（做愉快编程）</span><br><span class="line">2、分析接口 做开发前的进一步预判</span><br></pre></td></tr></table></figure>
<h3 id="开发中"><a href="#开发中" class="headerlink" title="开发中"></a>开发中</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、头文件内只包含外部模块可调用的属性或者方法</span><br><span class="line">2、模块构建的时候可首先按逻辑与UI交互类来区分管理（逻辑管理类、ViewController）</span><br><span class="line">3、.m文件 内容实现上按区域划分（#pragma mark -来区域划分）</span><br><span class="line">	（具体可为：初始化区域、自定义视图区域、自定义方法区域、生命循环区域、回调区域等）</span><br><span class="line">4、视图层尽量做到封装（这样保证一个大模块都是若干小模块组合而成）</span><br><span class="line">5、网络请求放到逻辑管理类中，VC中只管理数据返回后的渲染</span><br><span class="line">6、抽象数据模型</span><br><span class="line">7、适当添加注释（借助VVDoc）</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>封装的目的代码复用，提高了代码的可维护性等</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>在相应的模块给dealloc 打个log 看是否有内存泄露的情况</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="一些有意思的写法"><a href="#一些有意思的写法" class="headerlink" title="一些有意思的写法"></a>一些有意思的写法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、- (void)xxxMethod &#123;</span><br><span class="line">  if ([xxx boolValue]) &#123;</span><br><span class="line">    //todo：xxx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、</span><br><span class="line">if (xxx == nil) &#123;&#125;</span><br><span class="line">if (xxx == NO) &#123;&#125;</span><br><span class="line">if (xxx == YES) &#123;&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、局部变量、实例变量、方法名  保持全名命名 不缩减 （驼峰序列）</span><br><span class="line"></span><br><span class="line">4、（估计此处也同样会有质疑声）</span><br><span class="line">if (xxx)</span><br><span class="line">&#123;</span><br><span class="line">  //todo：something</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  //todo：something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5 、instancetype 与 id 的使用 </span><br><span class="line"></span><br><span class="line">6、[NSNumber numberWithInt:xxx] -&gt; @xxx 等类似的形式 </span><br></pre></td></tr></table></figure>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重构？</span><br><span class="line">何时重构：随时随地（事不过三）</span><br><span class="line">哪些情况下就要考虑重构？</span><br><span class="line">  重复代码、过长的函数、函数过多的参数列、过大的类、</span><br><span class="line"></span><br><span class="line">把一些开发技巧编程一种习惯，更能编写高效率、高质量的代码</span><br></pre></td></tr></table></figure>

<h3 id="学习外部地址"><a href="#学习外部地址" class="headerlink" title="学习外部地址"></a>学习外部地址</h3><p><a href="http://liuyanwei.jumppo.com/2016/02/29/iOS-objc-styleguide.html">刘彦玮博客总结</a><br> <a href="https://github.com/oa414/objc-zen-book-cn/">objc禅翻译</a><br> <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-objc-styleguide/contents/">Google 开源项目风格指南 - objc</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/06/iOS/iOS%E9%A2%98%E5%BA%93/</url>
    <content><![CDATA[<p>阿里、字节：一套高效的iOS面试题</p>
<p><a href="https://mp.weixin.qq.com/s/MfIYO239_BtuTPGYbzyYRA">一套高效的iOS面试题</a></p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>笔者最近收集梳理了一些iOS相关的问题，其中大部分都是大厂面试或者面试其他人用到的，能命中大部分的面试和日常工作，更希望你可以用它来检验自己<br>由于问题量太大，本文只是给了问题，希望发挥圈友的动手能力，自己去探索下，也可以在下方进行评论回复你的答案或者提出更高质量的问题！！！</p>
<h2 id="runtime相关问题"><a href="#runtime相关问题" class="headerlink" title="runtime相关问题"></a>runtime相关问题</h2><p>runtime是iOS开发最核心的知识了，如果下面的问题都解决了，那么对runtime的理解已经很深了。<br>runtime已经开源了，这有一份别人调试好可运行的源码objc-runtime，也可以去官网找objc4</p>
<p>objc-runtime地址：<a href="https://github.com/RetVal/objc-runtime">https://github.com/RetVal/objc-runtime</a></p>
<p>objc4地址：<a href="https://opensource.apple.com/tarballs/objc4/">https://opensource.apple.com/tarballs/objc4/</a></p>
<h3 id="结构模型"><a href="#结构模型" class="headerlink" title="结构模型"></a>结构模型</h3><p>介绍下runtime的内存模型（isa、对象、类、metaclass、结构体的存储信息等）<br>为什么要设计metaclass<br>class_copyIvarList &amp; class_copyPropertyList区别<br>class_rw_t 和 class_ro_t 的区别<br>category如何被加载的,两个category的load方法的加载顺序，两个category的同名方法的加载顺序<br>category &amp; extension区别，能给NSObject添加Extension吗，结果如何<br>消息转发机制，消息转发机制和其他语言的消息机制优劣对比<br>在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么<br>IMP、SEL、Method的区别和使用场景<br>load、initialize方法的区别什么？在继承关系中他们有什么区别<br>说说消息转发机制的优劣</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>weak的实现原理？SideTable的结构是什么样的<br>关联对象的应用？系统如何实现关联对象的<br>关联对象的如何进行内存管理的？关联对象如何实现weak属性<br>Autoreleasepool的原理？所使用的的数据结构是什么<br>ARC的实现原理？ARC下对retain &amp; release做了哪些优化<br>ARC下哪些情况会造成内存泄漏</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Method Swizzle注意事项<br>属性修饰符atomic的内部实现是怎么样的?能保证线程安全吗<br>iOS 中内省的几个方法有哪些？内部实现原理是什么<br>class、objc_getClass、object_getclass 方法有什么区别?</p>
<h2 id="NSNotification相关"><a href="#NSNotification相关" class="headerlink" title="NSNotification相关"></a>NSNotification相关</h2><p>苹果并没有开源相关代码，但是可以读下GNUStep的源码，基本上实现方式很具有参考性</p>
<p>GNUStep地址：<a href="https://github.com/gnustep/libs-base">https://github.com/gnustep/libs-base</a></p>
<p>实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等）<br>通知的发送时同步的，还是异步的<br>NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息<br>NSNotificationQueue是异步还是同步发送？在哪个线程响应<br>NSNotificationQueue和runloop的关系<br>如何保证通知接收的线程在主线程<br>页面销毁时不移除通知会崩溃吗<br>多次添加同一个通知会是什么结果？多次移除通知呢<br>下面的方式能接收到通知吗？为什么<br>1// 发送通知<br>2[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@”TestNotification” object:@1];<br>3// 接收通知<br>4[NSNotificationCenter.defaultCenter postNotificationName:@”TestNotification” object:nil];</p>
<h2 id="Runloop-amp-KVO"><a href="#Runloop-amp-KVO" class="headerlink" title="Runloop &amp; KVO"></a>Runloop &amp; KVO</h2><h3 id="runloop"><a href="#runloop" class="headerlink" title="runloop"></a>runloop</h3><p>runloop对于一个标准的iOS开发来说都不陌生，应该说熟悉runloop是标配，下面就随便列几个典型问题吧</p>
<p>app如何接收到触摸事件的<br>为什么只有主线程的runloop是开启的<br>为什么只在主线程刷新UI<br>PerformSelector和runloop的关系<br>如何使线程保活</p>
<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>同runloop一样，这也是标配的知识点了，同样列出几个典型问题</p>
<p>实现原理<br>如何手动关闭kvo<br>通过KVC修改属性会触发KVO么<br>哪些情况下使用kvo会崩溃，怎么防护崩溃<br>kvo的优缺点</p>
<h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><p>block的内部实现，结构体是什么样的<br>block是类吗，有哪些类型<br>一个int变量被 __block 修饰与否的区别？block的变量截获<br>block在修改NSMutableArray，需不需要添加__block<br>怎么进行内存管理的<br>block可以用strong修饰吗<br>解决循环引用时为什么要用__strong、__weak修饰<br>block发生copy时机<br>Block访问对象类型的auto变量时，在ARC和MRC下有什么区别</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>主要以GCD为主</p>
<p>iOS开发中有多少类型的线程？分别对比<br>GCD有哪些队列，默认提供哪些队列<br>GCD有哪些方法api<br>GCD主线程 &amp; 主队列的关系<br>如何实现同步，有多少方式就说多少<br>dispatch_once实现原理<br>什么情况下会死锁<br>有哪些类型的线程锁，分别介绍下作用和使用场景<br>NSOperationQueue中的maxConcurrentOperationCount默认值<br>NSTimer、CADisplayLink、dispatch_source_t 的优劣</p>
<h2 id="视图-amp-图像相关"><a href="#视图-amp-图像相关" class="headerlink" title="视图&amp;图像相关"></a>视图&amp;图像相关</h2><p>AutoLayout的原理，性能如何<br>UIView &amp; CALayer的区别<br>事件响应链<br>drawrect &amp; layoutsubviews调用时机<br>UI的刷新原理<br>隐式动画 &amp; 显示动画区别<br>什么是离屏渲染<br>imageName &amp;  imageWithContentsOfFile区别<br>多个相同的图片，会重复加载吗<br>图片是什么时候解码的，如何优化<br>图片渲染怎么优化<br>如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>如何做启动优化，如何监控<br>如何做卡顿优化，如何监控<br>如何做耗电优化，如何监控<br>如何做网络优化，如何监控</p>
<h2 id="开发证书"><a href="#开发证书" class="headerlink" title="开发证书"></a>开发证书</h2><p>苹果使用证书的目的是什么<br>AppStore安装app时的认证流程<br>开发者怎么在debug模式下把app安装到设备呢</p>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="典型源码的学习"><a href="#典型源码的学习" class="headerlink" title="典型源码的学习"></a>典型源码的学习</h3><p>只是列出一些iOS比较核心的开源库，这些库包含了很多高质量的思想，源码学习的时候一定要关注每个框架解决的核心问题是什么，还有它们的优缺点，这样才能算真正理解和吸收</p>
<p>AFN<br>SDWebImage<br>JSPatch、Aspects(虽然一个不可用、另一个不维护，但是这两个库都很精炼巧妙，很适合学习)<br>Weex/RN, 笔者认为这种前端和客户端紧密联系的库是必须要知道其原理的<br>CTMediator、其他router库，这些都是常见的路由库，开发中基本上都会用到<br>请圈友们在评论下面补充吧</p>
<h3 id="架构设计-1"><a href="#架构设计-1" class="headerlink" title="架构设计"></a>架构设计</h3><p>手动埋点、自动化埋点、可视化埋点<br>MVC、MVP、MVVM设计模式<br>常见的设计模式<br>单例的弊端<br>常见的路由方案，以及优缺点对比<br>如果保证项目的稳定性<br>设计一个图片缓存框架(LRU)<br>如何设计一个git diff<br>设计一个线程池？画出你的架构图<br>你的app架构是什么，有什么优缺点、为什么这么做、怎么改进</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>PerformSelector &amp; NSInvocation优劣对比<br>oc怎么实现多继承？怎么面向切面（可以参考Aspects深度解析-iOS面向切面编程）<br>哪些bug会导致崩溃，如何防护崩溃<br>怎么监控崩溃<br>app的启动过程（考察LLVM编译过程、静态链接、动态链接、runtime初始化）<br>沙盒目录的每个文件夹划分的作用<br>简述下match-o文件结构</p>
<h2 id="系统基础知识"><a href="#系统基础知识" class="headerlink" title="系统基础知识"></a>系统基础知识</h2><p>进程和线程的区别<br>HTTPS的握手过程<br>什么是中间人攻击？怎么预防<br>TCP的握手过程？为什么进行三次握手，四次挥手<br>堆和栈区的区别？谁的占用内存空间大<br>加密算法：对称加密算法和非对称加密算法区别<br>常见的对称加密和非对称加密算法有哪些<br>MD5、Sha1、Sha256区别<br>charles抓包过程？不使用charles，4G网络如何抓包</p>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><p>对于移动开发者来说，一般不会遇到非常难的算法，大多以数据结构为主，笔者列出一些必会的算法，当然有时间了可以去LeetCode上刷刷题</p>
<p>LeetCode地址：<a href="https://leetcode.com/">https://leetcode.com/</a></p>
<p>八大排序算法<br>栈&amp;队列<br>字符串处理<br>链表<br>二叉树相关操作<br>深搜广搜<br>基本的动态规划题、贪心算法、二分查找</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些都是笔者收集的加上自身面试的一些经验总结，后期会持续收集补充，欢迎圈内的高手补充你的答案或者高质量问题</p>
<p>准备面试是一方面，对于非面试的iOS开发者来说更适用于检验自己，发起进阶之路。另外知识点是琐碎的，但是真的能全部弄懂并把琐碎的知识点融会贯通，构建起自己的知识体系，你就进阶一层。</p>
]]></content>
  </entry>
  <entry>
    <title>iOS-ARC和垃圾回收机制的区别</title>
    <url>/2018/06/11/iOS/ios-ARC%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>在<code>java</code>中有个垃圾回收器，什么是垃圾回收器，就是在程序运行的期间，垃圾回收器会不断的去扫描堆中的对象是否无人使用。如果无人使用就会回收了。</p>
<p><code>ARC</code>在编译的时候就会在合适的地方插入<code>retain,release,autorelease</code>,在运行的时候没有东西去进行实时检查，它插入的代码可以在对象没有人用的时候，引用计数器就会变为0.一旦变为0就会被销毁了。</p>
<p>如果在java中有一段代码是<code>Person * p=[Person new]; p=nil</code>，这个对象什么时候被回收？不一定，因为这要看垃圾回收器有没有扫描到这里。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS runtime</title>
    <url>/2018/06/11/iOS/runtime%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="class-结构（方法步骤）"><a href="#class-结构（方法步骤）" class="headerlink" title="class 结构（方法步骤）"></a>class 结构（方法步骤）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    //类本身</span><br><span class="line">    Class _Nonnull isa ;</span><br><span class="line">    //父类</span><br><span class="line">    Class _Nullable super_class</span><br><span class="line">    //类名                             </span><br><span class="line">    const char * _Nonnull name                              </span><br><span class="line">    long version                                            </span><br><span class="line">    long info</span><br><span class="line">    //类大小                                               </span><br><span class="line">    long instance_size      </span><br><span class="line">    //类中的变量                                </span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                 </span><br><span class="line">    //类中的变量 </span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists</span><br><span class="line">    //缓存，便于下次查找                   </span><br><span class="line">    struct objc_cache * _Nonnull cache</span><br><span class="line">    //类中的协议                       </span><br><span class="line">    struct objc_protocol_list * _Nullable protocols         </span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>

<h3 id="NSObject-alloc-init-初始化步骤"><a href="#NSObject-alloc-init-初始化步骤" class="headerlink" title="[[NSObject alloc] init]初始化步骤"></a>[[NSObject alloc] init]初始化步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">   https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100</span><br><span class="line">     </span><br><span class="line">     struct objc_class &#123;</span><br><span class="line">     Class isa // 类本身 --&gt; &#123;isa; methodLists(alloc)(类方法)&#125;</span><br><span class="line">     </span><br><span class="line">     Class super_class                                        ;</span><br><span class="line">     const char *name                                         ;</span><br><span class="line">     long version                                             ;</span><br><span class="line">     long info                                                ;</span><br><span class="line">     long instance_size                                       ;</span><br><span class="line">     struct objc_ivar_list *ivars                             ;</span><br><span class="line">     struct objc_method_list **methodLists  // 实例方法                  ;</span><br><span class="line">     struct objc_cache *cache                                 ;</span><br><span class="line">     struct objc_protocol_list *protocols                     ;</span><br><span class="line">     &#125;</span><br><span class="line">     最终指向自己，形成了一个闭环， NSObject的isa 不是指向一个nil</span><br><span class="line">     1 [EOCObject alloc] 先执行，因为EOCObject检测，没有alloc方法， 就去父类里面去查找。</span><br><span class="line">     2 检测父类是否响应 alloc， 如果有，那么执行， 开始分配内存空间大小（成员变量）。// 方法（类有关系）</span><br><span class="line">     3 init 方法，检测是否响应，如果没有去父类查找。</span><br><span class="line">     4 方法执行完，会存缓存（所以一般第二次操作，会更快）</span><br><span class="line">     */</span><br><span class="line">    MyObject * objc  = [[MyObject alloc] init];</span><br></pre></td></tr></table></figure>

<h3 id="main-之前的过程有哪些？"><a href="#main-之前的过程有哪些？" class="headerlink" title="main()之前的过程有哪些？"></a>main()之前的过程有哪些？</h3><p>1<code>main</code>之前的加载过程<br>1）<code>dyld</code> 开始将程序二进制文件初始化<br>2）交由<code>ImageLoader</code> 读取 <code>image</code>，其中包含了我们的类，方法等各种符号<code>（Class、Protocol 、Selector、 IMP）</code><br>3）由于<code>runtime</code> 向<code>dyld</code> 绑定了回调，当<code>image</code>加载到内存后，<code>dyld</code>会通知<code>runtime</code>进行处理<br>4）<code>runtime</code> 接手后调用<code>map_images</code>做解析和处理<br>5）接下来<code>load_images</code> 中调用<code>call_load_methods</code>方法，遍历所有加载进来的<code>Class</code>，按继承层次依次调用Class的<code>+load</code>和其他Category的<code>+load</code>方法<br>6）至此 所有的信息都被加载到内存中<br>7）最后<code>dyld</code>调用真正的<code>main</code>函数  </p>
<ul>
<li>对象的<code>isa</code>指针指向所属的类  </li>
<li>类的<code>isa</code>指针指向了所属的元类  </li>
<li>元类的<code>isa</code>指向了根元类，根元类指向了自己。</li>
<li>类的<code>superClass</code> 指向父类最终到根类</li>
<li>根类的<code>superclass</code>指向<code>nil</code></li>
<li>元类的<code>superclass</code> 指向父元类，最终到根元类</li>
<li>根元类的<code>superclass</code> 指向根类</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1682758-675c67c6868038d1?imageMogr2/auto-orient/"></p>
<p>class_isMetaClass用于判断Class对象是否为元类，object_getClass用于获取对象的isa指针指向的对象。</p>
<h3 id="仓库地址"><a href="#仓库地址" class="headerlink" title="仓库地址"></a>仓库地址</h3><p><a href="https://coding.net/u/dream001/p/iOS_runtime/git/tree/master">dream001 demo仓库地址</a><br><a href="https://opensource.apple.com/source/objc4/">苹果官网开源代码</a><br><a href="https://developer.apple.com/documentation/objectivec/objective_c_runtime#//apple_ref/doc/uid/TP40001418-CH1g-126286">官方api</a></p>
<p><a href="https://juejin.im/post/5ac0a6116fb9a028de44d717">掘金runtime实战总结</a><br><a href="https://maxwellqi.github.io/ios-primary-main/">IOS程序在main函数前所做的事情</a>  <a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/">main</a><br><a href="http://blog.devtang.com/2014/09/09/ios-weekly-24/">devtang</a></p>
<p><a href="https://www.csdn.net/article/2015-07-06/2825133-objective-c-runtime/1">深入理解Objective-C的Runtime机制</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>《Effective-Objective-C 2.0》</title>
    <url>/2018/06/11/iOS/%E3%80%8AEffective-Objective-C%202.0%E3%80%8B/</url>
    <content><![CDATA[<p>图片原地址：<a href="https://upload-images.jianshu.io/upload_images/1457495-debf9e0c37687e51.png">https://upload-images.jianshu.io/upload_images/1457495-debf9e0c37687e51.png</a><br><img src="https://upload-images.jianshu.io/upload_images/1457495-debf9e0c37687e51.png" alt="图片"><br><a href="https://www.jianshu.com/p/862b064e82e0">对应简书总结</a><br><a href="https://github.com/aozhimin/awesome-iOS-resource/blob/master/Books/Effective%20Objective-C%202.0%20%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95.pdf">Effective-Objective-C 2.0.pdf</a><br><a href="https://github.com/aozhimin/awesome-iOS-resource/tree/master/Books">iOS相关书籍汇总</a></p>
<hr>
<p><em>分界线</em></p>
<hr>
<blockquote>
<p>说明：以下内容 均来自与jatstar的汇总 只做引用学习 没有商业用途 <a href="https://jatstar.cn/2016/07/10/Effective-Objective-C-2-0/">Effective-Objective-C 2.0</a></p>
</blockquote>
<h3 id="熟悉Objective-C"><a href="#熟悉Objective-C" class="headerlink" title="熟悉Objective-C"></a>熟悉Objective-C</h3><ul>
<li>起源<ol>
<li>由消息型语言鼻祖Smalltalk演化而来。是C语言的超集。</li>
<li>与函数式语言关键区别：消息结构的语言，运行时所执行的代码由运行环境决定(动态绑定)；函数调用的语言，由编译器决定。</li>
<li>NSString *someString 中 someString为指向NSString 的指针。Type * 声明的对象总是被分配的堆区(heap space) 中，而绝不可能分配的栈区(stack)。</li>
<li>如果只需保存int float double char 等非对象类型（nonoobject type） ，使用C结构体(如CGRect)比使用OC对象性能更优，因为创建OC对象需要分配及释放堆区内存等额外开销。 </li>
</ol>
</li>
<li>在类的头文件中尽量少引入其他头文件<ol>
<li>头文件在类的头文件中，少引入头文件，使用@Class 向前声明即可。 然后在实现文件中再引入那些类的头文件。这样可以降低类之间的耦合。</li>
<li>无法使用向前声明的情况，如果 引入当前类遵守的某一项协议，此时把协议单独放下一个头文件中，再将其引入。</li>
</ol>
</li>
<li>多用字面量语法，少用与之等价的方法。</li>
</ul>
<ol>
<li>举个🌰:</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *intNumber = @<span class="number">1</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *floatNumber = @<span class="number">2.5</span>f;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *namesArray = @[<span class="string">@&quot;Jat&quot;</span>,<span class="string">@&quot;Jay&quot;</span>,<span class="string">@&quot;Vae&quot;</span>];</span><br><span class="line"><span class="built_in">NSString</span> *myName = namesArray[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *personData = @&#123;<span class="string">@&quot;ChineseName&quot;</span>:<span class="string">@&quot;张建宇&quot;</span>,</span><br><span class="line"><span class="string">@&quot;EnglishName&quot;</span>:<span class="string">@&quot;Jat&quot;</span>,</span><br><span class="line"><span class="string">@&quot;age&quot;</span>:<span class="string">@&quot;23&quot;</span>&#125;</span><br><span class="line">Number *myAge = personData[<span class="string">@&quot;age&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过字面量创建的数组或者字典 ，如果值中有nil，会抛出异常。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>多用类型常量，少用＃define 预处理指令。  </p>
<ol>
<li>＃define定义的出来的常量，不包含类型信息，编译器需要再编译前执行查找替换，会增加编译时间。  </li>
<li>只在当前类使用的常量，可以使用 static const 在.m中定义。  </li>
<li>在头文件中使用extern来声明全局变量,并在相关实现文件中定义其值。命名时，通常使用于是相关的类名最为前缀。如  UITextFieldTextDidBeginEditingNotification 。  </li>
<li>《iOS开发中 const,static,extern用法总结》  </li>
</ol>
</li>
<li><p>使用枚举来表示状态，选项，状态码  </p>
<ol>
<li>易懂的枚举名可以提高代码的可读性。  </li>
<li>选项为多选时，使用二进制表示枚举值，以便通过按位或将其组合起来。🌰：  UIInterfaceOrientationMask。  </li>
<li>switch语句中，不要实现default分支。这样加入新的枚举之后，编译器会提示：switch语句没有处理所有枚举值。  <h3 id="消息／对象／运行时"><a href="#消息／对象／运行时" class="headerlink" title="消息／对象／运行时"></a>消息／对象／运行时</h3></li>
</ol>
</li>
<li><p>理解“属性” 这一概念 Objective-C语法@property详解</p>
</li>
<li><p>在对象内部尽量直接访问实例变量。</p>
<ol>
<li>直接访问实例变量不经过方法派发，比点语法快。</li>
<li>⚠️直接访问copy修饰的属性，不会掉用setter方法，所以不会拷贝该属性。</li>
<li>⚠️不会触发KVO通知。是否会产生问题，视情况而定。</li>
<li>初始化方法和dealloc方法中，总是应该直接访问。</li>
<li>⚠️注意考虑懒加载的情况下，要使用点语法。</li>
</ol>
</li>
<li><p>理解“对象等同性”这一概念。</p>
<ol>
<li>==比较的是指针地址是否一样。</li>
<li>特有的等同性判断方法，如isEqualToString比isEqual快一些。</li>
<li>相同的对象必须具有相同的哈希码，但是哈希码相同的对象未必相同。</li>
<li>不必逐条比较每个属性的哈希码，依情况，使用速度快，碰撞率低的算法。</li>
</ol>
</li>
<li><p>以“类族模式”隐藏实现细节</p>
<ol>
<li>例如UIButton 中的 + (instancetype)buttonWithType:(UIButtonType)buttonType.</li>
<li>可以把实现细节隐藏在一个公共的接口后面。</li>
</ol>
</li>
<li><p>在既有类中使用关联对象存放自定义数据</p>
</li>
<li><p>理解objc_msgSend 的作用</p>
<ol>
<li>Objective-c “动态绑定(dynamic binding)” 的特性使得所要调用的函数直到运行时才能确定。通过动态消息派发系统(dynamic message dicpatch system)来查出对应的方法并执行。</li>
<li>消息由接收者(receiver)，选择子(selecter)，以及参数构成。调用方法实际上相当于在给对象发送消息。</li>
</ol>
</li>
<li><p>理解消息转发机制 //TODO： 待续</p>
</li>
<li><p>用方法调配技术调试黑盒方法 </p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Category</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSString+Test.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc runtime.h=&quot;&quot;&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">Test</span>)</span></span><br><span class="line">- (<span class="built_in">NSString</span>*)eoc_myLowercaseString &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *lowercase = [<span class="keyword">self</span> eoc_myLowercaseString];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ =&gt; %@&quot;</span>, <span class="keyword">self</span>, lowercase);</span><br><span class="line">    <span class="keyword">return</span> lowercase;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不会死循环，因为eoc_myLowercaseString与lowercaseString方法互换了，运行时期间eoc_myLowercaseString选择子实际上对应的原有的lowercaseString方法实现。</span></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>],<span class="keyword">@selector</span>(lowercaseString));</span><br><span class="line">    Method swappedMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>],<span class="keyword">@selector</span>(eoc_myLowercaseString));</span><br><span class="line">    method_exchangeImplementations(originalMethod, swappedMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">测试一下：</span></span><br><span class="line"><span class="comment">NSString *string = @&quot;Hello World&quot;;</span></span><br><span class="line"><span class="comment">NSString *textString = [string lowercaseString];</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">Hello World =&gt; hello world</span></span><br><span class="line"><span class="comment">*/</span>&lt;/objc&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>理解类对象的用意 //TODO: 待续</p>
<h3 id="接口与API设计"><a href="#接口与API设计" class="headerlink" title="接口与API设计"></a>接口与API设计</h3></li>
<li><p>使用前缀避免命名空间冲突。</p>
</li>
<li><p>提供全能初始化方法</p>
<ol>
<li>提供一个全能初始化方法，并与文档中指明，其他初始化方法均调用此方法。</li>
<li>全能初始化方法与超类不同时，应该重写，冲突时，应该加上抛异常机制提示。</li>
</ol>
</li>
<li><p>实现description方法</p>
<ol>
<li>自定义类，覆写description方法，返回的字符串，NSLog时的显示该字符串；</li>
<li>重写debugDescription，改变调试控制台输出信息，默认为description方法的返回值。</li>
</ol>
</li>
<li><p>尽量使用不可变对象。</p>
</li>
<li><p>使用清晰而且协调的命名方式</p>
</li>
<li><p>为私有方法名加前缀</p>
<ol>
<li>给私有方法名加上前缀(虽然我感觉没必要～也没见过知名开源项目有加；但是爱老婆说按规范要加)</li>
<li>不要使用下划线做私有方法的前缀，因为这种做法是预留给苹果的。</li>
</ol>
</li>
<li><p>理解Objective-C错误模型</p>
<ol>
<li>只有发生使整个应用崩溃的严重错误时，才之用异常。</li>
<li>不那么严重的错误，可以指派委托方法来处理错误，也可以把错误信息放在NSError里，由NSLog输出。 </li>
</ol>
</li>
<li><p>理解NSCoding协议。</p>
<ol>
<li>想令对象具有拷贝功能，需实现NSCoying协议；如果对象有可变版本，还需要实现NSMutableCopying协议。</li>
<li>浅拷贝之后的内容与原始内容指针地址相同，深拷贝之后的内容指向原始内容相关对象的一份拷贝。(深拷贝会逐个元素发送Copy消息，用拷贝得到元素创建Set);</li>
</ol>
</li>
<li><p>通过委托与数据源协议进行对象间的通信。</p>
<ol>
<li>@property(nonatomic,weak)id<classnamedelegate> delegate</classnamedelegate> 用weak修饰，，防止循环引用(retain cycle);</li>
</ol>
</li>
<li><p>将类的实现代码分散到便于管理的数个分类之中。//易于管理</p>
</li>
<li><p>总是为第三方类的分类名称增加前缀。</p>
</li>
<li><p>勿在分类中声明属性。</p>
<ol>
<li>封装数据所用的全部属性都定义在主接口里。</li>
<li>关联对象可以解决分类不能合成实例变量的问题。//本书作者认为此方法内存管理上容易出错，不是很推荐。</li>
</ol>
</li>
<li><p>使用“class-continuation”分类 隐藏实现细节 //就是Extension吧，匿名的分类。</p>
</li>
<li><p>通过协议提供匿名对象。 //隐藏返回值类型</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3></li>
<li><p>理解引用计数</p>
</li>
<li><p>以ARC简化引用计数</p>
</li>
<li><p>在dealloc方法中只释放引用并移除监听(KVO和Notifications)</p>
</li>
<li><p>编写 “异常安全代码”时留意内存管理问题(即：使用@try...@catch语法时)</p>
</li>
<li><p>以弱引用避免保留环(retain cycle :循环引用)</p>
</li>
<li><p>以“自动释放池块”降低内存峰值。</p>
</li>
<li><p>用“僵尸对象”调试内存管理问题。</p>
<ol>
<li>系统在回收对象时，可以不将其真正回收，而是把它转化为僵尸对象。</li>
<li>系统会修改对象的isa指针，令其指向特殊的僵尸类。僵尸类能够响应所有的选择子，打印一条包含消息内容以及接收者的消息，然后终止程序。</li>
</ol>
</li>
<li><p>不要使用retainCount。(ARC模式下，此方法废弃了)。</p>
<h3 id="block与GCD"><a href="#block与GCD" class="headerlink" title="block与GCD"></a>block与GCD</h3></li>
</ul>
<p>//翻译成 块与大中枢派发也是醉了。。。</p>
<ul>
<li>理解block这一概念。<ol>
<li>语法结构： return_type (^block_name)(parameters)</li>
<li>默认情况下block外的变量需要在block中修改的，需要在声明时加__block修饰，但block修改其所在的类的成员变量时不需要加。</li>
<li>定义block时，它是分配在栈区的，所以。只在其作用域范围有效。调用copy拷贝到堆区之后可以和OC对象一样具备引用计数。由ARC去管理。</li>
</ol>
</li>
<li>为常见的block类型创建typedef</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(^SomeBlock)(<span class="built_in">BOOL</span> flag,<span class="keyword">int</span> value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line">SomeBlock block = ^ (<span class="built_in">BOOL</span> flag,<span class="keyword">int</span> value)&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">return</span> value * <span class="number">5</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value *<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用handler block降低代码的分散程度。//如AFN中的网络请求回调</li>
<li>用block引用其所属对象时不要出现循环引用。</li>
<li>多用派发队列，少用同步锁。<ol>
<li>派发队列可以用来表述同步语义(synchornization semantic),比使用@synchronized块和NSLock对象更简单。</li>
<li>使用同步和异步派发结合起来，可以实现与普通加锁一样的同步行为，而且不会阻塞执行异步派发的线程。</li>
<li>使用同步队列和栅栏块，可以让同步锁更加高效。</li>
</ol>
</li>
<li>多用GCD,少用｀performSelector｀系列方法。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SEL selector;</span><br><span class="line"><span class="keyword">if</span>(<span class="comment">/* some condition */</span>)&#123;</span><br><span class="line">    selector = <span class="keyword">@selector</span>(foo);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/* some other condition */</span>)&#123;</span><br><span class="line">    selector = <span class="keyword">@selector</span>(bar);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    selector = @selecter(baz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>/*<br>运行时才能确定调用列哪个方法，<br>编译器没有办法在编译时按ARC的内存管理原则判定返回值是不是该释放，<br>编译器没有添加释放操作。<br>这将又可能导致内存泄漏<br>*/</p>
<ul>
<li>掌握GCD和NSOperationQueue的使用时机。<ol>
<li>运行任务之前，可以用在NSOperation对象上调用cancel取消该任务。</li>
<li>可以指定任务间的依赖关系。</li>
<li>可以通过KVO监听NSOperation的属性。例如isFinished,isCancelled。</li>
<li>指定操作的优先级。</li>
<li>重用NSOperation对象。</li>
</ol>
</li>
<li>通过Dispathtch Group机制，根据系统资源状况来执行任务。</li>
<li>使用dispatch_once来执行只需运行一次的线程安全代码。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+(<span class="keyword">id</span>)sharedInstance&#123;</span><br><span class="line">    <span class="keyword">static</span> SomeClass *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(@onceToken,^&#123;</span><br><span class="line">        sharedInstance = [[<span class="keyword">self</span> alloc]init];</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不要使用dispatch_get_current_queue(void);//调试还是可以用下的</p>
<h3 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h3></li>
<li><p>熟悉系统框架。</p>
<ol>
<li>CFNetWork:提供C语言级别的网络通信能力，将BSDsocket抽象成易于使用的接口。</li>
<li>CoreAudio:提供的C语言API可用来操作设备上的音频硬件。</li>
<li>AVFoundation:处理音频视频的录制，回放。</li>
<li>CoreData:用于实现数据持久化。</li>
<li>CoreText:提供C语言接口，用于执行文字排版以及渲染操作。</li>
</ol>
</li>
<li><p>多用block枚举，少用for循环。//block枚举本身通过GCD并发执行遍历，更高效。</p>
</li>
<li><p>对自定义其内存管理语义的cellection使用无缝桥接。</p>
</li>
<li><p>构建缓存时选用NSCache而非NSDictionary.// low memory时 NSCache会自动删减缓存</p>
</li>
<li><p>精简initalize和load的实现代码。</p>
<ol>
<li>iOS平台上，当类或者分类载入系统时，会先调用+(void) load;同时实现时，先调类里面的，再调用分类里面的。</li>
<li>无法判断各个类载入的顺序，所以在load方法使用第三方类比较危险。</li>
<li>load方法会阻塞线程，所以要尽量精简里面的代码。</li>
<li>首次使用某个类是，会调用该类的+(void) initalize方法，可以覆写该方法做一些与类相关的初始化操作。但是同load一样，也应该尽量精简。</li>
</ol>
</li>
<li><p>别忘了NSTimer会保留目标对象。//weakSelf大法打破循环就好了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是cocoapods</title>
    <url>/2016/06/11/iOS/%E4%BB%80%E4%B9%88%E6%98%AFCocoaPods/</url>
    <content><![CDATA[<h2 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h2><h3 id="什么是CocoaPods"><a href="#什么是CocoaPods" class="headerlink" title="什么是CocoaPods"></a>什么是CocoaPods</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CocoaPods是一个用来帮助我们管理第三方依赖库的工具。</span><br><span class="line">它可以解决库与库之间的依赖关系，下载库的源代码，</span><br><span class="line">同时通过创建一个Xcode的workspace来将这些第三方库和我们的工程连接起来，</span><br><span class="line">供我们开发使用。</span><br><span class="line">使用CocoaPods的目的是让我们能自动化的、集中的、直观的管理第三方开源库。</span><br></pre></td></tr></table></figure>

<h3 id="为什么需要CocoaPods"><a href="#为什么需要CocoaPods" class="headerlink" title="为什么需要CocoaPods"></a>为什么需要CocoaPods</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   在进行iOS开发的时候，总免不了使用第三方的开源库，</span><br><span class="line">比如SBJson、AFNetworking、Reachability等等。使用这些库的时候通常需要：</span><br><span class="line">   下载开源库的源代码并引入工程</span><br><span class="line">   向工程中添加开源库使用到的framework</span><br><span class="line">   解决开源库和开源库以及开源库和工程之间的依赖关系、</span><br><span class="line">   检查重复添加的framework等问题</span><br><span class="line">	如果开源库有更新的时候，还需要将工程中使用的开源库删除，</span><br><span class="line">重新执行前面的三个步骤</span><br></pre></td></tr></table></figure>
<h3 id="CocoaPods的安装"><a href="#CocoaPods的安装" class="headerlink" title="CocoaPods的安装"></a>CocoaPods的安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	1、安装</span><br><span class="line">	CocoaPods是用Ruby实现的，要想使用它首先需要有Ruby的环境。</span><br><span class="line">	幸运的是OS X系统默认的已经可以运行Ruby了，因此我们只需要执行以下命令：</span><br><span class="line">	 $ sudo gem install cocoapods  </span><br><span class="line">	CocoaPods是以Ruby gem包的形式被安装的。在安装执行的过程中，</span><br><span class="line">	可能会问我们是不是更新rake，输入y即可。这是因为rake gem包会在安装的过程中检查更细，</span><br><span class="line">	如果有可用的新版本就会出现刚才的选项。</span><br><span class="line">	在安装进程结束的时候，执行命令：</span><br><span class="line">   	 $ pod setup  </span><br><span class="line"></span><br><span class="line">   	 2、安装过程中可能遇到的问题</span><br><span class="line">   	   执行完install命令半天没反应  ---被墙了</span><br><span class="line">   	   gem版本过老 ---- sudo gem update --system  </span><br><span class="line">   	   安装完成后，执行pod setup命令时报错：rvm use ruby-1.9.3-p448  </span><br><span class="line">     3、升级CocoaPods</span><br><span class="line">     	sudo gem install cocoapods  </span><br><span class="line">CocoaPods的使用：</span><br><span class="line">	1、创建Podfile  cd到项目目录 touch Podfile</span><br><span class="line">	2、编辑Podfile </span><br><span class="line">	3、开始安装 pod install</span><br></pre></td></tr></table></figure>

<p>安装完成后就可以使用了</p>
<h2 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h2><h3 id="使用cocoapods出现ld-symbol-s-not-found-for-architecture-x86-64问题"><a href="#使用cocoapods出现ld-symbol-s-not-found-for-architecture-x86-64问题" class="headerlink" title="使用cocoapods出现ld: symbol(s) not found for architecture x86_64问题"></a>使用cocoapods出现ld: symbol(s) not found for architecture x86_64问题</h3><p><a href="https://cn.aliyun.com/jiaocheng/398823.html">解决方案</a></p>
<h2 id="cocoapods版本兼容问题"><a href="#cocoapods版本兼容问题" class="headerlink" title="cocoapods版本兼容问题"></a>cocoapods版本兼容问题</h2><p><a href="https://blog.csdn.net/u013749108/article/details/53239557">使用bundle管理多版本Cocoapods之间的协助开发</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>使用bundle管理多版本Cocoapods之间的协助开发</title>
    <url>/2016/06/11/iOS/%E4%BD%BF%E7%94%A8bundle%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACCocoapods%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E5%8A%A9%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>一般在公司团队开发中，在使用Cocoapods的时候，会面临同事之间使用的pod版本不一致的问题。</p>
<p>由于不同版本的pod在执行pod install或者pod update的时候会改变 .xcodeproj 的格式 或为xml 或者 json。这样就会造成很难解决的冲突问题。</p>
<p>因此这里介绍一下如何高效便捷的统一我们的Cocoapods版本。</p>
<h3 id="Bundle："><a href="#Bundle：" class="headerlink" title="Bundle："></a>Bundle：</h3><p>Bundler是一个ruby环境下的一个gem。</p>
<p>使用 Bundler 的原理就是通过为每个项目指定特定的一个pod版本,使用这个版本来执行install或者update。</p>
<p>好处就是我们在安装多个pod版本的时候，根据不同的项目需求去执行pod命令的时候，不用手动去切换pod的版本。</p>
<p>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gem install bundler</span><br></pre></td></tr></table></figure>

<p>创建gemfile文件</p>
<p>cd 项目目录  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bundle init</span><br></pre></td></tr></table></figure>

<p>这样, 与 <code>.xcodeproj</code> 同级的目录中就会多出一个 <code>Gemfile</code>文件。</p>
<p>在Gemfile里添加如下代码，指定pod版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># frozen_string_literal: true</span><br><span class="line">source &quot;https://rubygems.org&quot;</span><br><span class="line"></span><br><span class="line"># gem &quot;rails&quot;</span><br><span class="line">gem &#x27;cocoapods&#x27;, &#x27;0.39.0&#x27;</span><br></pre></td></tr></table></figure>

<p>到这里已经安装完毕，使用起来也很简单<br>在之前执行的命令前面加上 <code>bundle exec</code>就好了，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bundle exec pod install --verbose --no-repo-update</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">bundle exec pod update --verbose --no-repo-update</span><br></pre></td></tr></table></figure>

<h3 id="本地cocoapods版本列举"><a href="#本地cocoapods版本列举" class="headerlink" title="本地cocoapods版本列举"></a>本地cocoapods版本列举</h3><p>可以通过 gem list –local | grep cocoapods 命令查看我们电脑上安装了哪些版本的 CocoaPods，并通过 pod –version 查看系统默认使用的那个版本。</p>
<p><a href="https://www.jianshu.com/p/411003ac28e4">多个版本的 CocoaPods 的切换</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS总结的点</title>
    <url>/2018/06/11/iOS/%E6%80%BB%E7%BB%93%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<h3 id="UIImage中-imageNamed-和-imageWithContentsOfFile的区别"><a href="#UIImage中-imageNamed-和-imageWithContentsOfFile的区别" class="headerlink" title="UIImage中 imageNamed 和 imageWithContentsOfFile的区别"></a>UIImage中 imageNamed 和 imageWithContentsOfFile的区别</h3><p><code>[UIImage imageNamed:]</code>只适合与UI界面中小的贴图的读取，而一些比较大的资源文件应该尽量避免使用这个接口。<br>直接读取文件路径<code>[UIImage imageWithContentsOfFile]</code>来解决图片的读取问题<br>这两种方式的主要区别在于：<br><code>imageName</code>的方式会在使用的时候系统会cache，程序员是无法处理cache的，这是由系统自动处理的，对于重复加载的图像，速度会提升很多，这样反而用户体验好。所以如果某张图片需要在应用中使用多次，或者重复引用，使用<code>imageName</code>的方式会更好<br><code>imageWithContentsOfFile</code>的方式，在使用完成之后系统会释放，不会缓存下来，所以也就没有这样的问题。一般也不会把所有的图片都会缓存。有些图片在应用中只使用一两次的，就可以用这样的方式，比如新手引导界面的图片等等，就适合这样的方式。没有明显的界限。</p>
<h3 id="CALayer-和-UIView的区别"><a href="#CALayer-和-UIView的区别" class="headerlink" title="CALayer 和 UIView的区别"></a>CALayer 和 UIView的区别</h3><p><code>CALayer</code>属于<code>Core Animation</code>部分的内容，比较重要而不太好理解。以下是园子中看到的一篇文章的摘录：</p>
<ol>
<li><code>UIView</code>是<code>iOS</code>系统中界面元素的基础，所有的界面元素都是继承自它。它本身完全是由   <code>CoreAnimation</code>来实现的。它真正的绘图部分，是由一个<code>CALayer</code>类来管理。<code>UIView</code>本身更像是一个<code>CALayer</code>的管理器，访问它的跟绘图和跟坐标有关的属性，例如<code>frame，bounds</code>等，实际上内部都是在访问它所包含的<code>CALayer</code>的相关属性。</li>
<li><code>UIView</code>有个重要属性<code>layer</code>，可以返回它的主<code>CALayer</code>实例。</li>
</ol>
<h3 id="如何定义一个不规则的button-（还包含一个问题若干个button叠加在一起，苹果如何知道点击的是哪个button，实现原理？）"><a href="#如何定义一个不规则的button-（还包含一个问题若干个button叠加在一起，苹果如何知道点击的是哪个button，实现原理？）" class="headerlink" title="如何定义一个不规则的button （还包含一个问题若干个button叠加在一起，苹果如何知道点击的是哪个button，实现原理？）"></a>如何定义一个不规则的button （还包含一个问题若干个button叠加在一起，苹果如何知道点击的是哪个button，实现原理？）</h3><p>  在<code>iOS</code>中通常使用<code>hit-testing</code>去找到那个被触摸的视图。这个视图叫<code>hit-test view</code>，当<code>iOS</code>找到<code>hit-test view</code>后就把<code>touch event</code>交个那个视图来处理。</p>
<h3 id="用GCD的方式去实现有n个线程去访问一个属性，只有一个线程去修改属性"><a href="#用GCD的方式去实现有n个线程去访问一个属性，只有一个线程去修改属性" class="headerlink" title="用GCD的方式去实现有n个线程去访问一个属性，只有一个线程去修改属性"></a>用GCD的方式去实现有n个线程去访问一个属性，只有一个线程去修改属性</h3><h3 id="NSRunloop的使用"><a href="#NSRunloop的使用" class="headerlink" title="NSRunloop的使用"></a>NSRunloop的使用</h3><p> 那么具体什么是<code>NSRunLoop</code>呢？其实<code>NSRunLoop</code>的本质是一个消息机制的处理模式。<br> <code>NSRunLoop</code>是一种更加高明的消息处理模式<br> <a href="http://blog.csdn.net/cwq9944/article/details/8555104">http://blog.csdn.net/cwq9944/article/details/8555104</a></p>
<h3 id="CoreAnimation-与-UIViewAnimation分别何时会使用"><a href="#CoreAnimation-与-UIViewAnimation分别何时会使用" class="headerlink" title="CoreAnimation 与 UIViewAnimation分别何时会使用"></a>CoreAnimation 与 UIViewAnimation分别何时会使用</h3><h3 id="arc-和-gc-理解"><a href="#arc-和-gc-理解" class="headerlink" title="arc 和 gc 理解"></a>arc 和 gc 理解</h3><p> ARC是iOS 5推出的新功能，全称叫 ARC(Automatic Reference Counting)。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。<br> ARC基本规则</p>
<p>retain, release, autorelease, dealloc由编译器自动插入，不能在代码中调用<br>dealloc虽然可以被重载，但是不能调用[super dealloc]</p>
<h3 id="如何在ARC代码中混编非ARC代码"><a href="#如何在ARC代码中混编非ARC代码" class="headerlink" title="如何在ARC代码中混编非ARC代码"></a>如何在ARC代码中混编非ARC代码</h3><p> “ios中如果arc和非arc文件混编，可以在build parses中指定compile flags，如果arc文件设为”-fobjc-arc”,非arc文件设为”-fno-objc-arc””  </p>
<p> 使用了ARC之后如果你想复用以前写过的使用MRC的类， 就会出报错。这时候怎么办？方法比较简单， 只需要做下面的一个步骤就可以解决：<br> 在targets的build phases选项下Compile Sources下选择要不使用arc编译的文件，双击它，输入 -fno-objc-arc 即可</p>
<p> MRC工程中也可以使用ARC的类。方法如下：<br> 在targets的build phases选项下Compile Sources下选择要使用arc编译的文件，双击它，输入 -fobjc-arc 即可</p>
<h3 id="NSAutoreleasepool理解"><a href="#NSAutoreleasepool理解" class="headerlink" title="NSAutoreleasepool理解"></a>NSAutoreleasepool理解</h3><p>  iOS的运行时是由一个一个runloop组成的</p>
<p> 每个runloop中都创建一个Autorelease Pool，并在runloop的末尾进行释放，<br> 所以，一般情况下，每个接受autorelease消息的对象，都会在下个runloop开始前被释放。也就是说，在一段同步的代码中执行过程中，生成的对象接受autorelease消息后，一般是不会在代码段执行完成前释放的。</p>
<p> 当然也有让autorelease提前生效的办法：自己创建Pool并进行释放</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSAutoreleasePool</span> * pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="built_in">NSArray</span> * array = [[[<span class="built_in">NSArray</span> alloc] init] autorelease];</span><br><span class="line">[pool drain];</span><br></pre></td></tr></table></figure>

<h3 id="weak-block"><a href="#weak-block" class="headerlink" title="__weak,__block"></a>__weak,__block</h3><p>   __weak不增加引用，__block增加引用<br>   举例哦，某对象self，self的strong成员变量有blockA，blockA内部引用了self，如果self不经过__weak处理，就会变成：</p>
<p> self强引用blockA，blockA强引用self。这不就循环引用了嘛</p>
<h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><p>由于runtime是更底层的语言，我们编写的OC代码在运行时，编译器内部会先转为C和C++的代码，然后再执行，因而运用runtime机制，程 序的性能也会更好。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> no;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>复制代码<br>  然后，我们在其它文件中使用这个类，注意在使用之前，要包含 #import &lt;objc/message.h&gt;</p>
<p> 下面通过一小段代码来获取到上面这个类中所有的成员变量</p>
<p>复制代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">    Ivar *vars = class_copyIvarList([Lender <span class="keyword">class</span>], &amp;outCount); </span><br><span class="line">    <span class="comment">// 获取到所有的成员变量列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的成员变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">        Ivar ivar = vars[i]; <span class="comment">// 取出第i个位置的成员变量</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = ivar_getName(ivar); <span class="comment">// 获取变量名</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *propertyType = ivar_getTypeEncoding(ivar); <span class="comment">// 获取变量编码类型</span></span><br><span class="line">        printf(<span class="string">&quot;---%s--%s\n&quot;</span>, propertyName, propertyType);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么是GCD？"><a href="#什么是GCD？" class="headerlink" title="什么是GCD？"></a>什么是GCD？</h3><p> Grand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，<br> GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。<br> GCD的基本概念就是dispatch queue。dispatch queue是一个对象，它可以接受任务，并将任务以先到先执行的顺序来执行。dispatch queue可以是并发的或串行的。并发任务会像NSOperationQueue那样基于系统负载来合适地并发进行，串行队列同一时间只执行单一任务。<br> GCD中有三种队列类型：<br> The main queue: 与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。main queue可以调用dispatch_get_main_queue()来获得。因为main queue是与主线程相关的，所以这是一个串行队列。<br> Global queues: 全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。可以调用dispatch_get_global_queue函数传入优先级来访问队列。<br> 用户队列: 用户队列 (GCD并不这样称呼这种队列, 但是没有一个特定的名字来形容这种队列，所以我们称其为用户队列) 是用函数 dispatch_queue_create 创建的队列. 这些队列是串行的。正因为如此，它们可以用来完成同步机制, 有点像传统线程中的mutex。  </p>
<p> 首先，我们要明确NSOperationQueue与GCD之间的关系</p>
<p> NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象。</p>
<p> 其次，我们要区别两者的不同</p>
<p> GCD仅仅支持FIFO队列，而NSOperationQueue中的队列可以被重新设置优先级，从而实现不同操作的执行顺序调整</p>
<p>   <a href="http://www.dreamingwish.com/frontui/article/default/ios-multithread-program-runloop-the.html">http://www.dreamingwish.com/frontui/article/default/ios-multithread-program-runloop-the.html</a></p>
<h3 id="xcode：关于Other-Linker-Flags"><a href="#xcode：关于Other-Linker-Flags" class="headerlink" title="xcode：关于Other Linker Flags"></a>xcode：关于Other Linker Flags</h3><p> 关于Other Linker Flags</p>
<p> xcode中，在“Targets”选项下有Other Linker Flags选项，在这里可以填写xcode链接器的参数，如：-ObjC、-all_load、-force_load等。<br> 主要参数</p>
<p> 这里要说的主要参数是ld工具的参数，也是在Other Linker Flags里常用到的参数。</p>
<p> 1.-ObjC</p>
<p> 当使用ObjC写的静态类别库（Objective-C static library that contains categories），在程序编译链接时，如果不在Other Linker Flags中填写-ObjC，往往会报错，出现”selector not recognized”。博主无力，原因看不太懂。具体原因请查阅xcode帮助文档。</p>
<p> -ObjC的作用是加载用ObjC实现的类、类别等所有成员。</p>
<p> 2.-all_load</p>
<p> 强制链接器加载所有包含非ObjC的目标文档。</p>
<ol start="3">
<li>-force_load</li>
</ol>
<p> 加载指定的目标文档。-force_load后面需要文档路径</p>
<h3 id="strong：会retain（强引用）"><a href="#strong：会retain（强引用）" class="headerlink" title="__strong：会retain（强引用）"></a>__strong：会retain（强引用）</h3><p>__weak NSObject *obj;和assign类似，多一个功能：对象销毁后置为nil</p>
<p>__autoreleasing：使对象延迟释放</p>
<p>__bridge:忽略所有的内存管理细节</p>
<p>Core Foundation需要使用桥接，    </p>
<h3 id="Objective-C运行时定义了几种重要的类型。"><a href="#Objective-C运行时定义了几种重要的类型。" class="headerlink" title="Objective-C运行时定义了几种重要的类型。"></a>Objective-C运行时定义了几种重要的类型。</h3><p> Class：定义Objective-C类<br> Ivar：定义对象的实例变量，包括类型和名字。<br> Protocol：定义正式协议。<br> objc_property_t：定义属性。叫这个名字可能是为了防止和Objective-C 1.0中的用户类型冲突，那时候还没有属性。<br> Method：定义对象方法或类方法。这个类型提供了方法的名字（就是<strong>选择器</strong>）、参数数量和类型，以及返回值（这些信息合起来称为方法的<strong>签名</strong>），还有一个指向代码的函数指针（也就是方法的<strong>实现</strong>）。<br> SEL：定义选择器。选择器是方法名的唯一标识符。<br> IMP：定义方法实现。这只是一个指向某个函数的指针，该函数接受一个对象、一个选择器和一个可变长参数列表（varargs），返回一个对象  </p>
<h3 id="Objective-C-Method-Swizzling-IOS-中方法重组"><a href="#Objective-C-Method-Swizzling-IOS-中方法重组" class="headerlink" title="Objective-C Method Swizzling IOS 中方法重组"></a>Objective-C Method Swizzling IOS 中方法重组</h3><p>相关常用方法，都在包内：</p>
<p>//向类中添加Method<br><code>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</code></p>
<p>//修改类的Method IMP<br><code>class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</code></p>
<p>//交换2个方法中的IMP<br><code>void method_exchangeImplementations(Method m1, Method m2)</code></p>
<p>//获取类的某个实例方法<br><code>Method class_getInstanceMethod(Class aClass, SEL aSelector);</code><br>底层原理</p>
<p>在运行时，<code>oc</code> 的方法被称为一种叫 <code>Method</code> 的结构体，这种 <code>objc_method</code> 类型的结构体定义为：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">   SEL method_name         OBJC2_UNAVAILABLE;</span><br><span class="line">   <span class="keyword">char</span> *method_types      OBJC2_UNAVAILABLE;</span><br><span class="line">   IMP method_imp          OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>UIBezierPath画边角弧度</title>
    <url>/2018/06/11/iOS/%E7%94%BB%E8%BE%B9%E8%A7%92%E5%BC%A7%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="UIBezierPath"><a href="#UIBezierPath" class="headerlink" title="UIBezierPath"></a>UIBezierPath</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIBezierPath</span> *maskPath = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:m_newsIV.bounds</span><br><span class="line">                                                     byRoundingCorners:<span class="built_in">UIRectCornerTopLeft</span> | <span class="built_in">UIRectCornerTopRight</span></span><br><span class="line">                                                           cornerRadii:<span class="built_in">CGSizeMake</span>(<span class="number">10.0</span>, <span class="number">10.0</span>)];</span><br><span class="line">      <span class="comment">// Create the shape layer and set its path</span></span><br><span class="line">      <span class="built_in">CAShapeLayer</span> *maskLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">      maskLayer.frame = m_newsIV.bounds;</span><br><span class="line">      maskLayer.path = maskPath.CGPath;</span><br><span class="line">      <span class="comment">// Set the newly created shape layer as the mask for the image view&#x27;s layer</span></span><br><span class="line">      m_newsIV.layer.mask = maskLayer;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>正则</title>
    <url>/2018/06/11/iOS/%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<table log-set-param="table_view" data-sort="sortDisabled" valign="top"><tbody><tr><td align="left" width="75">
<div class="para"><strong>元字符</strong></div>
</td>
<td align="left" valign="top" width="658">
<div class="para"><strong>描述</strong></div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">\</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，&ldquo;\\n&rdquo;匹配\n。&ldquo;\n&rdquo;匹配换行符。序列&ldquo;\\&rdquo;匹配&ldquo;\&rdquo;而&ldquo;\(&rdquo;则匹配&ldquo;(&rdquo;。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">^</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配&ldquo;\n&rdquo;或&ldquo;\r&rdquo;之后的位置。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">$</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配&ldquo;\n&rdquo;或&ldquo;\r&rdquo;之前的位置。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">*</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">匹配前面的子表达式零次或多次(大于等于0次)。例如，zo*能匹配&ldquo;z&rdquo;，&ldquo;zo&rdquo;以及&ldquo;zoo&rdquo;。*等价于{0,}。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">+</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">匹配前面的子表达式一次或多次(大于等于1次）。例如，&ldquo;zo+&rdquo;能匹配&ldquo;zo&rdquo;以及&ldquo;zoo&rdquo;，但不能匹配&ldquo;z&rdquo;。+等价于{1,}。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">?</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">匹配前面的子表达式零次或一次。例如，&ldquo;do(es)?&rdquo;可以匹配&ldquo;do&rdquo;或&ldquo;does&rdquo;中的&ldquo;do&rdquo;。?等价于{0,1}。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">{n}</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">n是一个非负整数。匹配确定的n次。例如，&ldquo;o{2}&rdquo;不能匹配&ldquo;Bob&rdquo;中的&ldquo;o&rdquo;，但是能匹配&ldquo;food&rdquo;中的两个o。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">{n,}</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">n是一个非负整数。至少匹配n次。例如，&ldquo;o{2,}&rdquo;不能匹配&ldquo;Bob&rdquo;中的&ldquo;o&rdquo;，但能匹配&ldquo;foooood&rdquo;中的所有o。&ldquo;o{1,}&rdquo;等价于&ldquo;o+&rdquo;。&ldquo;o{0,}&rdquo;则等价于&ldquo;o*&rdquo;。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">{n,m}</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，&ldquo;o{1,3}&rdquo;将匹配&ldquo;fooooood&rdquo;中的前三个o。&ldquo;o{0,1}&rdquo;等价于&ldquo;o?&rdquo;。请注意在逗号和两个数之间不能有空格。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">?</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串&ldquo;oooo&rdquo;，&ldquo;o+?&rdquo;将匹配单个&ldquo;o&rdquo;，而&ldquo;o+&rdquo;将匹配所有&ldquo;o&rdquo;。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">.点</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">匹配除&ldquo;\r\n&rdquo;之外的任何单个字符。要匹配包括&ldquo;\r\n&rdquo;在内的任何字符，请使用像&ldquo;[\s\S]&rdquo;的模式。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">(pattern)</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0&hellip;$9属性。要匹配圆括号字符，请使用&ldquo;\(&rdquo;或&ldquo;\)&rdquo;。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">(?:pattern)</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符&ldquo;(|)&rdquo;来组合一个模式的各个部分是很有用。例如&ldquo;industr(?:y|ies)&rdquo;就是一个比&ldquo;industry|industries&rdquo;更简略的表达式。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">(?=pattern)</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，&ldquo;Windows(?=95|98|NT|2000)&rdquo;能匹配&ldquo;Windows2000&rdquo;中的&ldquo;Windows&rdquo;，但不能匹配&ldquo;Windows3.1&rdquo;中的&ldquo;Windows&rdquo;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">(?!pattern)</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如&ldquo;Windows(?!95|98|NT|2000)&rdquo;能匹配&ldquo;Windows3.1&rdquo;中的&ldquo;Windows&rdquo;，但不能匹配&ldquo;Windows2000&rdquo;中的&ldquo;Windows&rdquo;。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">(?&lt;=pattern)</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">反向肯定预查，与正向肯定预查类似，只是方向相反。例如，&ldquo;(?&lt;=95|98|NT|2000)Windows&rdquo;能匹配&ldquo;2000Windows&rdquo;中的&ldquo;Windows&rdquo;，但不能匹配&ldquo;3.1Windows&rdquo;中的&ldquo;Windows&rdquo;。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">(?&lt;!pattern)</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">反向否定预查，与正向否定预查类似，只是方向相反。例如&ldquo;(?&lt;!95|98|NT|2000)Windows&rdquo;能匹配&ldquo;3.1Windows&rdquo;中的&ldquo;Windows&rdquo;，但不能匹配&ldquo;2000Windows&rdquo;中的&ldquo;Windows&rdquo;。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">x|y</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">匹配x或y。例如，&ldquo;z|food&rdquo;能匹配&ldquo;z&rdquo;或&ldquo;food&rdquo;。&ldquo;(z|f)ood&rdquo;则匹配&ldquo;zood&rdquo;或&ldquo;food&rdquo;。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">[xyz]</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">字符集合。匹配所包含的任意一个字符。例如，&ldquo;[abc]&rdquo;可以匹配&ldquo;plain&rdquo;中的&ldquo;a&rdquo;。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">[^xyz]</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">负值字符集合。匹配未包含的任意字符。例如，&ldquo;[^abc]&rdquo;可以匹配&ldquo;plain&rdquo;中的&ldquo;plin&rdquo;。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">[a-z]</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">字符范围。匹配指定范围内的任意字符。例如，&ldquo;[a-z]&rdquo;可以匹配&ldquo;a&rdquo;到&ldquo;z&rdquo;范围内的任意小写字母字符。</div>
<div class="para">注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">[^a-z]</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">负值字符范围。匹配任何不在指定范围内的任意字符。例如，&ldquo;[^a-z]&rdquo;可以匹配任何不在&ldquo;a&rdquo;到&ldquo;z&rdquo;范围内的任意字符。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">\b</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">匹配一个单词边界，也就是指单词和空格间的位置。例如，&ldquo;er\b&rdquo;可以匹配&ldquo;never&rdquo;中的&ldquo;er&rdquo;，但不能匹配&ldquo;verb&rdquo;中的&ldquo;er&rdquo;。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">\B</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">匹配非单词边界。&ldquo;er\B&rdquo;能匹配&ldquo;verb&rdquo;中的&ldquo;er&rdquo;，但不能匹配&ldquo;never&rdquo;中的&ldquo;er&rdquo;。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">\cx</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的&ldquo;c&rdquo;字符。</div>
</td>
</tr>
<tr>
<td align="left" valign="center" width="75">
<div class="para">\d</div>
</td>
<td align="left" valign="center" width="658">
<div class="para">匹配一个数字字符。等价于[0-9]。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\D</div>
</td>
<td align="left" valign="center">
<div class="para">匹配一个非数字字符。等价于[^0-9]。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\f</div>
</td>
<td align="left" valign="center">
<div class="para">匹配一个换页符。等价于\x0c和\cL。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\n</div>
</td>
<td align="left" valign="center">
<div class="para">匹配一个换行符。等价于\x0a和\cJ。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\r</div>
</td>
<td align="left" valign="center">
<div class="para">匹配一个回车符。等价于\x0d和\cM。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\s</div>
</td>
<td align="left" valign="center">
<div class="para">匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\S</div>
</td>
<td align="left" valign="center">
<div class="para">匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\t</div>
</td>
<td align="left" valign="center">
<div class="para">匹配一个制表符。等价于\x09和\cI。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\v</div>
</td>
<td align="left" valign="center">
<div class="para">匹配一个垂直制表符。等价于\x0b和\cK。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\w</div>
</td>
<td align="left" valign="center">
<div class="para">匹配包括下划线的任何单词字符。等价于&ldquo;[A-Za-z0-9_]&rdquo;。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\W</div>
</td>
<td align="left" valign="center">
<div class="para">匹配任何非单词字符。等价于&ldquo;[^A-Za-z0-9_]&rdquo;。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\xn</div>
</td>
<td align="left" valign="center">
<div class="para">匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，&ldquo;\x41&rdquo;匹配&ldquo;A&rdquo;。&ldquo;\x041&rdquo;则等价于&ldquo;\x04&amp;1&rdquo;。正则表达式中可以使用ASCII编码。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\num</div>
</td>
<td align="left" valign="center">
<div class="para">匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，&ldquo;(.)\1&rdquo;匹配两个连续的相同字符。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\n</div>
</td>
<td align="left" valign="center">
<div class="para">标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\nm</div>
</td>
<td align="left" valign="center">
<div class="para">标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\nml</div>
</td>
<td align="left" valign="center">
<div class="para">如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">
<div class="para">\un</div>
</td>
<td align="left" valign="center">
<div class="para">匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（&amp;copy;）。</div>
</td>
</tr>
<tr>
<td align="left" valign="center">\&lt; \&gt;</td>
<td align="left" valign="center">匹配词（word）的开始（\&lt;）和结束（\&gt;）。例如正则表达式\&lt;the\&gt;能够匹配字符串"for the wise"中的"the"，但是不能匹配字符串"otherwise"中的"the"。注意：这个元字符不是所有的软件都支持的。</td>
</tr>
<tr>
<td align="left" valign="center">\( \)</td>
<td align="left" valign="center">将 \( 和 \) 之间的表达式定义为&ldquo;组&rdquo;（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \1 到\9 的符号来引用。</td>
</tr>
<tr>
<td align="left" valign="center">|</td>
<td align="left" valign="center">将两个匹配条件进行逻辑&ldquo;或&rdquo;（Or）运算。例如正则表达式(him|her) 匹配"it belongs to him"和"it belongs to her"，但是不能匹配"it belongs to them."。注意：这个元字符不是所有的软件都支持的。</td>
</tr>
<tr>
<td align="left" valign="center">+</td>
<td align="left" valign="center">匹配1或多个正好在它之前的那个字符。例如正则表达式9+匹配9、99、999等。注意：这个元字符不是所有的软件都支持的。</td>
</tr>
<tr>
<td align="left" valign="center">?</td>
<td align="left" valign="center">匹配0或1个正好在它之前的那个字符。注意：这个元字符不是所有的软件都支持的。</td>
</tr>
<tr>
<td align="left" valign="center">{i} {i,j}</td>
<td align="left" valign="center">匹配指定数目的字符，这些字符是在它之前的表达式定义的。例如正则表达式A[0-9]{3} 能够匹配字符"A"后面跟着正好3个数字字符的串，例如A123、A348等，但是不匹配A1234。而正则表达式[0-9]{4,6} 匹配连续的任意4个、5个或者6个数字</td>
</tr>
</tbody>
</table>

]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解iOS App的启动过程</title>
    <url>/2018/06/11/iOS/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iOS%20App%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/Hello_Hwc/article/details/78317863?locationNum=9&fps=1">深入理解iOS App的启动过程</a></p>
<h2 id="准备知识-知道概念"><a href="#准备知识-知道概念" class="headerlink" title="准备知识 知道概念"></a>准备知识 知道概念</h2><h3 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h3><p>哪些名词指的是Mach-o ?</p>
<ul>
<li>Executable 可执行文件</li>
<li>Dylib 动态库</li>
<li>Bundle 无法被连接的动态库，只能通过dlopen()加载</li>
<li>Image 指的是Executable，Dylib或者Bundle的一种，文中会多次使用Image这个名词。</li>
<li>Framework 动态库和对应的头文件和资源文件的集合</li>
</ul>
<p>Apple出品的操作系统的可执行文件格式几乎都是mach-o，iOS当然也不例外。<br>mach-o可以大致的分为三部分：</p>
<ul>
<li>Header 头部，包含可以执行的CPU架构，比如x86,arm64</li>
<li>Load commands 加载命令，包含文件的组织架构和在虚拟内存中的布局方式</li>
<li>Data，数据，包含load commands中需要的各个段(segment)的数据，每一个Segment都得大小是Page的整数倍。</li>
</ul>
<p>那么Data部分又包含哪些segment呢？绝大多数mach-o包括以下三个段（支持用户自定义Segment，但是很少使用）</p>
<ul>
<li><code>__TEXT</code> 代码段，只读，包括函数，和只读的字符串，上图中类似<code>__TEXT</code>,__text的都是代码段</li>
<li><code>__DATA </code>数据段，读写，包括可读写的全局变量等，上图类似中的<code>__DATA</code>,<code>__data</code>都是数据段</li>
<li><code>__LINKEDIT</code> <code> __LINKEDIT</code>包含了方法和变量的元数据（位置，偏移量），以及代码签名等信息。</li>
</ul>
<h3 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h3><blockquote>
<p>dyld的全称是dynamic loader，它的作用是加载一个进程所需要的image，dyld是开源的。</p>
</blockquote>
<h3 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h3><blockquote>
<p>虚拟内存是在物理内存上建立的一个逻辑地址空间，它向上（应用）提供了一个连续的逻辑地址空间，向下隐藏了物理内存的细节。<br>虚拟内存使得逻辑地址可以没有实际的物理地址，也可以让多个逻辑地址对应到一个物理地址。<br>虚拟内存被划分为一个个大小相同的Page（64位系统上是16KB），提高管理和读写的效率。 Page又分为只读和读写的Page。</p>
</blockquote>
<p>虚拟内存是建立在物理内存和进程之间的中间层。在iOS上，当内存不足的时候，会尝试释放那些只读的Page，因为只读的Page在下次被访问的时候，可以再从磁盘读取。如果没有可用内存，会通知在后台的App（也就是在这个时候收到了memory warning），如果在这之后仍然没有可用内存，则会杀死在后台的App。</p>
<h3 id="Page-fault"><a href="#Page-fault" class="headerlink" title="Page fault"></a>Page fault</h3><blockquote>
<p>在应用执行的时候，它被分配的逻辑地址空间都是可以访问的，当应用访问一个逻辑Page，而在对应的物理内存中并不存在的时候，这时候就发生了一次Page fault。当Page fault发生的时候，会中断当前的程序，在物理内存中寻找一个可用的Page，然后从磁盘中读取数据到物理内存，接着继续执行当前程序。</p>
</blockquote>
<h3 id="Dirty-Page-amp-Clean-Page"><a href="#Dirty-Page-amp-Clean-Page" class="headerlink" title="Dirty Page &amp; Clean Page"></a>Dirty Page &amp; Clean Page</h3><p>1、如果一个Page可以从磁盘上重新生成，那么这个Page称为Clean Page<br>2、如果一个Page包含了进程相关信息，那么这个Page称为Dirty Page<br>像代码段这种只读的Page就是Clean Page。而像数据段(_DATA)这种读写的Page，当写数据发生的时候，会触发COW(Copy on write)，也就是写时复制，Page会被标记成Dirty，同时会被复制。</p>
<h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p><img src="/images/app_start.jpg"></p>
<h3 id="加载动态库"><a href="#加载动态库" class="headerlink" title="加载动态库"></a>加载动态库</h3><blockquote>
<p>dyld会首先读取mach-o文件的Header和load commands。<br>接着就知道了这个可执行文件依赖的动态库。例如加载动态库A到内存，接着检查A所依赖的动态库，就这样的递归加载，直到所有的动态库加载完毕。通常一个App所依赖的动态库在100-400个左右，其中大多数都是系统的动态库，它们会被缓存到dyld shared cache，这样读取的效率会很高。</p>
</blockquote>
<h3 id="Rebase-amp-amp-Bind"><a href="#Rebase-amp-amp-Bind" class="headerlink" title="Rebase &amp;&amp; Bind"></a>Rebase &amp;&amp; Bind</h3><p>为什么要Rebase？</p>
<p>有两种主要的技术来保证应用的安全：ASLR和Code Sign。</p>
<p>ASLR的全称是Address space layout randomization，翻译过来就是“地址空间布局随机化”。App被启动的时候，程序会被影射到逻辑的地址空间，这个逻辑的地址空间有一个起始地址，而ASLR技术使得这个起始地址是随机的。如果是固定的，那么黑客很容易就可以由起始地址+偏移量找到函数的地址。</p>
<ul>
<li>Rebase 修正内部(指向当前mach-o文件)的指针指向</li>
<li>Bind 修正外部指针指向</li>
</ul>
<h3 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective C"></a>Objective C</h3><p>Objective C是动态语言，所以在执行main函数之前，需要把类的信息注册到一个全局的Table中。同时，Objective C支持Category，在初始化的时候，也会把Category中的方法注册到对应的类中，同时会唯一Selector，这也是为什么当你的Cagegory实现了类中同名的方法后，类中的方法会被覆盖。</p>
<p>另外，由于iOS开发时基于Cocoa Touch的，所以绝大多数的类起始都是系统类，所以大多数的Runtime初始化起始在Rebase和Bind中已经完成。</p>
<h3 id="Initializers"><a href="#Initializers" class="headerlink" title="Initializers"></a>Initializers</h3><p>接下来就是必要的初始化部分了，主要包括几部分：</p>
<p>+load方法。<br>C／C++静态初始化对象和标记为__attribute__(constructor)的方法<br>这里要提一点的就是，+load方法已经被弃用了，如果你用Swift开发，你会发现根本无法去写这样一个方法，官方的建议是实用initialize。区别就是，load是在类装载的时候执行，而initialize是在类第一次收到message前调用。</p>
<h3 id="Main函数之后"><a href="#Main函数之后" class="headerlink" title="Main函数之后"></a>Main函数之后</h3><p>从main函数开始执行，到你的第一个界面显示，这期间一般会做哪些事情。</p>
<ul>
<li>执行AppDelegate的代理方法，主要是didFinishLaunchingWithOptions</li>
<li>初始化Window，初始化基础的ViewController结构(一般是UINavigationController+UITabViewController)</li>
<li>获取数据(Local DB／Network)，展示给用户。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不同的App在启动的时候做的事情往往不同，但是优化起来的核心思想无非就两个：</p>
<p>能延迟执行的就延迟执行。比如SDK的初始化，界面的创建。<br>不能延迟执行的，尽量放到后台执行。比如数据读取，原始JSON数据转对象，日志发送。<br>Main函数之前</p>
<p>Main函数之前是iOS系统的工作，所以这部分的优化往往更具有通用性。</p>
<h3 id="dylibs"><a href="#dylibs" class="headerlink" title="dylibs"></a>dylibs</h3><p>启动的第一步是加载动态库，加载系统的动态库使很快的，因为可以缓存，而加载内嵌的动态库速度较慢。所以，提高这一步的效率的关键是：减少动态库的数量。</p>
<p>合并动态库，比如公司内部由私有Pod建立了如下动态库：XXTableView, XXHUD, XXLabel，强烈建议合并成一个XXUIKit来提高加载速度。</p>
<h3 id="Rebase-amp-Bind-amp-Objective-C-Runtime"><a href="#Rebase-amp-Bind-amp-Objective-C-Runtime" class="headerlink" title="Rebase &amp; Bind &amp; Objective C Runtime"></a>Rebase &amp; Bind &amp; Objective C Runtime</h3><p>Rebase和Bind都是为了解决指针引用的问题。对于Objective C开发来说，主要的时间消耗在Class/Method的符号加载上，所以常见的优化方案是：</p>
<p>减少__DATA段中的指针数量。<br>合并Category和功能类似的类。比如：UIView+Frame,UIView+AutoLayout…合并为一个<br>删除无用的方法和类。<br>多用Swift Structs，因为Swfit Structs是静态分发的。感兴趣的同学可以看看我之前这篇文章：《Swift进阶之内存模型和方法调度》</p>
<h3 id="Initializers-1"><a href="#Initializers-1" class="headerlink" title="Initializers"></a>Initializers</h3><p>通常，我们会在+load方法中进行method-swizzling，这也是Nshipster推荐的方式。</p>
<p>用initialize替代load。不少同学喜欢用method-swizzling来实现AOP去做日志统计等内容，强烈建议改为在initialize进行初始化。<br>减少__atribute__((constructor))的使用，而是在第一次访问的时候才用dispatch_once等方式初始化。<br>不要创建线程<br>使用Swfit重写代码。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>详解KVO底层实现</title>
    <url>/2018/06/11/iOS/%E8%AF%A6%E8%A7%A3KVO%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="一、KVO-Key-Value-Observing"><a href="#一、KVO-Key-Value-Observing" class="headerlink" title="一、KVO (Key-Value Observing)"></a>一、KVO (Key-Value Observing)</h3><p>KVO 是 Objective-C 对观察者模式（Observer Pattern）的实现。也是 Cocoa Binding 的基础。当被观察对象的某个属性发生更改时，观察者对象会获得通知。</p>
<p>有意思的是，你不需要给被观察的对象添加任何额外代码，就能使用 KVO 。这是怎么做到的？</p>
<h3 id="二、-KVO内部实现原理"><a href="#二、-KVO内部实现原理" class="headerlink" title="二、 KVO内部实现原理"></a>二、 KVO内部实现原理</h3><p>KVO是基于runtime机制实现的<br>当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制<br>如果原类为Person，那么生成的派生类名为NSKVONotifying_Person<br>每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法<br>键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。<br>补充：KVO的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类</p>
<h3 id="三、补充：-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？（看链接）"><a href="#三、补充：-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？（看链接）" class="headerlink" title="三、补充： 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？（看链接）"></a>三、补充： 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？（看链接）</h3><p><a href="https://tech.glowing.com/cn/implement-kvo/">如何自己动手实现 KVO</a></p>
<h3 id="四、附注-KVC底层实现原理-如下"><a href="#四、附注-KVC底层实现原理-如下" class="headerlink" title="四、附注: KVC底层实现原理(如下)"></a>四、附注: KVC底层实现原理(如下)</h3><p>KVC运用了一个isa-swizzling技术. isa-swizzling就是类型混合指针机制, 将2个对象的isa指针互相调换, 就是俗称的黑魔法.<br>KVC主要通过isa-swizzling, 来实现其内部查找定位的. 默认的实现方法�由NSOject提供isa指针, 如其名称所指,(就是is a kind of的意思), 指向分发表对象的类. 该分发表实际上包含了指向实现类中的方法的指针, 和其它数据。</p>
<p>具体主要分为三大步<br>第一步：寻找该属性有没有setsetter方法？有，就直接赋值<br>第二步：寻找有没有该属性带下划线的成员属性？有，就直接赋值<br>第三步：寻找有没有该属性的成员属性？有，就直接赋值<br>或者这么说<br>1、首先搜索setKey:方法.(key指成员变量名, 首字母大写)<br>2、上面的setter方法没找到, 如果类方法accessInstanceVariablesDirectly返回YES. 那么按 _key, _isKey，key, iskey的顺序搜索成员名.(NSKeyValueCodingCatogery中实现的类方法, 默认实现为返回YES)<br>3、如果没有找到成员变量, 调用setValue:forUnderfinedKey:<br>比如说如下的一行KVC的代码：</p>
<p>举个🌰e.g:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[object setValue:<span class="string">@&quot;13123&quot;</span> forKey:<span class="string">@&quot;uuid&quot;</span>];</span><br><span class="line"> </span><br><span class="line">就会被编译器处理成:</span><br><span class="line"><span class="comment">// 首先找到对应sel</span></span><br><span class="line">SEL sel = sel_get_ uuid(<span class="string">&quot;setValue:forKey:&quot;</span>);</span><br><span class="line"><span class="comment">// 根据object-&gt;isa找到sel对应的IMP实现指针</span></span><br><span class="line">IMP method = objc_msg_lookup (object-&gt;isa,sel);</span><br><span class="line"><span class="comment">// 调用指针完成KVC赋值</span></span><br><span class="line">method(object, sel, <span class="string">@&quot;13123&quot;</span>, <span class="string">@&quot;uuid&quot;</span>);</span><br></pre></td></tr></table></figure>


<h3 id="如何为一个实例动态替换方法"><a href="#如何为一个实例动态替换方法" class="headerlink" title="如何为一个实例动态替换方法"></a>如何为一个实例动态替换方法</h3><p><a href="http://ios.jobbole.com/93080/">资料</a><br>根据kvo的实现原理：派生个实例方法所在类的子类，创建hook函数，然后修改isa指针<code>object_setClass(instance, newClass);</code>，实现替换的方法实现。</p>
<p><a href="https://www.cnblogs.com/oc-bowen/p/5884768.html">详解KVO底层实现</a><br><a href="https://coding.net/u/dream001/p/CustomKVO/git/tree/master">代码实现仓库地址</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS面试题库</title>
    <url>/2018/06/11/iOS/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="简单的做下自我介绍"><a href="#简单的做下自我介绍" class="headerlink" title="简单的做下自我介绍"></a>简单的做下自我介绍</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关注点：考察下介绍和简历是否一致，现场的把控和语言表达能力。</span><br></pre></td></tr></table></figure>
<h2 id="控制器的生命周期"><a href="#控制器的生命周期" class="headerlink" title="控制器的生命周期"></a>控制器的生命周期</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">1、 alloc                                   创建对象，分配空间</span><br><span class="line">2、init (initWithNibName) 初始化对象，初始化数据</span><br><span class="line">3、loadView                          从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图</span><br><span class="line">4、viewDidLoad                   载入完成，可以进行自定义数据以及动态创建其他控件</span><br><span class="line">5、viewWillAppear              视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了</span><br><span class="line">6、viewDidAppear               视图已在屏幕上渲染完成</span><br><span class="line">7、dealloc 销毁 （通过该方法内还可以检测什么？ 答案：返回后看时候回调该函数 来判断是否有内存泄露）</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">要求：对生命周期要熟悉精通，中间可以根据情况自己把握 讨论具体某个函数</span><br></pre></td></tr></table></figure>
<h2 id="如何使UILabel显示多行？"><a href="#如何使UILabel显示多行？" class="headerlink" title="如何使UILabel显示多行？"></a>如何使UILabel显示多行？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：numberOfLines = 0</span><br></pre></td></tr></table></figure>
<h2 id="frame和bounds有什么不同？"><a href="#frame和bounds有什么不同？" class="headerlink" title="frame和bounds有什么不同？"></a>frame和bounds有什么不同？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：相对父 与 自身</span><br></pre></td></tr></table></figure>
<h2 id="assign、retain、copy、strong、weak什么时候用？区别？"><a href="#assign、retain、copy、strong、weak什么时候用？区别？" class="headerlink" title="assign、retain、copy、strong、weak什么时候用？区别？"></a>assign、retain、copy、strong、weak什么时候用？区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">assign 基本数据类型与代理使用</span><br><span class="line">retain 引用计数在用来的基础上加1</span><br><span class="line">copy 开辟个新的内存空间</span><br><span class="line">strong 相当于老版本的retain,而且可以不再需要做release操作了</span><br><span class="line">weak 相当于老版本的assign。但是只适应于对象</span><br></pre></td></tr></table></figure>
<h2 id="imageName与imageContentOfFile的区别"><a href="#imageName与imageContentOfFile的区别" class="headerlink" title="imageName与imageContentOfFile的区别"></a>imageName与imageContentOfFile的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">后者没有缓存 适用于只需要一次使用  减少对系统内存的耗用情况</span><br></pre></td></tr></table></figure>
<h2 id="对于单元格重用的理解？"><a href="#对于单元格重用的理解？" class="headerlink" title="对于单元格重用的理解？"></a>对于单元格重用的理解？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">1、当屏幕上滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用。</span><br><span class="line">2、当有新单元从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，</span><br><span class="line">若有，就直接用，没有就重新创建一个。</span><br></pre></td></tr></table></figure>
<h2 id="Category的优缺点"><a href="#Category的优缺点" class="headerlink" title="Category的优缺点"></a>Category的优缺点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">优点：可以不创建子类的前提下扩展方法、可以对比较胖的类进行拆分。</span><br><span class="line">缺点：如果和类的方法起的重名会覆盖类中的方法、不能添加实例变量。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Delegate、Notification、Block区别与使用场景"><a href="#Delegate、Notification、Block区别与使用场景" class="headerlink" title="Delegate、Notification、Block区别与使用场景"></a>Delegate、Notification、Block区别与使用场景</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">Delegate是一对一的回调机制</span><br><span class="line">Notification是一对多的对所有添加观察者的通知</span><br><span class="line">Block代码比较简洁不需要像代理一样定义协议方法</span><br></pre></td></tr></table></figure>

<p>delegate针对one-to-one关系，并且reciever可以返回值给sender，notification 可以针对one-to-one/many/none,reciever无法返回值给sender.所以，delegate用于sender希望接受到reciever的某个功能反馈值，notification用于通知多个object某个事件。</p>
<h2 id="GCD中队列都是哪几种？"><a href="#GCD中队列都是哪几种？" class="headerlink" title="GCD中队列都是哪几种？"></a>GCD中队列都是哪几种？</h2><p>参考答案：以下四种队列</p>
<table>
<thead>
<tr>
<th>串行队列</th>
<th>并行队列</th>
<th>全局队列</th>
<th>主队列</th>
</tr>
</thead>
<tbody><tr>
<td>DISPATCH_QUEUE_SERIAL</td>
<td>DISPATCH_QUEUE_CONCURRENT</td>
<td>dispatch_get_global_queue</td>
<td>dispatch_get_main_queue</td>
</tr>
<tr>
<td>队列中的任务只会顺序执行</td>
<td>队列中的任务通常会并发执行</td>
<td>是系统的</td>
<td>在多线程开发中，使用主队列更新UI</td>
</tr>
</tbody></table>
<h2 id="有A、B-2个异步请求，如何判断A、B都完成执行？如果需要A、B顺序执行，该如何实现？"><a href="#有A、B-2个异步请求，如何判断A、B都完成执行？如果需要A、B顺序执行，该如何实现？" class="headerlink" title="有A、B 2个异步请求，如何判断A、B都完成执行？如果需要A、B顺序执行，该如何实现？"></a>有A、B 2个异步请求，如何判断A、B都完成执行？如果需要A、B顺序执行，该如何实现？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：能说出group和group_notify即可</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_group_async(group, queue, ^&#123; /*任务A */ &#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123; /*任务B */ &#125;);</span><br><span class="line">dispatch_group_notify(group,dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> // 在A、B异步执行完成后，会回调这里</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">第二问：能说出把用串行队列即可</span><br></pre></td></tr></table></figure>
<h2 id="自动布局之autoresizingMask-UIViewAutoresizingFlexibleWidth-UIViewAutoresizingFlexibleBottomMargin含义和内部原理是怎么样的？"><a href="#自动布局之autoresizingMask-UIViewAutoresizingFlexibleWidth-UIViewAutoresizingFlexibleBottomMargin含义和内部原理是怎么样的？" class="headerlink" title="自动布局之autoresizingMask UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleBottomMargin含义和内部原理是怎么样的？"></a>自动布局之autoresizingMask UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleBottomMargin含义和内部原理是怎么样的？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">知道这段代码的表面含义：左右间距不变自动调整宽度 和 顶部间距不变</span><br><span class="line">其次知道枚举的状态和选项模式 </span><br><span class="line">外部通过按位或 </span><br><span class="line">内部实现是通过位与操作运算实现的（可要求拿笔书写大致内部实现代码流程）</span><br></pre></td></tr></table></figure>
<h2 id="什么是-RunLoop？"><a href="#什么是-RunLoop？" class="headerlink" title="什么是 RunLoop？"></a>什么是 RunLoop？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">从字面上讲就是运行循环，它内部就是do-while循环，在这个循环内部不断地处理各种任务。</span><br><span class="line">一个线程对应一个RunLoop，基本作用就是保持程序的持续运行，处理app中的各种事件。通过runloop，有事运行，没事就休息，可以节省cpu资源，提高程序性能。</span><br><span class="line"></span><br><span class="line">主线程的run loop默认是启动的。iOS的应用程序里面，程序启动后会有一个如下的main()函数</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">	@autoreleasepool &#123;</span><br><span class="line">    	return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后顺势承接下一题</span><br></pre></td></tr></table></figure>
<h2 id="滑动tableview的时候-定时器不执行的原因？解决办法？"><a href="#滑动tableview的时候-定时器不执行的原因？解决办法？" class="headerlink" title="滑动tableview的时候 定时器不执行的原因？解决办法？"></a>滑动tableview的时候 定时器不执行的原因？解决办法？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">和上一题做承接</span><br><span class="line">参考答案：</span><br><span class="line">首先：将NSTimer添加到主线程NSRunLoop的默认模式下，只有主线程是默认模式下才能执行NSTimer</span><br><span class="line">（滚动scrollView，RunLoop默认进入Tracking模式，所以NSTimer不会有效果）。</span><br><span class="line">其次：只要将 timer 添加到 Common 占位模式下，timer就可以在Default和UITrackingRunLoopMode模式下都能运行（Common是一个表示，它是将NSDefaultRunLoopMode 和 UITrackingRunLoopMode标记为了Common）</span><br></pre></td></tr></table></figure>
<h2 id="哪些情况下会造成内存泄露？"><a href="#哪些情况下会造成内存泄露？" class="headerlink" title="哪些情况下会造成内存泄露？"></a>哪些情况下会造成内存泄露？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">A、B对象进行强引用、代理强引用、block循环引用、timer、N次循环造成的内存上涨(autoReleasePool添加) 、用到Core Foundation对象（CFRelease）等。</span><br></pre></td></tr></table></figure>
<h2 id="Runtime实现的机制是什么，一般用于什么场景？"><a href="#Runtime实现的机制是什么，一般用于什么场景？" class="headerlink" title="Runtime实现的机制是什么，一般用于什么场景？"></a>Runtime实现的机制是什么，一般用于什么场景？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">1). 使用时需要导入的头文件 &lt;objc/message.h&gt; &lt;objc/runtime.h&gt;</span><br><span class="line">2). Runtime 运行时机制，它是一套C语言库。</span><br><span class="line">3). 实际上我们编写的所有OC代码，最终都是转成了runtime库的东西。</span><br><span class="line"></span><br><span class="line">应用场景：</span><br><span class="line">    （1）获取类里面的所有成员变量。</span><br><span class="line">    （2）为类动态添加成员变量。</span><br><span class="line">    （3）动态改变类的方法实现。</span><br><span class="line">    （4）为类动态添加新的方法等。</span><br><span class="line">用于模型抽象</span><br></pre></td></tr></table></figure>
<h2 id="什么是-Method-Swizzle？"><a href="#什么是-Method-Swizzle？" class="headerlink" title="什么是 Method Swizzle？"></a>什么是 Method Swizzle？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">1). 在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法 Method Swizzle。</span><br><span class="line">2). Method Swizzle 指的是改变一个已存在的选择器对应的实现的过程。OC中方法的调用能够在运行时通过改变，通过改变类的调度表中选择器到最终函数间的映射关系。</span><br><span class="line">3). 在OC中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用OC的动态特性，可以实现在运行时偷换selector对应的方法实现。</span><br><span class="line">4). 每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的方法实现。</span><br><span class="line">5). 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP。</span><br><span class="line">6). 我们可以利用 class_replaceMethod 来修改类。</span><br><span class="line">7). 我们可以利用 method_setImplementation 来直接设置某个方法的IMP。</span><br><span class="line">8). 归根结底，都是偷换了selector的IMP。</span><br></pre></td></tr></table></figure>
<h2 id="通过简历中开发过的项目，了解下项目分工和面试者负责的模块，怎么进行开发、维护的？"><a href="#通过简历中开发过的项目，了解下项目分工和面试者负责的模块，怎么进行开发、维护的？" class="headerlink" title="通过简历中开发过的项目，了解下项目分工和面试者负责的模块，怎么进行开发、维护的？"></a>通过简历中开发过的项目，了解下项目分工和面试者负责的模块，怎么进行开发、维护的？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：对负责的模块应该有清晰的思路</span><br></pre></td></tr></table></figure>
<h2 id="在iOS中业务模块的编程风格是怎样的？"><a href="#在iOS中业务模块的编程风格是怎样的？" class="headerlink" title="在iOS中业务模块的编程风格是怎样的？"></a>在iOS中业务模块的编程风格是怎样的？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">MVC、业务逻辑与用户界面分离、代码按区区域划分、多用组合、</span><br><span class="line">用类别防止类过胖保持易维护易扩展等等</span><br><span class="line">（只要编程习惯保证代码的简洁性、可阅读下皆可）  良好的编程风格可减少内存泄露和其它bug的出现。</span><br></pre></td></tr></table></figure>
<h2 id="最近在技术方面最有成就感的事？或者说最有成就感的项目是哪个？"><a href="#最近在技术方面最有成就感的事？或者说最有成就感的项目是哪个？" class="headerlink" title="最近在技术方面最有成就感的事？或者说最有成就感的项目是哪个？"></a>最近在技术方面最有成就感的事？或者说最有成就感的项目是哪个？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">一般为攻破了某个技术难题。可以针对面试者开发的项目 多聊聊 了解下面试者的思路。</span><br></pre></td></tr></table></figure>
<h2 id="上面的技术难题怎么攻破的？"><a href="#上面的技术难题怎么攻破的？" class="headerlink" title="上面的技术难题怎么攻破的？"></a>上面的技术难题怎么攻破的？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">了解该面试者解决问题的方式、渠道。</span><br></pre></td></tr></table></figure>
<h2 id="未来几年的职业规划？"><a href="#未来几年的职业规划？" class="headerlink" title="未来几年的职业规划？"></a>未来几年的职业规划？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">暂无具体  （多聊聊 感受下性格以及与人相处，</span><br><span class="line">至于职业规划只要符合部门的需要即可）</span><br></pre></td></tr></table></figure>
<h2 id="问下面试者他想了解哪些？"><a href="#问下面试者他想了解哪些？" class="headerlink" title="问下面试者他想了解哪些？"></a>问下面试者他想了解哪些？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目的：了解下面试者的诉求、看他对公司是否有兴趣、看性格和表达能力</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS基础必学列表</title>
    <url>/2021/12/06/%E5%89%8D%E7%AB%AF/CSS/</url>
    <content><![CDATA[<h4 id="CSS基础必学列表"><a href="#CSS基础必学列表" class="headerlink" title="CSS基础必学列表"></a>CSS基础必学列表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSS width宽度</span><br><span class="line">CSS height高度</span><br><span class="line">CSS border边框</span><br><span class="line">CSS background背景</span><br><span class="line">CSS sprites背景拼合</span><br><span class="line">CSS float浮动</span><br><span class="line">CSS margin外边距</span><br><span class="line">CSS padding内边距</span><br><span class="line">CSS color字体颜色</span><br><span class="line">CSS font-size字体大小</span><br><span class="line">CSS font-family字体</span><br><span class="line">CSS font-weight字体加粗</span><br><span class="line">CSS display显示与隐藏</span><br><span class="line">CSS overflow隐藏与滚动条</span><br><span class="line">CSS position定位</span><br><span class="line">CSS text-align内容水平位置</span><br><span class="line">CSS text-indent缩进</span><br><span class="line">CSS text-decoration下划线</span><br><span class="line">CSS clear清除浮动</span><br><span class="line">CSS cursor鼠标手势光标</span><br><span class="line">CSS font文本</span><br><span class="line">CSS font-style文本斜体</span><br><span class="line">CSS font-variant缩小大写字母</span><br><span class="line">CSS id CSS class</span><br><span class="line">left right top bottom</span><br><span class="line">css letter-spacing字间距</span><br><span class="line">CSS line-height行高</span><br><span class="line">css min-width最小宽度</span><br><span class="line">css max-width最大宽度</span><br><span class="line">CSS min-height最小高度</span><br><span class="line">css max-height最大高度</span><br><span class="line">CSS text-transform英文大小写</span><br><span class="line">css text-overflow省略号</span><br><span class="line">CSS white-space不换行</span><br><span class="line">css z-index重叠顺序</span><br><span class="line">CSS 前花括号星号*</span><br><span class="line">CSS 缩写</span><br><span class="line">div与span区别及用法</span><br><span class="line">CSS是什么</span><br><span class="line">DIV+CSS是什么</span><br><span class="line">CSS 注释</span><br><span class="line">CSS 指针</span><br><span class="line">CSS 文本排版</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li><code>DIV CSS left right top bottom</code>定位<br>这四个CSS属性样式用于定位对象盒子，必须定义<code>position</code>属性值为<code>absolute</code>或者<code>relative</code>此取值方可生效。</li>
</ul>
<p><a href="http://www.divcss5.com/rumen/r119.shtml">DIVCSS5</a>  </p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6</title>
    <url>/2021/12/06/%E5%89%8D%E7%AB%AF/ES6/</url>
    <content><![CDATA[<h4 id="ECMAScript-6-入门"><a href="#ECMAScript-6-入门" class="headerlink" title="ECMAScript 6 入门"></a>ECMAScript 6 入门</h4><ul>
<li>ECMAScript 6简介</li>
<li>let 和 const 命令</li>
<li>变量的解构赋值</li>
<li>字符串的扩展</li>
<li>正则的扩展</li>
<li>数值的扩展</li>
<li>函数的扩展</li>
<li>数组的扩展</li>
<li>对象的扩展</li>
<li>对象的新增方法</li>
<li>Symbol</li>
<li>Set 和 Map 数据结构</li>
<li>Proxy</li>
<li>Reflect</li>
<li>Promise 对象</li>
<li>Iterator 和 for…of 循环</li>
<li>Generator 函数的语法</li>
<li>Generator 函数的异步应用</li>
<li>async 函数</li>
<li>Class 的基本语法</li>
<li>Class 的继承</li>
<li>Decorator</li>
<li>Module 的语法</li>
<li>Module 的加载实现</li>
</ul>
<p><a href="http://es6.ruanyifeng.com/">ECMAScript 6 入门</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ESLint安装使用流程</title>
    <url>/2018/06/14/%E5%89%8D%E7%AB%AF/ESLint%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>ESLint安装使用流程</p>
<h1 id="京东通天塔项目安装使用流程"><a href="#京东通天塔项目安装使用流程" class="headerlink" title="京东通天塔项目安装使用流程"></a>京东通天塔项目安装使用流程</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 京东通天塔项目已经添加了相关的配置只需要做以下操作即可使用：</span><br><span class="line">1. npm run install_eslint_packages     安装相关依赖包</span><br><span class="line">2. IDE配置：</span><br><span class="line">  http://139.199.180.74/showdoc/Public/Uploads/2017-12-12/5a2f4a15bfbcd.jpeg</span><br><span class="line">3.输出使用 详见最底部 `ESLint输出报告方式`</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="新项目安装使用流程"><a href="#新项目安装使用流程" class="headerlink" title="新项目安装使用流程"></a>新项目安装使用流程</h1><h2 id="ESLint流程梳理"><a href="#ESLint流程梳理" class="headerlink" title="ESLint流程梳理"></a>ESLint流程梳理</h2><h3 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a>一、背景介绍</h3><h5 id="ESLint是一个用来识别-ECMAScript-并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。ESLint被设计为完全可配置的，主要有两种方式来配置ESLint："><a href="#ESLint是一个用来识别-ECMAScript-并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。ESLint被设计为完全可配置的，主要有两种方式来配置ESLint：" class="headerlink" title="ESLint是一个用来识别 ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。ESLint被设计为完全可配置的，主要有两种方式来配置ESLint："></a>ESLint是一个用来识别 ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。ESLint被设计为完全可配置的，主要有两种方式来配置ESLint：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在注释中配置：使用JavaScript注释直接把配置嵌入到JS文件中。</span><br><span class="line">配置文件：使用下面任一的文件来为全部的目录和它的子目录指定配置信息。</span><br><span class="line">javascript：使用.eslintrc.js文件并导出一个包含配置的对象。</span><br><span class="line">YAML：.eslintrc.yaml或者.eslintrc.yml</span><br><span class="line">JSON：.eslintrc.json，并且此文件允许使用JS形式的注释</span><br><span class="line">废弃的用法：.eslintrc，此文件可以是JSON或者YAML</span><br><span class="line">package.json：在package.json文件中创建eslintConfig属性，所有的配置包含在此属性中。</span><br><span class="line">这些文件的优先级则是按照以上出现的顺序</span><br><span class="line">（.eslintrc.js &gt; .eslintrc.yaml &gt; .eslintrc.yml &gt; .eslintrc.json &gt; .eslintrc &gt; package.json）。</span><br><span class="line"></span><br><span class="line">三种方法可以配置ESLint</span><br><span class="line">    &gt; 使用.eslintrc.*文件（ 支持JSON和YAML两种语法）</span><br><span class="line">    &gt; 在package.json中添加eslintConfig配置块</span><br><span class="line">    &gt; 使用JavaScript注释直接把配置嵌入到文件中</span><br><span class="line"></span><br><span class="line">可以被配置的信息主要分为3类：</span><br><span class="line"></span><br><span class="line">Environments：你的 javascript 脚步将要运行在什么环境（如：nodejs，browser，commonjs等）中。</span><br><span class="line">Globals：执行代码时脚步需要访问的额外全局变量。</span><br><span class="line">Rules：开启某些规则，也可以设置规则的等级。 </span><br></pre></td></tr></table></figure>


<h3 id="二、作用"><a href="#二、作用" class="headerlink" title="二、作用"></a>二、作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EsLint提供以下几种校验：</span><br><span class="line"></span><br><span class="line">语法错误校验</span><br><span class="line">不重要或丢失的标点符号，如分号</span><br><span class="line">没法运行到的代码块（使用过WebStorm的童鞋应该了解）</span><br><span class="line">未被使用的参数提醒</span><br><span class="line">漏掉的结束符，如&#125;</span><br><span class="line">确保样式的统一规则，如sass或者less</span><br><span class="line">检查变量的命名</span><br></pre></td></tr></table></figure>

<h3 id="三、安装"><a href="#三、安装" class="headerlink" title="三、安装"></a>三、安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装</span><br><span class="line"></span><br><span class="line">全局安装</span><br><span class="line">npm i -g eslint</span><br><span class="line">局部安装（推荐）</span><br><span class="line">npm i -D eslint</span><br><span class="line">安装完毕后，接下来新建一个配置文件.eslintrc.js，</span><br><span class="line">或者使用如下的命令行来自动生成。</span><br><span class="line"></span><br><span class="line">eslint --init</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h3><h5 id="指定执行环境"><a href="#指定执行环境" class="headerlink" title="指定执行环境"></a>指定执行环境</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JavaScript 代码可以运行在浏览器或 nodejs 等环境中，</span><br><span class="line">每个环境的全局变量都不尽相同（如 nodejs 中没有 DOM 相关的全局变量）。</span><br><span class="line">在配置文件中可以自由的指定执行环境。</span><br><span class="line"></span><br><span class="line">// .eslintrc.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: true,</span><br><span class="line">    node: true,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">https://eslint.org/docs/user-guide/configuring#specifying-environments</span><br></pre></td></tr></table></figure>
<h5 id="指定全局变量"><a href="#指定全局变量" class="headerlink" title="指定全局变量"></a>指定全局变量</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以在配置文件或注释中指定额外的全局变量，false表明变量只读：</span><br><span class="line"></span><br><span class="line">使用注释来配置：</span><br><span class="line">/* global var1, var2 */</span><br><span class="line">/* global var1:false, var2:false */</span><br><span class="line">使用配置文件来配置：</span><br><span class="line">// .eslintrc.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  globals: &#123;</span><br><span class="line">    var1: true,</span><br><span class="line">    var2: true,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="配置Rules"><a href="#配置Rules" class="headerlink" title="配置Rules"></a>配置Rules</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在配置文件中可以设置一些规则。</span><br><span class="line"></span><br><span class="line">这些规则的等级有三种：</span><br><span class="line"></span><br><span class="line">&quot;off&quot; 或者 0：关闭规则。</span><br><span class="line">&quot;warn&quot; 或者 1：打开规则，并且作为一个警告（不影响exit code）。</span><br><span class="line">&quot;error&quot; 或者 2：打开规则，并且作为一个错误（exit code将会是1）。</span><br><span class="line"></span><br><span class="line">默认校验的地址http://eslint.org/docs/rules/</span><br></pre></td></tr></table></figure>


<h3 id="五、使用方法"><a href="#五、使用方法" class="headerlink" title="五、使用方法"></a>五、使用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过命令行工具来使用 eslint 。</span><br><span class="line">1、列出所有文件命令 eslint .</span><br><span class="line">2、列出具体某个文件</span><br><span class="line">eslint [options] file.js [file.js] [dir]</span><br></pre></td></tr></table></figure>
<h3 id="六、自动修复"><a href="#六、自动修复" class="headerlink" title="六、自动修复"></a>六、自动修复</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eslint --fix [dir]</span><br></pre></td></tr></table></figure>

<h3 id="七、相关插件使用"><a href="#七、相关插件使用" class="headerlink" title="七、相关插件使用"></a>七、相关插件使用</h3><h5 id="ESLint输出报告方式"><a href="#ESLint输出报告方式" class="headerlink" title="ESLint输出报告方式"></a>ESLint输出报告方式</h5><p>一、终端直接输出方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eslint .</span><br></pre></td></tr></table></figure>

<p>二、md格式：(到eslint_report目录下查看md格式文件)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eslint run eslint_makdown </span><br></pre></td></tr></table></figure>

<p>三、html格式：（到eslint_report目录下查看html格式文件）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eslint run eslint_html</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex布局</title>
    <url>/2021/12/06/%E5%89%8D%E7%AB%AF/Flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h4 id="Flex布局是什么？"><a href="#Flex布局是什么？" class="headerlink" title="Flex布局是什么？"></a>Flex布局是什么？</h4><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br><img src="http://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png"></p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br><strong>项目默认沿主轴排列</strong>。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
<h4 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h4><p>以下6个属性设置在容器上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex-direction</span><br><span class="line">flex-wrap</span><br><span class="line">flex-flow</span><br><span class="line">justify-content</span><br><span class="line">align-items</span><br><span class="line">align-content</span><br></pre></td></tr></table></figure>

<h5 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h5><p>flex-direction属性决定主轴的方向（即项目的排列方向）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.runoob.com/wp-content/uploads/2015/07/0cbe5f8268121114e87d0546e53cda6e.png"></p>
<p>它可能有4个值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">row（默认值）：主轴为水平方向，起点在左端。</span><br><span class="line">row-reverse：主轴为水平方向，起点在右端。</span><br><span class="line">column：主轴为垂直方向，起点在上沿。</span><br><span class="line">column-reverse：主轴为垂直方向，起点在下沿。</span><br></pre></td></tr></table></figure>
<h5 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h5><p>justify-content属性定义了项目在主轴上的对齐方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.runoob.com/wp-content/uploads/2015/07/c55dfe8e3422458b50e985552ef13ba5.png"></p>
<p>5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex-start（默认值）：左对齐</span><br><span class="line">flex-end：右对齐</span><br><span class="line">center： 居中</span><br><span class="line">space-between：两端对齐，项目之间的间隔都相等。</span><br><span class="line">space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br></pre></td></tr></table></figure>

<h5 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h5><p>align-items属性定义项目在交叉轴上如何对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.runoob.com/wp-content/uploads/2015/07/2b0c39c7e7a80d5a784c8c2ca63cde17.png"></p>
<p>取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex-start：交叉轴的起点对齐。</span><br><span class="line">flex-end：交叉轴的终点对齐。</span><br><span class="line">center：交叉轴的中点对齐。</span><br><span class="line">baseline: 项目的第一行文字的基线对齐。</span><br><span class="line">stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</span><br></pre></td></tr></table></figure>

<p><a href="http://www.runoob.com/w3cnote/flex-grammar.html">Flex布局出处</a><br><a href="https://www.w3cplus.com/css3/flexbox-basics.html">Flexbox——快速布局神器</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Flex布局</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC，MVP 和 MVVM</title>
    <url>/2018/06/11/%E5%89%8D%E7%AB%AF/MVC%EF%BC%8CMVP%20%E5%92%8C%20MVVM%20/</url>
    <content><![CDATA[<p>复杂的软件必须有清晰合理的架构，否则无法开发和维护。<br>MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的 MVP 和 MVVM 架构的区别就不容易了。<br>昨天晚上，我读了《Scaling Isomorphic Javascript Code》，突然意识到，它们的区别非常简单。我用几段话，就可以说清。</p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC模式的意思是，软件可以分成三个部分。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020104.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 视图（View）：用户界面。</span><br><span class="line">* 控制器（Controller）：业务逻辑</span><br><span class="line">* 模型（Model）：数据保存</span><br></pre></td></tr></table></figure>
<p>各部分之间的通信方式如下。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020105.png"></p>
<ol>
<li>View 传送指令到 Controller</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>Model 将新的数据发送到 View，用户得到反馈<br>所有通信都是单向的。<h2 id="互动模式"><a href="#互动模式" class="headerlink" title="互动模式"></a>互动模式</h2></li>
</ol>
<p>接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020106.png"></p>
<p>另一种是直接通过controller接受指令。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020107.png"></p>
<h2 id="实例：Backbone"><a href="#实例：Backbone" class="headerlink" title="实例：Backbone"></a>实例：Backbone</h2><p>实际项目往往采用更灵活的方式，以 Backbone.js 为例。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020108.png"></p>
<ol>
<li>用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。</li>
<li>用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。</li>
<li>Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2></li>
</ol>
<p>MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020109.png"></p>
<ol>
<li>各部分之间的通信，都是双向的。</li>
<li>View 与 Model 不发生联系，都通过 Presenter 传递。</li>
<li>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2></li>
</ol>
<p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020110.png"></p>
<p>唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。<a href="https://angularjs.org/">Angular</a> 和 <a href="http://emberjs.com/">Ember</a> 都采用这种模式。<br><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">来自</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>MVC，MVP 和 MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title>RN原理解析</title>
    <url>/2018/06/15/%E5%89%8D%E7%AB%AF/RN%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="react-amp-reactnative-图"><a href="#react-amp-reactnative-图" class="headerlink" title="react &amp; reactnative 图"></a>react &amp; reactnative 图</h3><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1534829808989&di=15083e538967408b39c1a62b911d322d&imgtype=jpg&src=http://img2.imgtn.bdimg.com/it/u=349030452,2123440704&fm=214&gp=0.jpg" alt="img"></p>
<p><a href="https://github.com/guoxiaoxing/react-native/blob/master/doc/ReactNative%E6%BA%90%E7%A0%81%E7%AF%87/1ReactNative%E6%BA%90%E7%A0%81%E7%AF%87%EF%BC%9A%E6%BA%90%E7%A0%81%E5%88%9D%E8%AF%86.md">android 原理分解链接</a></p>
<p><strong>iOS 平台为例，剖析一下 React Native 的原理</strong></p>
<h3 id="基本原理概述"><a href="#基本原理概述" class="headerlink" title="基本原理概述"></a>基本原理概述</h3><ul>
<li>React Native 能够运行起来，全靠 Objective-C 和 JavaScript 的交互。</li>
<li>C 系列的语言，经过编译，链接等操作后，会得到一个二进制格式的可执行文，所谓的运行程序，其实是运行这个二进制程序。</li>
<li> JavaScript 是一种脚本语言，它不会经过编译、链接等操作，而是在运行时 才动态的进行词法、语法分析，生成抽象语法树(AST)和字节码，然后由解释器负责执行或者使用 JIT 将字节码转化为机器码再执行。整个流程由 JavaScript 引擎负责完成。</li>
<li> 苹果提供了一个叫做 JavaScript Core 的框架，这是一个 JavaScript 引擎。iOS7中加入了JavaScriptCore.framework框架。把 WebKit 的 JavaScript 引擎用 Objective-C 封装。该框架让Objective-C和JavaScript代码直接的交互变得更加的简单方便。（注：JSCore，即JavaScriptCore，JS解析的核心部分，IOS使用的是内置的JavaScriptCore，Androis上使用的是  <a href="https://webkit.org/%E5%AE%B6%E7%9A%84jsc.so%E3%80%82%EF%BC%89">https://webkit.org/家的jsc.so。）</a><br><a href="https://blog.csdn.net/guojiezhi/article/details/51839088">JavaScriptCore和Objective-C 交互</a></li>
<li> JavaScript 是一种单线程的语言，它不具备自运行的能力，因此总是被动调用。很多介绍 React Native 的文章都会提到 “JavaScript 线程” 的概念，实际上，它表示的是 Objective-C 创建了一个单独的线程，这个线程只用于执行 JavaScript 代码，而且 JavaScript 代码只会在这个线程中执行。</li>
</ul>
<h3 id="Objective-C-与-JavaScript-交互"><a href="#Objective-C-与-JavaScript-交互" class="headerlink" title="Objective-C 与 JavaScript 交互"></a>Objective-C 与 JavaScript 交互</h3><p>obj-c 与 js调用关系图<br><img src="https://upload-images.jianshu.io/upload_images/6039087-13814ffff21ce4eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="obj-c 与 js调用关系图"></p>
<p><img src="http://blog.cnbang.net/wp-content/uploads/2015/03/ReactNative2.png"></p>
<p>交互流程</p>
<p>在 React Native 中，Objective-C 和 JavaScript 的交互都是通过传递 ModuleId、MethodId 和 Arguments 进行的。Objective-C 和 JavaScript 两端都保存了一份配置表，里面标记了所有 Objective-C 暴露给 JavaScript 的模块和方法。这样，无论是哪一方调用另一方的方法，实际上传递的数据只有 ModuleId、MethodId 和 Arguments 这三个元素，它们分别表示类、方法和方法参数，当 Objective-C 接收到这三个值后，就可以通过 runtime 唯一确定要调用的是哪个函数，然后调用这个函数。Objective-C 和 JavaScript 的交互总是由Objective-C发起的。Object-C与js的交互是通过各端的Bridge和ModuleConfig来进行的，实际过程可分为两个阶段：<strong>初始化阶段</strong>和<strong>方法调用阶段</strong>。</p>
<p><strong>初始化 React Native</strong></p>
<p>在RN（ios）项目中都会有 AppDelegate.m 这个文件，文件有如下代码：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6039087-04c818b174ee5617.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/638"></p>
<p>用户能看到的一切内容都来源于这个 RootView，所有的初始化工作也都在这个方法内完成。在这个方法内部，在创建 RootView 之前，React Native 实际上先创建了一个 Bridge 对象。它是 Objective-C 与 JavaScript 交互的桥梁，后续的方法交互完全依赖于它，而整个初始化过程的最终目的其实也就是创建这个桥梁对象。</p>
<p>初始化方法的核心是 setUp 方法，而 setUp 方法的主要任务则是创建 BatchedBridge。BatchedBridge 的作用是批量读取 JavaScript 对 Objective-C 的方法调用，同时它内部持有一个 JavaScriptExecutor，顾名思义，这个对象用来执行 JavaScript 代码。创建 BatchedBridge 的关键是 start 方法，它可以分为五个步骤：</p>
<p>1.读取 JavaScript 源码</p>
<p>JavaScript 的代码是在 Objective-C 提供的环境下运行的，所以第一步就是把 JavaScript 加载进内存中，对于一个空的项目来说，所有的 JavaScript 代码大约占用 1.5 Mb 的内存空间。在这一步中，JSX 代码已经被转化成原生的 JavaScript 代码。</p>
<p>2.初始化模块信息</p>
<p>主要任务是找到所有需要暴露给 JavaScript 的类（Module）</p>
<p>初始化 JavaScript 代码的执行器，即 RCTJSCExecutor 对象</p>
<p>初始化JavaScript代码执行器，同时向 JavaScript 上下文中添加了一些 Block(Object-c中对闭包的实现) 作为全局变量。</p>
<p>3.Block–nativeRequireModuleConfig ： 它在 JavaScript 注册新的模块时调用：</p>
<p>Block–nativeFlushQueueImmediate：一般情况下，Objective-C 会定时、主动的调用JS放到MessageQueue 中的方法，实际上（由于卡顿或某些特殊原因），JavaScript 也可以主动调用 Objective-C 的方法，目前，React Native 的逻辑是，如果消息队列中有等待 Objective-C 处理的逻辑，而且 Objective-C 超过 5ms 都没有来取走，那么 JavaScript 就会主动调用 Objective-C 的方法。</p>
<p>请牢牢记住这个 5ms，它告诉我们 JavaScript 与 Objective-C 的交互是存在一定开销的，不然就不会等待而是每次都立刻发起请求。其次，这个时间开销大约是毫秒级的，不会比 5ms 小太多，否则等待这么久就意义不大了。</p>
<p>4.生成模块列表并写入 JavaScript 端</p>
<p>让 JavaScript 获取所有模块的名字，作为一个全局变量存储</p>
<p>5.执行 JavaScript 源码</p>
<p>运行代码时，第三步中所添加的 Block（nativeRequireModuleConfig ） 就会被执行，从而向 JavaScript 端写入配置信息。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6039087-a94e84c6c182f147.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700"></p>
<p>初始化工程</p>
<p><strong>方法调用</strong></p>
<p>1.OC调用 JS代码</p>
<p>OC不会直接调用实际的js函数，而是会去调用维系的中转函数，中转函数接收到    的参数包含了 ModuleId、MethodId 和 Arguments，就可以查找自己的模块配置表，找到真正要调用的 JavaScript 函数。</p>
<p>2.JS调用OC代码</p>
<p>在调用 Objective-C 代码时，JavaScript 会解析出方法的 ModuleId、MethodId 和 Arguments 并放入到 MessageQueue 中，等待 Objective-C 主动拿走，或者超时后主动发送给 Objective-C。</p>
<p>函数内部在每一次方调用中查找模块配置表找出要调用的方法，并通过 runtime 动态的调用。</p>
<p><a href="https://www.jianshu.com/p/82a28c8b673b">React-Native简介与运行原理解析</a><br><a href="http://blog.cnbang.net/tech/2698/">React Native通信机制详解</a></p>
]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative学习</tag>
      </tags>
  </entry>
  <entry>
    <title>RN学习相关地址</title>
    <url>/2018/06/15/%E5%89%8D%E7%AB%AF/RN%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h2 id="RN学习相关地址"><a href="#RN学习相关地址" class="headerlink" title="RN学习相关地址"></a>RN学习相关地址</h2><p><a href="https://www.jianshu.com/p/04c22869df76">ReactNative从零开始搭建环境笔记0</a>    </p>
<p><a href="https://reactnative.cn/docs/getting-started.html">reactnative中文官网</a><br><a href="https://www.cnblogs.com/summary-2017/p/7472772.html">React之JSX语法</a><br><a href="https://github.com/crazycodeboy/RNStudyNotes">crazycodeboy  RN学习笔记</a><br><a href="http://www.devio.org/tags/#React%20Native">RN学习应用与实践</a><br><a href="http://www.devio.org/2016/08/01/Reac-Native%E5%B8%83%E5%B1%80%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/">布局详细指南</a><br><a href="http://zh.learnlayout.com/display.html">CSS布局</a><br><a href="https://github.com/crazycodeboy/RNStudyNotes/tree/master/React%20Native%20%E6%AF%8F%E6%97%A5%E4%B8%80%E5%AD%A6">ReactNative每日一学</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex布局介绍</a><br><a href="https://github.com/sunnylqm/react-native-coding-style/blob/master/README.md#state/props">React Native 代码规范</a>  </p>
<h2 id="前端扩展"><a href="#前端扩展" class="headerlink" title="前端扩展"></a>前端扩展</h2><p><a href="http://www.ruanyifeng.com/blog/2016/01/flux.html">Flux 架构入门教程</a><br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html">Redux 入门教程（一）：基本用法</a><br>[JavaScript ES6基础语法] (<a href="http://es6.ruanyifeng.com/">http://es6.ruanyifeng.com/</a>)<br>[Redux介绍] (<a href="http://cn.redux.js.org/">http://cn.redux.js.org/</a>)<br><a href="https://cn.mobx.js.org/">MobX 简单、可扩展的状态管理</a><br><a href="https://www.yuque.com/ant-design/course/fd5af7">Ant Design 实战教程（beta 版）第一个组件</a></p>
<h2 id="视频学习"><a href="#视频学习" class="headerlink" title="视频学习"></a>视频学习</h2><p><a href="http://www.imooc.com/learn/808">ReactNative基础与入门</a>  </p>
]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative学习</tag>
      </tags>
  </entry>
  <entry>
    <title>RN脚手架初始化项目在0.45版本后问题</title>
    <url>/2018/06/15/%E5%89%8D%E7%AB%AF/RN%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E5%9C%A80.45%E7%89%88%E6%9C%AC%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>由于 <code>RN 0.45.0</code> 后，需要依赖一些第三方库，这些库通过 npm 或 yarn 下载非常慢，所以可以先手动下载，放到此文件夹： <code>~/.rncache</code>（如果路径不存在就手动创建一个）</p>
<p>首先配置npm镜像 <a href="">地址跳转</a> 如果依然失败的话 需要看以下步骤了。</p>
<p>以下是我用到的几个库（版本可能会有更新），如果手动下载有困难，可以找已经下载好的同学拿一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boost_1_63_0.tar.gz</span><br><span class="line">double-conversion-1.1.5.tar.gz</span><br><span class="line">folly-2016.09.26.00.tar.gz</span><br><span class="line">glog-0.3.4.tar.gz</span><br></pre></td></tr></table></figure>

<p>react更新依赖的脚本在这个地方：<code>react-native/scripts/ios-install-third-party.sh</code></p>
<p><a href="https://pan.baidu.com/s/1kVDUAZ9#list/path=%2Fother%2Freactnative.cn%2Frn-third-party&parentPath=%2Fother%2Freactnative.cn">百度网盘</a><br><a href="https://blog.csdn.net/u013751625/article/details/75046147">外链下载</a><br><a href="https://bbs.reactnative.cn/topic/4301/ios-rn-0-45%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E6%89%80%E9%9C%80%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BC%96%E8%AF%91%E5%BA%93-boost%E7%AD%89">iOS RN 0.45以上版本所需的第三方编译库(boost等)</a></p>
<p>产生原因：</p>
<ul>
<li><p>~/.rncache 中 boost_1_63_0.tar.gz， double-conversion-1.1.5.tar.gz， folly-2016.09.26.00.tar.gz， glog-0.3.4.tar.gz 文件下载不完整</p>
</li>
<li><p>node_modules/react-native/third-party 文件不完整</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>删除 .rncache 后重新下载，或手动下载后放入 .rncache 中</p>
</li>
<li><p>把以上文件解压后放入 node_modules/react-native/third-party 下</p>
</li>
</ul>
]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative学习</tag>
      </tags>
  </entry>
  <entry>
    <title>React DnD 的使用</title>
    <url>/2018/10/30/%E5%89%8D%E7%AB%AF/React%20DnD%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h3><p>想要灵活使用，就先知道几个核心API</p>
<ul>
<li><strong>DragSource</strong> 用于包装你需要拖动的组件，使组件能够被拖拽（make it draggable）</li>
<li><strong>DropTarget</strong> 用于包装接收拖拽元素的组件，使组件能够放置（dropped on it）</li>
<li><strong>DragDropContex</strong> 用于包装拖拽根组件，<code>DragSource</code> 和 <code>DropTarget</code> 都需要包裹在<code>DragDropContex</code>内</li>
<li><strong>DragDropContextProvider</strong> 与 <code>DragDropContex 类似</code>，用 <code>DragDropContextProvider</code> 元素包裹拖拽根组件。</li>
</ul>
<h3 id="外部优秀网站"><a href="#外部优秀网站" class="headerlink" title="外部优秀网站"></a>外部优秀网站</h3><p><a href="https://segmentfault.com/a/1190000014723549">React DnD 的使用</a><br><a href="http://react-dnd.github.io/react-dnd/">Drag and Drop for React</a>  </p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative基础学习</title>
    <url>/2018/06/15/%E5%89%8D%E7%AB%AF/ReactNative%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>组件装载，组件在渲染之前，会先调用默认的props，ES6就是，static defaultProps；接下来就是组件初始化，constructor（props）组件的构造方法；接下来是 componentWillMount组件在加载之前的方法；render完成组件的渲染；componentDidMount 组件渲染完成。接下来就进入运行阶段啦。（一次调用）</p>
<p>组件更新，在运行中，如果组件的属性发生了改变，就会调用 componentWillReceiveProps 会被调用，然后就会调用 shouldComponentUpdate ，询问我们是否要渲染组件，如果返回FALSE的话，就不会渲染；如果是TRUE的话，就会调用componentWillUpdate重新渲染组件，然后render，再后来就完成更新啦componentDidUpdate（多次调用）</p>
<p>组件卸载，页面关闭的时候，组件会被卸载，componentWillUnmount，可以完成资源的回收与释放啦。（一次调用）</p>
<h2 id="创建组件的三种方式"><a href="#创建组件的三种方式" class="headerlink" title="创建组件的三种方式"></a>创建组件的三种方式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 方式1 ES6</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">NewView</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span>hello ES6<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 方式2 ES5  需要module.exports</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var NewView = React.createClass(&#123;</span></span><br><span class="line"><span class="comment">//     render()&#123;</span></span><br><span class="line"><span class="comment">//         return &lt;Text style=&#123;styles.container&#125;&gt;hello ES5&lt;/Text&gt; ;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// module.exports = NewView;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 方式3 函数式  需要module.exports</span></span><br><span class="line"><span class="comment"> * 无状态，不能使用this，但是可以传入属性</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function NewView(props) &#123;</span></span><br><span class="line"><span class="comment">//     return &lt;Text style=&#123;styles.container&#125;&gt;hello &#123;props.name&#125;&lt;/Text&gt; ;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// module.exports = NewView;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="组件的导入和导出"><a href="#组件的导入和导出" class="headerlink" title="组件的导入和导出"></a>组件的导入和导出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一、导出组件</span><br><span class="line">三种导出方式，之前学过的ES6, ES5, 函数式三种建立组件方式，里面有提及过如何导出</span><br><span class="line"></span><br><span class="line">使用方式：</span><br><span class="line">import EIComponent from &#x27;./EIComponent&#x27;</span><br><span class="line"></span><br><span class="line">二、导出变量</span><br><span class="line">方法一：</span><br><span class="line">export var name = &#x27;sun&#x27;;</span><br><span class="line">export var age = &#x27;female&#x27;;</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">var name = &#x27;sun&#x27;;</span><br><span class="line">var age = &#x27;22&#x27;;</span><br><span class="line">export &#123;name, age&#125;;</span><br><span class="line"></span><br><span class="line">使用方式：</span><br><span class="line">例如setup.js中加入：</span><br><span class="line">import EIComponent,&#123;name,age&#125; from &#x27;./EIComponent&#x27;</span><br><span class="line"></span><br><span class="line">三、导出方法</span><br><span class="line">方法前加export</span><br><span class="line">export function sum(a,b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用方式：</span><br><span class="line">和变量使用方式一致</span><br><span class="line">import EIComponent,&#123;name,age,sum&#125; from &#x27;./EIComponent&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="React-Native-props使用详解"><a href="#React-Native-props使用详解" class="headerlink" title="React Native props使用详解"></a>React Native props使用详解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、什么是props? 父组件传递给子组件的属性</span><br><span class="line">2、如何使用props?</span><br><span class="line">3、什么是默认属性以及它的作用？ </span><br><span class="line">4、如何对props进行约束和检查？</span><br><span class="line">5、props使用小技巧之延展操作符？</span><br><span class="line">6、props使用小技巧之解构赋值？</span><br><span class="line"></span><br><span class="line">props使用技巧--延展操作符</span><br><span class="line">延展操作符是ES6中的新语法。当我要传递很多个属性时，</span><br><span class="line">let params = &#123;name:&#x27;张&#x27;，age:18, sex:&#x27;女&#x27; &#125;；</span><br><span class="line">使用的时候就是 &lt;PropsTest name=&#123;params.name&#125; sex=&#123;params.sex&#125; /&gt;（但这个非常的复杂，代码也会很长）</span><br><span class="line">&lt;PropsTest &#123; ...params &#125; /&gt;（使用 大括号里放三个点 ...，然后接着 params 就可以在下一个页面被使用了。 ）</span><br><span class="line"></span><br><span class="line">props使用技巧--解构赋值</span><br><span class="line">延展操作符是将属性全部进行赋值，但如果只想取出部分来进行赋值，就可以使用解构赋值。</span><br><span class="line">let params = &#123;name:&#x27;张&#x27;，age:18, sex:&#x27;女&#x27; &#125;；</span><br><span class="line">let &#123;name,sex&#125;=params;</span><br><span class="line"> &lt;PropsTest name=&#123;name&#125; sex=&#123;sex&#125; /&gt; </span><br><span class="line">它比传统的方式好是它可以从一组属性中获取指定属性，而且，少了一点点代码。</span><br></pre></td></tr></table></figure>

<h2 id="什么是state"><a href="#什么是state" class="headerlink" title="什么是state"></a>什么是state</h2><blockquote>
<p>props是不可改变，只读的。为了实现交互，就需要用到组件的state。我们将组件看为状态机，UI是各种各样的状态，并在各种各样的状态之间可以切换，只需要改变组件的state，就会重新渲染UI。<br>state是组件私有的，是没有办法通过其他组件传递过来的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">state也可以吹气球</span><br><span class="line"></span><br><span class="line">（导入新的资源，都会报错，因此需要将包管理器关掉，再重新启动服务即可。）</span><br><span class="line"></span><br><span class="line">如何控制state的变化呢，在文字上设置方法，</span><br><span class="line">onPress=&#123; ()=&gt; &#123;this.setState (&#123; size:this.state.size+10&#125;); &#125;&#125;</span><br><span class="line"> 改变state的值是用 this.setState&#123;size:90&#125;</span><br><span class="line">&lt;Image </span><br><span class="line">style=&#123;&#123;width:this.state.size,height:this.state.size&#125;&#125;  </span><br><span class="line">source=&#123;require(&#x27;./qiqiu.png)&#125;</span><br><span class="line">/&gt;</span><br><span class="line">上述代码就将 Image 的大小给渲染出来啦。(动态化的UI就有啦)</span><br></pre></td></tr></table></figure>

<h2 id="什么是ref"><a href="#什么是ref" class="headerlink" title="什么是ref"></a>什么是ref</h2><p>ref是什么？<br>ref是组件的特殊属性，组件被渲染后，指向组件的一个引用。可以通过组件的ref属性，来获取真实的组件。<br>因为，组件并不是真正的DOM节点，而是存在于内存中的一种数据结构，称为虚拟的DOM，只有当它真正的插入文档之后，才变为真正的DOM节点。根据React的设计，所以的DOM变动都发生在虚拟DOM上，然后再将实际的部分反映到真实的DOM上–这就是 DOM DIff，它可以提高页面性能。</p>
<h2 id="类-class"><a href="#类-class" class="headerlink" title="类 class"></a>类 class</h2><p>类<br>ES6中引入了class（类），让javaScript的面向对象编程变得更加简单和易于理解</p>
<p>一、类的导入<br>和导入普通的组件是一样的<br>import Student from ‘./Student’; </p>
<p>二、类的实例化<br>可以在setup.js的构造函数中，如下：<br>this.stu= new Student(“晓明”，”男”, 16);</p>
<p>三、使用类的实例<br>setup.js的render里面</p>
<p>this.stu.getDescription()//获取实例中的方法或属性等</p>
<p>四、类的继承<br>构造方法和方法是可以重写的</p>
]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative记录问题点</title>
    <url>/2018/06/15/%E5%89%8D%E7%AB%AF/ReactNative%E8%AE%B0%E5%BD%95%E9%97%AE%E9%A2%98%E7%82%B9/</url>
    <content><![CDATA[<h2 id="错误打印log的方法因为多了一个逗号："><a href="#错误打印log的方法因为多了一个逗号：" class="headerlink" title="错误打印log的方法因为多了一个逗号："></a>错误打印log的方法因为多了一个逗号：</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;*************ZSDiscountHomeBrandCardView**str***************&#x27;</span>, +<span class="built_in">this</span>.props.info)</span><br><span class="line"></span><br><span class="line">要删掉逗号就可以了 </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;*************ZSDiscountHomeBrandCardView**str***************&#x27;</span> +<span class="built_in">this</span>.props.info)</span><br></pre></td></tr></table></figure>

<h2 id="注意：此种方式是异步操作不能立马打印出log"><a href="#注意：此种方式是异步操作不能立马打印出log" class="headerlink" title="注意：此种方式是异步操作不能立马打印出log"></a>注意：此种方式是异步操作不能立马打印出log</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  <span class="attr">cardList</span>: tmpBrands</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;this.state.cardList=&#x27;</span> + <span class="built_in">this</span>.state.cardList)</span><br><span class="line"></span><br><span class="line"><span class="comment">//此种方式可以打印出log</span></span><br><span class="line"><span class="built_in">this</span>.setState(</span><br><span class="line">  &#123;<span class="attr">cardList</span>: tmpBrands&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;=》this.state.cardList=&#x27;</span> + <span class="built_in">this</span>.state.cardList)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="RN中this所引起的undefined-is-not-an-object错误"><a href="#RN中this所引起的undefined-is-not-an-object错误" class="headerlink" title="RN中this所引起的undefined is not an object错误"></a>RN中this所引起的undefined is not an object错误</h2><p>在我们编写RN代码的时候经常会出现一个错误，undefined is not an object(evaluating ‘this.refs’ ).<br>undefined is not an object错误，提示我们未知的对象，该句话的含义就是我们没有定义该对象。但是this就是当前对象，为什么还会出现如此问题？只有一种可能，就是当前引用的this和this.setState的this不是指向同一个对象，这样才会出想“undefined is not an object”这样的错误。<br>那么，今天我们来谈谈RN里的this，介绍几个特殊的case。<br><Dialog ref="dialog" callback={this.refuseCallback.bind(this)}/><br><a href="http://blog.csdn.net/codetomylaw/article/details/52215787">http://blog.csdn.net/codetomylaw/article/details/52215787</a></p>
<h2 id="rn中Image不要用嵌套"><a href="#rn中Image不要用嵌套" class="headerlink" title="rn中Image不要用嵌套"></a>rn中Image不要用嵌套</h2><p>莫名在android上有很多问题  例如：设置边角弧度的时候在android上显示异常、加入jdrouter 页面布局错乱</p>
<h2 id="hasOwnProperty-是否具有某个属性的使用"><a href="#hasOwnProperty-是否具有某个属性的使用" class="headerlink" title="hasOwnProperty  是否具有某个属性的使用"></a>hasOwnProperty  是否具有某个属性的使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">是否具有某个属性的使用</span><br></pre></td></tr></table></figure>


<h2 id="组件里-一定不能加分号"><a href="#组件里-一定不能加分号" class="headerlink" title="组件里 一定不能加分号"></a>组件里 一定不能加分号</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_renderErrorView () &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">NavigationBar</span> <span class="attr">Title</span>=<span class="string">&quot;专属优惠&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">JDNetworkErrorView</span> <span class="attr">onRetry</span>=<span class="string">&#123;this._fetchData&#125;/</span>&gt;</span>    ；//此处加分号就是错误的</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="导入react和JDReact方式"><a href="#导入react和JDReact方式" class="headerlink" title="导入react和JDReact方式"></a>导入react和JDReact方式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  StyleSheet,</span><br><span class="line">  Text,</span><br><span class="line">  View,</span><br><span class="line">  Platform</span><br><span class="line">&#125;<span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  JDText,</span><br><span class="line">  JDDevice,</span><br><span class="line">  JDImage,</span><br><span class="line">  JDTouchable,</span><br><span class="line">  JDNativeToast</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;@jdreact/jdreact-core-lib&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative使用记录</tag>
      </tags>
  </entry>
  <entry>
    <title>React简介</title>
    <url>/2018/06/15/%E5%89%8D%E7%AB%AF/React%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>#React简介<br><a href="http://www.jianshu.com/p/1606f8bd46ed">http://www.jianshu.com/p/1606f8bd46ed</a></p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><blockquote>
<p>Facebook认为MVC无法满足他们的扩展需求，由于他们非常巨大的代码库和庞大的组织，使得MVC很快变得非常复复杂，每当需要添加一项新的功能或特性时，系统的复杂度就成级数增长，致使代码变得脆弱和不可预测，结果导致他们的MVC正在土崩瓦解。认为MVC不适合大规模应用，当系统中有很多的模型和相应的视图时，其复杂度就会迅速扩大，非常难以理解和调试，特别是模型和视图间可能存在的双向数据流动。</p>
</blockquote>
<h2 id="React特点"><a href="#React特点" class="headerlink" title="React特点"></a>React特点</h2><blockquote>
<p>1、作为UI<br> React可以作为MVC中的View层进行使用，并且在已有项目中很容易使用React开发新功能。<br>2、虚拟dom<br>Virtual DOM 虚拟DOM<br>传统的web应用，操作DOM一般是直接更新操作的，但是我们知道DOM更新通常是比较昂贵的。而React为了尽可能减少对DOM的操作，提供了一种不同的而又强大的方式来更新DOM，代替直接的DOM操作。就是Virtual DOM,一个轻量级的虚拟的DOM，就是React抽象出来的一个对象，描述dom应该什么样子的，应该如何呈现。通过这个Virtual DOM去更新真实的DOM，由这个Virtual DOM管理真实DOM的更新。</p>
<p>为什么通过这多一层的Virtual DOM操作就能更快呢？ 这是因为React有个diff算法，更新Virtual DOM并不保证马上影响真实的DOM，React会等到事件循环结束，然后利用这个diff算法，通过当前新的dom表述与之前的作比较，计算出最小的步骤更新真实的DOM。<br>3、组件化<br>Components 组件<br>在DOM树上的节点被称为元素，在这里则不同，Virtual DOM上称为commponent。Virtual DOM的节点就是一个完整抽象的组件，它是由commponents组成。</p>
<p>component 的使用在 React 里极为重要, 因为 components 的存在让计算 DOM diff 更高效。</p>
</blockquote>
<h2 id="学习准备"><a href="#学习准备" class="headerlink" title="学习准备"></a>学习准备</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、前端基础知识：html、css、JavaScript</span><br><span class="line">2、jsx语法知识</span><br><span class="line">3、es6 相关知识</span><br></pre></td></tr></table></figure>
<h2 id="React和ReactNative关系"><a href="#React和ReactNative关系" class="headerlink" title="React和ReactNative关系"></a>React和ReactNative关系</h2><blockquote>
<p>react用于web应用开发，rn采用React方式进行移动应用开发。<br>rn采用React语法，用于进行JavaScript跨终端应用开发，即拥有原生native的交互体验，又能够保留React自由的开发效率，使用灵活的的html和css布局，使用React语法结构组件，然后同时运行在ios和android平台上。</p>
</blockquote>
<h2 id="React官网推荐JavaScript教程"><a href="#React官网推荐JavaScript教程" class="headerlink" title="React官网推荐JavaScript教程"></a>React官网推荐JavaScript教程</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript">React官网推荐JavaScript教程</a> </p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React项目创建 与 redux的使用</title>
    <url>/2018/10/30/%E5%89%8D%E7%AB%AF/React%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="初始化一个react项目"><a href="#初始化一个react项目" class="headerlink" title="初始化一个react项目"></a>初始化一个react项目</h3><ul>
<li><code>create-react-app</code>是一个通过<code>npm</code>发布的安装包，在确认<code>Node.js</code>和<code>npm</code>安装好之后，输入下面命令创建。<br>  <code>npm install -g create-react-app</code></li>
<li>安装结束后，使用下面命令创建应用目录。<br>  <code>create-react-app test-app </code> </li>
<li>打开目录<br>  <code>cd test-app</code></li>
<li>运行项目<br>  <code>npm start</code> </li>
</ul>
<h3 id="基于create-react-app的再配置"><a href="#基于create-react-app的再配置" class="headerlink" title="基于create-react-app的再配置"></a>基于create-react-app的再配置</h3><p><a href="https://www.cnblogs.com/xiaohuochai/p/8491055.html">使用react-app-rewired来进行react的再配置</a></p>
<h3 id="如何优雅地在React项目中使用Redux"><a href="#如何优雅地在React项目中使用Redux" class="headerlink" title="如何优雅地在React项目中使用Redux"></a>如何优雅地在React项目中使用Redux</h3><p><a href="https://www.cnblogs.com/sampapa/p/8134086.html">使用Redux</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save redux react-redux redux-thunk</span><br><span class="line">npm install --save-dev redux-logger</span><br></pre></td></tr></table></figure>

<p><strong>相关库说明</strong>  </p>
<ul>
<li><p><strong>React</strong> UI框架</p>
</li>
<li><p><strong>Redux</strong> 状态管理工具，与React没有任何关系，其他UI框架也可以使用Redux</p>
</li>
<li><p><strong>react-redux</strong> React插件，作用：方便在React项目中使用Redux</p>
</li>
<li><p><strong>react-thunk</strong> 中间件，作用：支持异步action</p>
</li>
</ul>
<p><strong>Redux三大原则</strong>  </p>
<ul>
<li>单一数据源<br>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中</li>
<li>State 是只读的<br>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象</li>
<li>使用纯函数来执行修改<br>为了描述 action 如何改变 state tree ，你需要编写 reducers</li>
</ul>
<h3 id="外部优秀网站"><a href="#外部优秀网站" class="headerlink" title="外部优秀网站"></a>外部优秀网站</h3><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a><br><a href="https://www.css88.com/book/css/">CSS参考手册</a><br><a href="http://www.ruanyifeng.com/blog/2015/03/react.html">React 入门 ruanyifeng</a><br><a href="https://segmentfault.com/a/1190000012921279">React入门篇</a><br><a href="https://react.docschina.org/docs/hello-world.html">react.docschina.org</a><br><a href="http://nav.react-china.org/">React 中文索引</a><br><a href="https://github.com/LeuisKen/react-collection">react-collection</a><br><a href="https://ant.design/docs/react/introduce-cn">Ant Design of React</a><br><a href="http://react-dnd.github.io/react-dnd/">Drag and Drop for React</a><br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html">Redux 入门教程</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element#%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9">HTML 元素参考
</a><br><a href="http://www.divcss5.com/">divcss学习</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax中的withCredentials使用</title>
    <url>/2021/12/06/%E5%89%8D%E7%AB%AF/ajax%E4%B8%AD%E7%9A%84withCredentials%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="XMLHttpRequest-withCredentials-有什么用"><a href="#XMLHttpRequest-withCredentials-有什么用" class="headerlink" title="XMLHttpRequest.withCredentials 有什么用?"></a>XMLHttpRequest.withCredentials 有什么用?</h4><p>跨域请求是否提供凭据信息(cookie、HTTP认证及客户端SSL证明等)<br>也可以简单的理解为，当前请求为跨域类型时是否在请求中协带cookie。<br>XMLHttpRequest.withCredentials 怎么用?<br>withCredentials属于XMLHttpRequest对象下的属性，可以对其进行查看或配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&#x27;GET&#x27;, &#x27;http://172.19.0.215:1314/learnLinkManager/getLearnLinkList&#x27;, true); </span><br><span class="line">xhr.withCredentials = true; //关键设置</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  console.log(&#x27;withCredentials=&gt;&#x27;, xhr.withCredentials);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(null);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/af1fc0fab4c5">ajax中的withCredentials使用效果</a><br><a href="https://www.cnblogs.com/zhangcybb/p/6594991.html">跨域请求设置withCredentials</a><br><a href="https://blog.csdn.net/sysuzjz/article/details/51566713">跨域请求带cookie的解决方案</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>跨域请求是否提供凭据信息cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>hashHistory 和 browserHistory 的区别</title>
    <url>/2018/10/30/%E5%89%8D%E7%AB%AF/hashHistory%20%E5%92%8C%20browserHistory%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="router的使用"><a href="#router的使用" class="headerlink" title="router的使用"></a>router的使用</h3><ul>
<li><p>安装<br><code>npm install react-router-dom --save</code></p>
</li>
<li><p>导入<br><code>import &#123; HashRouter, Route, Switch, withRouter,BrowserRouter &#125; from &#39;react-router-dom&#39;;</code></p>
</li>
<li><p>官方推荐使用browserHistory</p>
</li>
</ul>
<p>使用hashHistory,浏览器的url是这样的：/#/user/liuna?_k=adseis<br>使用browserHistory,浏览器的url是这样的：/user/liuna</p>
<p><a href="https://www.cnblogs.com/liuna/p/6137970.html">router的使用</a><br><a href="https://www.jianshu.com/p/8954e9fb0c7e">在React中使用react-router-dom路由</a>   </p>
<h3 id="使用-withRouter"><a href="#使用-withRouter" class="headerlink" title="使用 withRouter"></a>使用 withRouter</h3><p>引入withRouterimport { withRouter } from “react-router-dom”</p>
<p>然后用高阶组件withRouter把要导出的组件传入进去<br>最后使用this.props.history.push()把你需要跳转的路由push进去就好了</p>
<p><a href="https://www.jianshu.com/p/52528ebb771d">react-router v4 手动控制路由跳转</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>开发前端react项目 知识点总结</title>
    <url>/2018/06/15/%E5%89%8D%E7%AB%AF/js%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="js中的-和-amp-amp"><a href="#js中的-和-amp-amp" class="headerlink" title="js中的||和&amp;&amp;"></a>js中的||和&amp;&amp;</h4><ul>
<li><p>逻辑与&amp;&amp;和逻辑或||操作符可以应用于任何类型的操作数，而不仅仅是布尔值。</p>
</li>
<li><p>几乎所有语言中||和&amp;&amp;都遵循“短路”原理， 如&amp;&amp;中第一个表达式为假就不会去处理第二个表达式，而||正好相反。js同样也遵循上述原则： 
　　</p>
</li>
<li><p>当逻辑或||时，找到为true的分项就停止处理，并返回该分项的值，否则执行完，并返回最后分项的值。</p>
</li>
<li><p>当逻辑与&amp;&amp;时，找到为false的分项就停止处理，并返回该分项的值。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;&quot;</span> || <span class="literal">null</span> || <span class="number">3</span> || <span class="number">4</span>;<span class="comment">//3</span></span><br><span class="line">alert(a);</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">4</span> &amp;&amp; <span class="number">5</span> &amp;&amp; <span class="literal">null</span> &amp;&amp; <span class="string">&quot;0&quot;</span>;<span class="comment">//null</span></span><br><span class="line">alert(b);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="扩展运算符-…-的使用"><a href="#扩展运算符-…-的使用" class="headerlink" title="扩展运算符  … 的使用"></a>扩展运算符  … 的使用</h4><p><a href="https://www.cnblogs.com/chrischjh/p/4848934.html">妙用ES6解构和扩展运算符让你的代码更优雅</a></p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p><a href="https://www.cnblogs.com/snandy/p/4403111.html">ES6箭头函数（Arrow Functions）</a></p>
<h4 id="字典合并-利用扩展运算符"><a href="#字典合并-利用扩展运算符" class="headerlink" title="字典合并 利用扩展运算符"></a>字典合并 利用扩展运算符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj1 = &#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: &#x27;12&#x27;, &#x27;salary&#x27;: &#x27;2332&#x27;&#125;;</span><br><span class="line">const obj2 = &#123;&#x27;fat&#x27;: &#x27;true&#x27;, &#x27;name&#x27;: &#x27;李四&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">const obj3 = &#123;...obj1,...obj2&#125;;</span><br><span class="line">console.log(&#x27;obj3=====&#x27;, obj3);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="原生JS实现深拷贝"><a href="#原生JS实现深拷贝" class="headerlink" title="原生JS实现深拷贝"></a>原生JS实现深拷贝</h4><p><a href="https://blog.csdn.net/wang839305939/article/details/80819132">原生JS实现深拷贝</a><br><a href="https://www.css88.com/archives/8319">JavaScript 中的对象拷贝</a></p>
<ul>
<li>使用 <code>Object.assign()</code> 方法用于将从一个或多个源对象中的所有可枚举的属性值复制到目标对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">&#125;;</span><br><span class="line">let objCopy = Object.assign(&#123;&#125;, obj);</span><br><span class="line">console.log(objCopy);</span><br><span class="line">// Result - &#123; a: 1, b: 2 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>JSON.parse(JSON.stringify(object))</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123; </span><br><span class="line">  a: 1,</span><br><span class="line">  b: &#123; </span><br><span class="line">    c: 2,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let newObj = JSON.parse(JSON.stringify(obj));</span><br><span class="line"> </span><br><span class="line">obj.b.c = 20;</span><br><span class="line">console.log(obj); // &#123; a: 1, b: &#123; c: 20 &#125; &#125;</span><br><span class="line">console.log(newObj); // &#123; a: 1, b: &#123; c: 2 &#125; &#125; (一个新的对象)</span><br></pre></td></tr></table></figure>

<h4 id="Chrome-react调试插件"><a href="#Chrome-react调试插件" class="headerlink" title="Chrome react调试插件"></a>Chrome react调试插件</h4><p><a href="http://www.cnplugins.com/zhuanti/how-to-use-react-tools.html">React - React Developer Tools开发者工具的安装与使用（Chrome调试插件）</a></p>
<h4 id="从React15-5起，React-PropTypes被移入到单独的package中"><a href="#从React15-5起，React-PropTypes被移入到单独的package中" class="headerlink" title="从React15.5起，React.PropTypes被移入到单独的package中"></a>从React15.5起，React.PropTypes被移入到单独的package中</h4><p><a href="https://react.docschina.org/docs/typechecking-with-proptypes.html">使用 PropTypes 进行类型检查</a></p>
<p><strong>需要我们安装软件包prop-types 安装方法为：</strong></p>
<ul>
<li><p>安装prop-types <code>npm install prop-types --save</code>      </p>
</li>
<li><p>导入  <code>import &#123; PropTypes&#125; from &#39;prop-types&#39;;</code></p>
</li>
<li><p>使用</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  static defaultProps = &#123;</span><br><span class="line">    name: &#x27;stranger&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">static propTypes = &#123;</span><br><span class="line">        autoPlay: PropTypes.bool.isRequired,</span><br><span class="line">        maxLoops: PropTypes.number.isRequired,</span><br><span class="line">        posterFrameSrc:PropTypes.string.isRequired,</span><br><span class="line">        videoSrc: PropTypes.string.isRequired,</span><br><span class="line">        nameString: PropTypes.string.isRequired,</span><br><span class="line">    &#125;;  </span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<h4 id="CSS3的calc-使用"><a href="#CSS3的calc-使用" class="headerlink" title="CSS3的calc()使用"></a>CSS3的calc()使用</h4><p>calc()从字面我们可以把他理解为一个函数function。其实calc是英文单词calculate(计算)的缩写，是css3的一个新增的功能，用来指定元素的长度。比如说，你可以使用calc()给元素的border、margin、pading、font-size和width等属性设置动态值。为何说是动态值呢?因为我们使用的表达式来得到的值。不过calc()最大的好处就是用在流体布局上，可以通过calc()计算得到元素的宽度。</p>
<p><a href="https://www.w3cplus.com/css3/how-to-use-css3-calc-function.html">CSS3的calc()使用</a></p>
<h4 id="如果变量名与属性名不一致，必须写成下面这样。"><a href="#如果变量名与属性名不一致，必须写成下面这样。" class="headerlink" title="如果变量名与属性名不一致，必须写成下面这样。"></a>如果变量名与属性名不一致，必须写成下面这样。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let &#123; foo: baz &#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;;</span><br><span class="line">baz // &quot;aaa&quot;</span><br><span class="line"></span><br><span class="line">let obj = &#123; first: &#x27;hello&#x27;, last: &#x27;world&#x27; &#125;;</span><br><span class="line">let &#123; first: f, last: l &#125; = obj;</span><br><span class="line">f // &#x27;hello&#x27;</span><br><span class="line">l // &#x27;world&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="ES6-引入了一种新的原始数据类型Symbol"><a href="#ES6-引入了一种新的原始数据类型Symbol" class="headerlink" title="ES6 引入了一种新的原始数据类型Symbol"></a>ES6 引入了一种新的原始数据类型Symbol</h4><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>npm更换镜像</title>
    <url>/2021/12/06/%E5%89%8D%E7%AB%AF/npm%E6%9B%B4%E6%8D%A2%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h4 id="由于不可说原因，npm-install时，速度总是不尽如人意，解决办法是修改npm的数据源"><a href="#由于不可说原因，npm-install时，速度总是不尽如人意，解决办法是修改npm的数据源" class="headerlink" title="由于不可说原因，npm install时，速度总是不尽如人意，解决办法是修改npm的数据源"></a>由于不可说原因，npm install时，速度总是不尽如人意，解决办法是修改npm的数据源</h4><p><code>npm config set registry https://registry.npm.taobao.org</code></p>
<h4 id="开发ReactNative项目，搭建环境时通过如下代码将npm设置成淘宝镜像"><a href="#开发ReactNative项目，搭建环境时通过如下代码将npm设置成淘宝镜像" class="headerlink" title="开发ReactNative项目，搭建环境时通过如下代码将npm设置成淘宝镜像"></a>开发ReactNative项目，搭建环境时通过如下代码将npm设置成淘宝镜像</h4><p>终端直接设置 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org --global</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure>

<p>或者 编辑 ~/.npmrc 加入下面内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry = http://registry.cnpmjs.org</span><br></pre></td></tr></table></figure>

<h4 id="修改后可以通过这个进行测试"><a href="#修改后可以通过这个进行测试" class="headerlink" title="修改后可以通过这个进行测试"></a>修改后可以通过这个进行测试</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line"></span><br><span class="line">npm config get registry </span><br></pre></td></tr></table></figure>
<p><a href="https://segmentfault.com/a/1190000002589144">npm配置镜像、设置代理</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>npm更换镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>react 默认端口修改</title>
    <url>/2021/12/06/%E5%89%8D%E7%AB%AF/react%20%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<h4 id="修改react-port的方法"><a href="#修改react-port的方法" class="headerlink" title="修改react port的方法"></a>修改react port的方法</h4><p>执行npm start便可启动项目，所以不管是react怎么升级，找修改端口的位置，我们首先都应该想到看一下package.json里面的配置信息。如果你是先前创建的项目，端口的修改是在scripts文件夹的start.js文件里。但是现在创建的项目里没有了scripts文件夹了，但看package.json会发现它放到了依赖里面，在node_modules文件夹里的可以看到react-scripts文件夹，在start.js里可以找到修改端口的代码。</p>
<h4 id="依赖的模块放在哪"><a href="#依赖的模块放在哪" class="headerlink" title="依赖的模块放在哪"></a>依赖的模块放在哪</h4><ul>
<li><p>dependencies: 指定项目运行所依赖的模块，即：开发版和发布版都需要的依赖。</p>
</li>
<li><p>devDependencies:指定项目开发所需要的模块，即：开发版需要但发布版不需要，例如关于测试的、文档类的。</p>
</li>
</ul>
<p>npm install <package_name> –save 表示将这个包名及对应的版本添加到 package.json的 dependencies<br>npm install <package_name> –save-dev 表示将这个包名及对应的版本添加到 package.json的 devDependencies</p>
<p><a href="https://blog.csdn.net/weixin_37242696/article/details/80654508">react 默认端口修改</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react 默认端口修改</tag>
      </tags>
  </entry>
  <entry>
    <title>redux</title>
    <url>/2021/12/06/%E5%89%8D%E7%AB%AF/react-redux/</url>
    <content><![CDATA[<h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><p>随着 JavaScript 单页应用开发日趋复杂，<strong>JavaScript 需要管理比任何时候都要多的 state （状态）</strong>。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。</p>
<p><a href="https://www.redux.org.cn/">Redux 中文文档</a></p>
<h3 id="几个关键库"><a href="#几个关键库" class="headerlink" title="几个关键库"></a>几个关键库</h3><pre><code>   &quot;react-redux&quot;: &quot;^5.1.0&quot;,
    &quot;redux&quot;: &quot;^4.0.1&quot;,
    &quot;redux-logger&quot;: &quot;^3.0.6&quot;,
    &quot;redux-thunk&quot;: &quot;^2.3.0&quot;
</code></pre>
<h3 id="action内的type取名一定需要唯一的-如果多出添加重名的type-多处reducer都会收到该type的事件"><a href="#action内的type取名一定需要唯一的-如果多出添加重名的type-多处reducer都会收到该type的事件" class="headerlink" title="action内的type取名一定需要唯一的 如果多出添加重名的type 多处reducer都会收到该type的事件"></a>action内的type取名一定需要唯一的 如果多出添加重名的type 多处reducer都会收到该type的事件</h3><p>所有的 reducer 都会收到 action。<br>reducer 通过 action.type 来进行判定处理。<br>如果某个 reducer 不处理某个动作，也就是没有处理这个 action.type 的 case， 就会走 default 分支，把 state 原样返回。</p>
<p><a href="https://segmentfault.com/q/1010000012086401/a-1020000012111603">react-redux中多个action和reducer是如何关联的</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react redux</tag>
      </tags>
  </entry>
  <entry>
    <title>echarts 图标</title>
    <url>/2021/12/06/%E5%89%8D%E7%AB%AF/%E5%9B%BE%E6%A0%87echart/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot; /&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;div id=&quot;main&quot; style=&quot;position: absolute; left: 0; top: 0;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">let myChart=echarts.init(main)</span><br><span class="line">; (onresize=_=&gt;&#123;</span><br><span class="line">  main.style.width=innerWidth+&#x27;px&#x27;</span><br><span class="line">  main.style.height=innerHeight+&#x27;px&#x27;</span><br><span class="line">  myChart.resize()</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">const getopt=(title, inited, data)=&gt;(&#123;</span><br><span class="line">  backgroundColor: &#x27;#fff&#x27;,</span><br><span class="line">    title: &#123;</span><br><span class="line">        text: title,</span><br><span class="line">        left: &#x27;33%&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">        trigger: &#x27;axis&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    legend: Object.assign(&#123;</span><br><span class="line">        data: Object.keys(data[0]).filter(a=&gt;a!==&#x27;日期&#x27;),</span><br><span class="line">        top: &#x27;12%&#x27;,</span><br><span class="line">    &#125;, inited? &#123;&#125;: &#123;</span><br><span class="line">        selected: &#123;heapTotal: false, external: false, rss: false&#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    grid: &#123;</span><br><span class="line">        left: &#x27;3%&#x27;,</span><br><span class="line">        right: &#x27;4%&#x27;,</span><br><span class="line">        bottom: &#x27;3%&#x27;,</span><br><span class="line">        top: &#x27;22%&#x27;,</span><br><span class="line">        containLabel: true</span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: &#123;</span><br><span class="line">        type: &#x27;category&#x27;,</span><br><span class="line">        boundaryGap: false,</span><br><span class="line">        data: data.map(a=&gt;a[&#x27;日期&#x27;])</span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;</span><br><span class="line">        type: &#x27;value&#x27;,</span><br><span class="line">        axisLabel:&#123;formatter: &#x27;&#123;value&#125; 毫秒&#x27;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    series: Object.keys(data[0]).filter(a=&gt;a!==&#x27;日期&#x27;).map(k=&gt;(&#123;</span><br><span class="line">      name: k,</span><br><span class="line">      type: &#x27;line&#x27;,</span><br><span class="line">      stack: k,</span><br><span class="line">      data: data.map(a=&gt;a[k]),</span><br><span class="line">    &#125;)),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const data=[</span><br><span class="line">&#123;</span><br><span class="line">  &quot;日期&quot;: &quot;11-16&quot;,</span><br><span class="line">  &quot;Android&quot;: &quot;758.03&quot;,</span><br><span class="line">  &quot;iOS&quot;: &quot;872.21&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;日期&quot;: &quot;11-17&quot;,</span><br><span class="line">    &quot;Android&quot;: &quot;761.54&quot;,</span><br><span class="line">    &quot;iOS&quot;: &quot;878.91&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;日期&quot;: &quot;11-18&quot;,</span><br><span class="line">    &quot;Android&quot;: &quot;763.22&quot;,</span><br><span class="line">    &quot;iOS&quot;: &quot;871.78&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;日期&quot;: &quot;11-19&quot;,</span><br><span class="line">    &quot;Android&quot;: &quot;771.16&quot;,</span><br><span class="line">    &quot;iOS&quot;: &quot;888.15&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;日期&quot;: &quot;11-20&quot;,</span><br><span class="line">    &quot;Android&quot;: &quot;741.59&quot;,</span><br><span class="line">    &quot;iOS&quot;: &quot;847.57&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;日期&quot;: &quot;11-21&quot;,</span><br><span class="line">    &quot;Android&quot;: &quot;734.98&quot;,</span><br><span class="line">    &quot;iOS&quot;: &quot;832.24&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;日期&quot;: &quot;11-22&quot;,</span><br><span class="line">    &quot;Android&quot;: &quot;749.53&quot;,</span><br><span class="line">    &quot;iOS&quot;: &quot;821.18&quot;</span><br><span class="line">&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myChart.setOption(getopt(&#x27;H5加载耗时概览(来源烛龙平台)&#x27;, &#123;&#125;, data))</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/06/%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/</url>
    <content><![CDATA[
<meta charset="utf-8">
<meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport" />
<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
<div id="main" style="position: absolute; left: 0; top: 0;"></div>

<script type="text/javascript">
let myChart=echarts.init(main)
; (onresize=_=>{
  main.style.width=innerWidth+'px'
  main.style.height=innerHeight+'px'
  myChart.resize()
})()

const getopt=(title, inited, data)=>({
  backgroundColor: '#fff',
    title: {
        text: title,
        left: '33%',
    },
    tooltip: {
        trigger: 'axis',
    },
    legend: Object.assign({
        data: Object.keys(data[0]).filter(a=>a!=='日期'),
        top: '12%',
    }, inited? {}: {
        selected: {heapTotal: false, external: false, rss: false}
    }),
    grid: {
        left: '3%',
        right: '4%',
        bottom: '3%',
        top: '22%',
        containLabel: true
    },
    xAxis: {
        type: 'category',
        boundaryGap: false,
        data: data.map(a=>a['日期'])
    },
    yAxis: {
        type: 'value',
        axisLabel:{formatter: '{value} 毫秒'}
    },
    series: Object.keys(data[0]).filter(a=>a!=='日期').map(k=>({
      name: k,
      type: 'line',
      stack: k,
      data: data.map(a=>a[k]),
    })),
})

const data=[
{
  "日期": "11-16",
  "Android": "758.03",
  "iOS": "872.21"
},
{
    "日期": "11-17",
    "Android": "761.54",
    "iOS": "878.91"
},
{
    "日期": "11-18",
    "Android": "763.22",
    "iOS": "871.78"
},
{
    "日期": "11-19",
    "Android": "771.16",
    "iOS": "888.15"
},
{
    "日期": "11-20",
    "Android": "741.59",
    "iOS": "847.57"
},
{
    "日期": "11-21",
    "Android": "734.98",
    "iOS": "832.24"
},
{
    "日期": "11-22",
    "Android": "749.53",
    "iOS": "821.18"
},
]



myChart.setOption(getopt('H5加载耗时概览(来源烛龙平台)', {}, data))

</script>
]]></content>
  </entry>
  <entry>
    <title>如何扩展 Create React App 的 Webpack 配置</title>
    <url>/2018/10/30/%E5%89%8D%E7%AB%AF/%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%20Create%20React%20App%20%E7%9A%84%20Webpack%20%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>其实我们可以通过以下几种方式来修改 webpack 的配置：</p>
<ul>
<li>项目 eject</li>
<li>替换 react-scripts 包</li>
<li>使用 react-app-rewired</li>
<li>scripts 包 + override 组合</li>
</ul>
<p><a href="https://blog.csdn.net/qq_22889599/article/details/79507721">如何扩展 Create React App 的 Webpack 配置</a></p>
<h3 id="How-to-rewire-your-create-react-app-project"><a href="#How-to-rewire-your-create-react-app-project" class="headerlink" title="How to rewire your create-react-app project"></a>How to rewire your create-react-app project</h3><h4 id="1-Install-react-app-rewired"><a href="#1-Install-react-app-rewired" class="headerlink" title="1) Install react-app-rewired"></a>1) Install react-app-rewired</h4><p><code>$ npm install react-app-rewired --save-dev</code></p>
<h4 id="2-Create-a-config-overrides-js-file-in-the-root-directory"><a href="#2-Create-a-config-overrides-js-file-in-the-root-directory" class="headerlink" title="2) Create a config-overrides.js file in the root directory"></a>2) Create a config-overrides.js file in the root directory</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* config-overrides.js */</span><br><span class="line"></span><br><span class="line">module.exports = function override(config, env) &#123;</span><br><span class="line">  //do stuff with the webpack config...</span><br><span class="line">  return config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-- your-project</span><br><span class="line">|   +-- config-overrides.js</span><br><span class="line">|   +-- node_modules</span><br><span class="line">|   +-- package.json</span><br><span class="line">|   +-- public</span><br><span class="line">|   +-- README.md</span><br><span class="line">|   +-- src</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-‘Flip’-the-existing-calls-to-react-scripts-in-npm-scripts"><a href="#3-‘Flip’-the-existing-calls-to-react-scripts-in-npm-scripts" class="headerlink" title="3) ‘Flip’ the existing calls to react-scripts in npm scripts"></a>3) ‘Flip’ the existing calls to react-scripts in npm scripts</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /* package.json */</span><br><span class="line"></span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">-   &quot;start&quot;: &quot;react-scripts start&quot;,</span><br><span class="line">+   &quot;start&quot;: &quot;react-app-rewired start&quot;,</span><br><span class="line">-   &quot;build&quot;: &quot;react-scripts build&quot;,</span><br><span class="line">+   &quot;build&quot;: &quot;react-app-rewired build&quot;,</span><br><span class="line">-   &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,</span><br><span class="line">+   &quot;test&quot;: &quot;react-app-rewired test --env=jsdom&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-Start-the-Dev-Server"><a href="#4-Start-the-Dev-Server" class="headerlink" title="4) Start the Dev Server"></a>4) Start the Dev Server</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm start</span><br></pre></td></tr></table></figure>
<h4 id="5-Build-your-app"><a href="#5-Build-your-app" class="headerlink" title="5) Build your app"></a>5) Build your app</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/timarney/react-app-rewired#3-flip-the-existing-calls-to-react-scripts-in-npm-scripts">react-app-rewired使用</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React webpack配置</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发点汇总</title>
    <url>/2021/12/06/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h4 id="学习网址"><a href="#学习网址" class="headerlink" title="学习网址"></a>学习网址</h4><p><a href="https://www.w3school.com.cn/tags/index.asp">标签地址</a><br><a href="https://www.runoob.com/css/css-tutorial.html">css地址</a><br><a href="http://es6.ruanyifeng.com/">ES6</a><br><a href="https://css-tricks.com/almanac/">CSS</a></p>
<h4 id="调试方式"><a href="#调试方式" class="headerlink" title="调试方式"></a>调试方式</h4><ul>
<li>debugger</li>
<li>console.log(data);</li>
<li>alert(‘HelloWorld’); 效果弹出弹窗</li>
</ul>
<h4 id="Position-定位"><a href="#Position-定位" class="headerlink" title="Position(定位)"></a>Position(定位)</h4><p><a href="https://www.runoob.com/css/css-positioning.html#position-fixed">Position(定位)</a>  </p>
<ul>
<li><strong>static</strong>  静态定位的元素不会受到 top, bottom, left, right影响。</li>
<li><strong>relative</strong> 相对定位元素的定位是相对其正常位置。</li>
<li><strong>fixed</strong> 元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动：</li>
<li><strong>absolute</strong>  绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>:</li>
<li><strong>sticky</strong> sticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。</li>
<li></li>
</ul>
<h4 id="float-浮动"><a href="#float-浮动" class="headerlink" title="float(浮动)"></a>float(浮动)</h4><p>创造的初衷：为了解决文字环绕效果。<br>元素的水平方向浮动，意味着元素只能左右移动而不能上下移动。</p>
<h4 id="Overflow"><a href="#Overflow" class="headerlink" title="Overflow"></a>Overflow</h4><p>CSS overflow 属性用于控制内容溢出元素框时显示的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">值	描述</span><br><span class="line">visible	默认值。内容不会被修剪，会呈现在元素框之外。</span><br><span class="line">hidden	内容会被修剪，并且其余内容是不可见的。</span><br><span class="line">scroll	内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</span><br><span class="line">auto	如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</span><br><span class="line">inherit	规定应该从父元素继承 overflow 属性的值。</span><br></pre></td></tr></table></figure>



<h4 id="margin-amp-amp-padding"><a href="#margin-amp-amp-padding" class="headerlink" title="margin &amp;&amp; padding"></a>margin &amp;&amp; padding</h4><p><strong>margin</strong>属性可以为给定元素设置所有四个（上下左右）方向的外边距属性。四个外边距属性设置分别是： margin-top， margin-right， margin-bottom 和 margin-left 。指定的外边距允许为负数。</p>
<p><strong>padding</strong>属性设置一个元素的内边距，padding 区域指一个元素的内容和其边界之间的空间，该属性不能为负值。四个外边距属性设置分别是： padding-top， padding-right， padding-bottom 和 padding-left</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5121882-30e290f0b1f0fd0a.png"></p>
<h4 id="SCSS-讲解"><a href="#SCSS-讲解" class="headerlink" title="SCSS 讲解"></a>SCSS 讲解</h4><p><a href="http://www.softwhy.com/article-3989-1.html">SCSS</a></p>
<h4 id="display-的-block，inline，inline-block"><a href="#display-的-block，inline，inline-block" class="headerlink" title="display 的 block，inline，inline-block"></a>display 的 block，inline，inline-block</h4><p><strong>block</strong>和<strong>inline</strong>这两个概念是简略的说法，完整确切的说应该是 <strong>block-level elements (块级元素)</strong> 和 **inline elements (内联元素)**。</p>
<h4 id="margin-bottom-和-bottom-区别"><a href="#margin-bottom-和-bottom-区别" class="headerlink" title="margin-bottom  和  bottom 区别"></a>margin-bottom  和  bottom 区别</h4><p>1、margin-bottom是设置外下边距的 而bottom是和pisition属性一起使用的 表示偏移量<br>2、margin是相对于块来移动 position是相对父即元素来移动</p>
<h4 id="Visual-Studio-Code-装饰器提示“experimentalDecorators”的解决办法"><a href="#Visual-Studio-Code-装饰器提示“experimentalDecorators”的解决办法" class="headerlink" title="Visual Studio Code 装饰器提示“experimentalDecorators”的解决办法"></a>Visual Studio Code 装饰器提示“experimentalDecorators”的解决办法</h4><p>表现形式：老是有文件夹、字段打红出现，虽然能编译通过但是看着不得劲啊。<br><a href="https://blog.csdn.net/yiifaa/article/details/78862507">Visual Studio Code 装饰器提示“experimentalDecorators”的解决办法</a></p>
<h4 id="CSS中的BFC详解"><a href="#CSS中的BFC详解" class="headerlink" title="CSS中的BFC详解"></a>CSS中的BFC详解</h4><p><strong>何为BFC</strong></p>
<p>BFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。  </p>
<p><a href="https://www.cnblogs.com/chen-cong/p/7862832.html">CSS中的BFC</a></p>
<p>碰到的真实问题：内容是float：left浮动布局 但是外面div高度确没有撑起来。<br>解决方案：外面的div 需要设置overflow：hidden。  </p>
<h4 id="react在html中调用方法"><a href="#react在html中调用方法" class="headerlink" title="react在html中调用方法"></a>react在html中调用方法</h4><p>直接 { this.eventName() }</p>
<h4 id="字符串和变量的拼装方法"><a href="#字符串和变量的拼装方法" class="headerlink" title="字符串和变量的拼装方法"></a>字符串和变量的拼装方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let arrayLength = this.storeSecKillAreaOffsetTopArray.length;</span><br><span class="line"></span><br><span class="line">let secKillAreaId = `SecKill$&#123;arrayLength&#125;` </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JS基础篇–JS获取元素的宽高以及offsetTop-offsetLeft等的属性值"><a href="#JS基础篇–JS获取元素的宽高以及offsetTop-offsetLeft等的属性值" class="headerlink" title="JS基础篇–JS获取元素的宽高以及offsetTop,offsetLeft等的属性值"></a>JS基础篇–JS获取元素的宽高以及offsetTop,offsetLeft等的属性值</h4><p><a href="https://segmentfault.com/a/1190000002879406">JS基础篇–JS获取元素的宽高以及offsetTop,offsetLeft等的属性值</a></p>
<h4 id="获取当前页面滚动条纵坐标的位置"><a href="#获取当前页面滚动条纵坐标的位置" class="headerlink" title="获取当前页面滚动条纵坐标的位置"></a>获取当前页面滚动条纵坐标的位置</h4><p>获取当前页面滚动条纵坐标的位置：document.body.scrollTop与document.documentElement.scrollTop<br>获取当前页面滚动条横坐标的位置：document.body.scrollLeft与document.documentElement.scrollLeft</p>
<p>各浏览器下获取scrollTop的差异</p>
<ul>
<li>IE6/7/8：可以使用 document.documentElement.scrollTop；</li>
<li>IE9及以上：可以使用window.pageYOffset或者document.documentElement.scrollTop</li>
<li>Safari：window.pageYOffset 与document.body.scrollTop都可以；</li>
<li>Firefox:：火狐等等相对标准些的浏览器就省心多了，直接用window.pageYOffset或者  document.documentElement.scrollTop；</li>
<li>Chrome：谷歌浏览器只认识document.body.scrollTop;</li>
</ul>
<h4 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h4><p>display属性设置一个元素应如何显示，是我们在前端开发中常常使用的一个属性，其中，最常见的有：display:none;表示此元素将不被显示。display：block;将元素显示为块元素。（又叫块级元素）display:inline;将元素显示为内联元素。（又叫行内元素）display:inline-block;将元素显示为内联块元素</p>
<h4 id="display-inline-block元素之间空隙的产生原因和解决办法"><a href="#display-inline-block元素之间空隙的产生原因和解决办法" class="headerlink" title="display:inline-block元素之间空隙的产生原因和解决办法"></a>display:inline-block元素之间空隙的产生原因和解决办法</h4><p><a href="https://blog.csdn.net/qq_32614411/article/details/82223624">display:inline-block元素之间空隙的产生原因和解决办法</a></p>
<h4 id="文本一行截断-和-省略号"><a href="#文本一行截断-和-省略号" class="headerlink" title="文本一行截断 和 省略号"></a>文本一行截断 和 省略号</h4><p>一行截断： <code>height: 28px; line-height: 28px; overflow: hidden;</code><br>省略号：  <code>overflow: hidden;text-overflow: ellipsis; white-space: nowrap;</code>  </p>
<h4 id="ES6之对象解构"><a href="#ES6之对象解构" class="headerlink" title="ES6之对象解构"></a>ES6之对象解构</h4><p><a href="https://blog.csdn.net/YU_M_K/article/details/80451024">ES6之对象解构</a><br>最基本的解构<br>在对象中提取某个字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  id: 123,</span><br><span class="line">  name: &#x27;hehe&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">const &#123;name&#125; = user;</span><br><span class="line">console.log(name); //prints: hehe</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解构并使用别名<br>有时接口定义的字段往往带有下划线，但我们的前端更便好于驼峰式命名，那么可以使用别名(rename)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  id: 123,</span><br><span class="line">  nick_name: &#x27;hehe&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">const &#123;nick_name: nickName&#125; = user;</span><br><span class="line">console.log(nickName); //prints: hehe</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令"></a>let 和 const 命令</h4><p><code>let</code>在let命令所在的代码块内有效.<br><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<h4 id="微信缓存问题"><a href="#微信缓存问题" class="headerlink" title="微信缓存问题"></a>微信缓存问题</h4><p><code>index.tpl.html 文件里 &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt;</code><br> <a href="https://www.cnblogs.com/cyy-13/p/7402458.html">path</a></p>
<h4 id="forEach和map的区别"><a href="#forEach和map的区别" class="headerlink" title="forEach和map的区别"></a>forEach和map的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相同之处</span><br><span class="line">var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;];</span><br><span class="line"></span><br><span class="line">arr.forEach(function(item,index,arr)&#123;　　　　//item表示数组中的每一项，index标识当前项的下标，arr表示当前数组</span><br><span class="line">    console.log(item);</span><br><span class="line">    console.log(index);</span><br><span class="line">    console.log(arr);</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;,123);　　　　　　//这里的123参数，表示函数中的this指向，可写可不写，如果不写，则this指向window</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr.map(function(item,index,arr)&#123;   //参数含义同forEach</span><br><span class="line">    console.log(item);</span><br><span class="line">    console.log(index);</span><br><span class="line">    console.log(arr);</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;,123);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">不同之处</span><br><span class="line"></span><br><span class="line">var a = arr.forEach(function(item,index,arr)&#123;　</span><br><span class="line">    return 123</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var b = arr.map(function(item,index,arr)&#123;</span><br><span class="line">    return 123</span><br><span class="line">&#125;);　</span><br><span class="line"></span><br><span class="line">console.log(a);    //undefined</span><br><span class="line">console.log(b);    //[123,123,123,123]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端开发点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>web页面打开APP</title>
    <url>/2018/06/11/%E5%89%8D%E7%AB%AF/%E7%94%A8%E4%BA%8E%E5%9C%A8safari%E8%B7%B3%E8%BD%AC%E5%88%B0APP%E7%9A%84web%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="在WXApp上设置一个URL-Schemes"><a href="#在WXApp上设置一个URL-Schemes" class="headerlink" title="在WXApp上设置一个URL Schemes"></a>在WXApp上设置一个URL Schemes</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了能让别的App(包括我们刚才创建的MyApp)能够打开 OpenTest，</span><br><span class="line">我们需要为app添加一个URL Schemes。</span><br><span class="line">步骤：选中app工程-&gt;Info-&gt;URL Types-&gt;点击“+”-&gt;在URL Schemes栏填上 OpenTest</span><br></pre></td></tr></table></figure>

<h3 id="打开APP-xxx-html"><a href="#打开APP-xxx-html" class="headerlink" title="打开APP  xxx.html"></a>打开APP  xxx.html</h3><blockquote>
<p>可以保存一下页面为.html 放在本地服务Document目录下 快速启动</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;HandheldFriendly&quot;</span> <span class="attr">content</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, user-scalable=no&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">open_win</span>(<span class="params"></span>) </span></span></span><br><span class="line"><span class="function"><span class="javascript">		</span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">window</span>.open(<span class="string">&quot;OpenTest&quot;</span>)</span></span><br><span class="line"><span class="javascript">		<span class="comment">// window.open(&quot;http://www.baidu.com&quot;)</span></span></span><br><span class="line"><span class="javascript">		&#125;</span></span><br><span class="line"><span class="javascript">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:100%;height: 100%;background: white; position: absolute;&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 方法一 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;margin-top:200px; width:100%;color:#666; font-size:32px; text-align: center ;display:inline-block;&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">href</span>=<span class="string">&quot;OpenTest&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>打开OpenTest App页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- OpenTest --&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 方法二跳转有点问题 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;input type=button </span></span><br><span class="line"><span class="comment">		style=&quot;width:250px; height=200px;&quot;</span></span><br><span class="line"><span class="comment">		size=&quot;60&quot;</span></span><br><span class="line"><span class="comment">		value=&quot;dsl open 打开&quot; onclick=&quot;open_win()&quot; /&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>web页面打开APP</tag>
      </tags>
  </entry>
  <entry>
    <title>如果某个端口已被占用 如何查看和关闭</title>
    <url>/2018/06/15/%E5%89%8D%E7%AB%AF/%E7%AB%AF%E5%8F%A3%E6%9F%A5%E7%9C%8B%E5%92%8C%E5%85%B3%E9%97%AD/</url>
    <content><![CDATA[<h2 id="如果某个端口已被占用-如何查看和关闭"><a href="#如果某个端口已被占用-如何查看和关闭" class="headerlink" title="如果某个端口已被占用 如何查看和关闭"></a>如果某个端口已被占用 如何查看和关闭</h2><p>查看：lsof -i :8081 </p>
<p>关闭：kill -9 <PID></p>
]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Intellij IDEA 创建Spring-Boot项目</title>
    <url>/2018/06/11/java/Intellij%20IDEA%20%E5%88%9B%E5%BB%BASpring-Boot%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="1-1-SpringBoot简介"><a href="#1-1-SpringBoot简介" class="headerlink" title="1.1 SpringBoot简介"></a>1.1 SpringBoot简介</h3><p>① 为所有Spring 开发提供一个更快更广泛的人门体验。</p>
<p>② 零配置。无冗余代码生成和XML 强制配置，遵循“约定大于配置” 。</p>
<p>③ 集成了大量常用的第三方库的配置， Spring Boot 应用为这些第三方库提供了几乎可以零配置的开箱即用的能力。</p>
<p>④）提供一系列大型项目常用的非功能性特征，如嵌入式服务器、安全性、度量、运行状况检查、外部化配置等。</p>
<h3 id="1-2-Spring-Boot-不是Spring-的替代者"><a href="#1-2-Spring-Boot-不是Spring-的替代者" class="headerlink" title="1.2 Spring Boot 不是Spring 的替代者"></a>1.2 Spring Boot 不是Spring 的替代者</h3><p>        Spring 框架是通过IOC 机制来管理Bean 的。Spring Boot 依赖Spring 框架来管理对象的依赖。</p>
<p>        Spring Boot 并不是Spring 的精简版本，而是为使用Spring 做好各种产品级准备。</p>
<p>        简单的说，平常我们开发一个项目就好比组装一台电脑主机，需要我们自己购买各式各样的配件，最后把它们组装在一起。而Spring Boot 就好比是厂商帮我们组装好的品牌机电脑，各种常用的配件都帮我们封装好了，并且提供了许多的接口，只要我们想增加某个配件，或者修改某个配件的版本，只要跟他讲一下名称，都不需要我们自己去购买，他就会把配件送上门并且帮你装好，用springboot就是这么轻松！</p>
<h3 id="1-3-Spring-Boot-2-新特性"><a href="#1-3-Spring-Boot-2-新特性" class="headerlink" title="1.3 Spring Boot 2 新特性"></a>1.3 Spring Boot 2 新特性</h3><p>    目前Spring Boot 已经开发到了2.0.2版本 ，而我们之后的项目案例也是基于springboot2来开发的。</p>
<p>    Spring Boot 2 基于最新的Java 8 和Spring Framework 5 ，这意味着Spring Boot 2 拥有构建现代应用的能力。</p>
<p>    ( 1 ）基于Java 8 的反射增强， Spring Framework 5.0 中的方法参数可以更加高效地进行访问。<br>    ( 2 ）接口提供基于Java 8 的默认方法构建的选择性声明。<br>    ( 3 ）支持候选组件索引作为类路径扫描的替代方案。<br>    ( 4 ）当然，最为重要的是， 此次Spring Framework 5.0 推出了新的响应式堆钱WEB 框架。  </p>
<p>相应地， Spring Boot 2 会集成最新的技术枝，包括Spring Data 、Spring Security 、Spring Integration 、Spring  AMQP, Spring Session 、Spring Batch 等都做了更新，其他的第三方依赖也会尝试使用最新的版本。</p>
<p>毫无疑问，Spring Boot  是一种趋势，同时我们在使用spring boot 的同时也在使用着其它新的技术框架。</p>
<p><a href="https://blog.csdn.net/u014296316/article/details/79382186">Intellij IDEA 创建Spring-Boot项目</a><br><a href="https://blog.csdn.net/zyhlwzy/article/details/78730587">使用Intellij IDEA创建SpringBoot项目</a><br><a href="https://blog.csdn.net/xwd718/article/details/80640357">基于SpringBoot开发一套完整的项目</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Spring-Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Web应用程序的推荐目录结构</title>
    <url>/2018/06/11/java/Java%20Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A8%E8%8D%90%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="Java-Web应用程序的推荐目录结构"><a href="#Java-Web应用程序的推荐目录结构" class="headerlink" title="Java Web应用程序的推荐目录结构"></a>Java Web应用程序的推荐目录结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── mygroup</span><br><span class="line">    │   │       ├── controller</span><br><span class="line">    │   │       │   ├── HomeController.java</span><br><span class="line">    │   │       │   └── PersonController.java</span><br><span class="line">    │   │       ├── dao</span><br><span class="line">    │   │       │   └── PersonDao.java</span><br><span class="line">    │   │       └── model</span><br><span class="line">    │   │           └── Person.java</span><br><span class="line">    │   ├── resources</span><br><span class="line">    │   │   ├── db.properties</span><br><span class="line">    │   │   ├── log4j.xml</span><br><span class="line">    │   │   └── META-INF</span><br><span class="line">    │   │       └── persistence.xml</span><br><span class="line">    │   └── webapp</span><br><span class="line">    │       ├── index.html</span><br><span class="line">    │       ├── META-INF</span><br><span class="line">    │       │   ├── context.xml</span><br><span class="line">    │       │   └── MANIFEST.MF</span><br><span class="line">    │       ├── resources</span><br><span class="line">    │       │   └── css</span><br><span class="line">    │       │       └── screen.css</span><br><span class="line">    │       └── WEB-INF</span><br><span class="line">    │           ├── spring</span><br><span class="line">    │           │   ├── app</span><br><span class="line">    │           │   │   ├── controllers.xml</span><br><span class="line">    │           │   │   └── servlet-context.xml</span><br><span class="line">    │           │   ├── db.xml</span><br><span class="line">    │           │   └── root-context.xml</span><br><span class="line">    │           ├── views</span><br><span class="line">    │           │   ├── edit.jsp</span><br><span class="line">    │           │   ├── home.jsp</span><br><span class="line">    │           │   └── list.jsp</span><br><span class="line">    │           └── web.xml</span><br><span class="line">    └── test</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── mygroup</span><br><span class="line">        │       ├── controller</span><br><span class="line">        │       │   ├── DataInitializer.java</span><br><span class="line">        │       │   ├── HomeControllerTest.java</span><br><span class="line">        │       │   └── PersonControllerTest.java</span><br><span class="line">        │       └── dao</span><br><span class="line">        │           └── PersonDaoTest.java</span><br><span class="line">        └── resources</span><br><span class="line">            ├── db.properties</span><br><span class="line">            ├── log4j.xml</span><br><span class="line">            ├── test-context.xml</span><br><span class="line">            └── test-db.xml</span><br></pre></td></tr></table></figure>


<p><a href="https://www.cnblogs.com/yudy/archive/2012/06/26/2563638.html">Java Web应用程序的推荐目录结构</a><br><a href="https://www.cnblogs.com/scown/p/5561677.html">Java Web 项目目录规范</a><br><a href="https://blog.csdn.net/qq_28018283/article/details/79398661">用IntelliJ idea 创建 springMVC 的Maven 项目</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java Web应用程序的推荐目录结构</tag>
      </tags>
  </entry>
  <entry>
    <title>java-spring</title>
    <url>/2018/06/11/java/java-spring/</url>
    <content><![CDATA[<h2 id="spring框架"><a href="#spring框架" class="headerlink" title="spring框架"></a>spring框架</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，</span><br><span class="line">因此它将面向接口的编程思想贯穿整个系统应用。</span><br><span class="line">Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson创建。</span><br><span class="line">简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。</span><br></pre></td></tr></table></figure>

<h2 id="下载和安装Spring请按如下步骤进行。"><a href="#下载和安装Spring请按如下步骤进行。" class="headerlink" title="下载和安装Spring请按如下步骤进行。"></a>下载和安装Spring请按如下步骤进行。</h2><p>（1）登录站点，下载Spring的最新稳定版本。最新版本为spring-framework-5.0.建议下载spring-framework-spring-framework-4.0.0.M2-dist这个压缩包不仅包含Spring的开发包，而且包含Spring编译和运行所依赖的第三方类库。<br>解压缩下载到的压缩包，解压缩后的文件夹应用如下几个文件夹。<br>dist：该文件夹下放Spring的jar包，通常只需要Spring.jar文件即可。该文件夹下还有一些类似spring－Xxx.jar的压缩包， 这些压缩包是spring.jar压缩包的子模块压缩包。除非确定整个J2EE应用只需要使用Spring的某一方面时，才考虑使用这种分模块压缩包。通常建议使用Spring.jar<br>docs：该文件夹下包含spring的相关文档、开发指南及API参考文档。<br>lib：该文件夹下包含spring编译和运行所依赖的第三方类库，该路径下的类库并不是  spring必需的，但如果需要使用第三方类库的支持，这里的类库就是必需要的。<br>samples：该文件夹下包含Spring的几个简单例子，可作为Spring入门学习的案例。<br>src：该文件夹下包含Spring的全部源文件，如果开发过程中有地方无法把握，可以参考该源文件，了解底层实现。<br>spring<br>spring<br>test：该文件夹下包含Spring的测试示例。<br>tiger：该路径下存放关于JDK的相关内容<br>解压缩后的文件夹下，还包含一些关于Spring的License和项目相关文件<br>（2）将spring.jar复制到项目的CLASSPATH路径下，对于Web应用，将spring.jar文件复制到WEB-INF/lib路径下，该应用即可以利用Spring框架了。<br>（3）通常Spring的框架还依赖于其他一些jar文件，因此还须将lib下对应的包复制到WEB-INF/lib路径下，具体要复制哪些jar文件，取决于应用所需要使用的项目。通常需要复制cglib，dom4j，jakarta-commons，log4j等文件夹下的jar文件。<br>（4）为了编译java文件，可以找到Spring的基础类，将Spring.jar文件的路径添加到环境变量CLASSPATH中。当然，也可以使用ANT工具，但无须添加环境变量。如果使用Eclipse或者NetBeans等IDE时，也不需要设置环境变量。  </p>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p>传统的web架构的view 表现层使用struts作为表现层。但是如果试用下spring自带的MVC，会发现spring 在一般场合完全可以取代struts。从某些角度来说，spring的mvc设计的更加合理，有兴趣的话不妨尝试下单个的spring的MVC。</p>
<p><a href="https://www.w3cschool.cn/wkspring/">w3Cschool-spring学习</a></p>
<h2 id="Spring-Boot-是什么？"><a href="#Spring-Boot-是什么？" class="headerlink" title="Spring Boot 是什么？"></a>Spring Boot 是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring Boot 的目的是提供一组工具，以便快速构建容易配置的 Spring 应用程序。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>java 基础</title>
    <url>/2018/06/11/java/java%E5%9F%BA%E7%A1%80%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot</title>
    <url>/2018/06/11/java/springboot/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1FJ41197rF?p=36">SpringBoot核心技术篇</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、大量的XML让开发者厌恶,因此Spring提供了许多注解来完成各种功能。</span><br><span class="line">2、大量的注解让开发者厌恶 ,因此Spring提供了组合注解来完成各种功能。</span><br></pre></td></tr></table></figure>

<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker是一个开源的应用容器引擎。</p>
<h2 id="Spring-Boot与数据访问"><a href="#Spring-Boot与数据访问" class="headerlink" title="Spring Boot与数据访问"></a>Spring Boot与数据访问</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring注解</title>
    <url>/2018/06/11/java/spring%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、大量的XML让开发者厌恶,因此Spring提供了许多注解来完成各种功能。</span><br><span class="line">2、大量的注解让开发者厌恶 ,因此Spring提供了组合注解来完成各种功能。</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Boot-注解的意义以及作用"><a href="#Spring-Boot-注解的意义以及作用" class="headerlink" title="Spring Boot 注解的意义以及作用"></a>Spring Boot 注解的意义以及作用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用注解：隐式配置，例如：@Autowired、@Bean、@Component等，通过注解来简化xml文件。</span><br><span class="line"></span><br><span class="line">利用Java文件：显示配置，比xml配置的优势是具备类型安全。</span><br><span class="line"></span><br><span class="line">利用传统的xml配置文件。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注解(annotations)列表</p>
<p>@ResponseBody </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用该注解修饰的函数，会将结果直接填充到HTTP的响应体中，一般用于构建RESTful的api；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>@Controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层）。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>@RestController</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ResponseBody和@Controller的合集</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>@RequestMapping</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提供路由信息，负责URL到Controller中的具体函数的映射。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/m0_37995707/article/details/77447764">更多注解详看</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客框架</title>
    <url>/2018/06/11/other/Hexo/</url>
    <content><![CDATA[<h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^0.1.0&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^0.1.0&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^0.1.0&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^0.1.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^0.1.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^0.2.4&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^0.1.2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration.html">配置</a> 信息，您可以在此配置大部分的参数。</p>
<h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p> 主题 文件夹。Hexo 会根据主题来生成静态页面。</p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>
<h3 id="重要的几个指令"><a href="#重要的几个指令" class="headerlink" title="重要的几个指令"></a>重要的几个指令</h3><p>了解更多 详见<a href="https://hexo.io/zh-cn/docs/commands.html#deploy">指令</a> 信息</p>
<blockquote>
<p>初始化新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo init [folder]  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>server 启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<blockquote>
<p>generate 生成静态文件。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<blockquote>
<p>deploy 部署网站。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<blockquote>
<p>clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<h3 id="资源文件夹"><a href="#资源文件夹" class="headerlink" title="资源文件夹"></a>资源文件夹</h3><blockquote>
<p>资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](/images/image.jpg) </span><br></pre></td></tr></table></figure>
<blockquote>
<p>的方法访问它们。</p>
</blockquote>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><blockquote>
<p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。详见<a href="https://hexo.io/zh-cn/docs/deployment.html">网站</a> 信息</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>博客框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客框架添加搜索</title>
    <url>/2018/06/11/other/Hexo%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>用Hexo提供的<code>Local Search</code>,原理是通过<code>hexo-generator-search</code>插件在本地生成一个<code>search.xml</code>文件，搜索的时候从这个文件中根据关键字检索出相应的链接。</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h5 id="安装-hexo-generator-search"><a href="#安装-hexo-generator-search" class="headerlink" title="安装 hexo-generator-search"></a>安装 hexo-generator-search</h5><p>在站点的根目录下执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>

<h5 id="安装-hexo-generator-searchdb"><a href="#安装-hexo-generator-searchdb" class="headerlink" title="安装 hexo-generator-searchdb"></a>安装 hexo-generator-searchdb</h5><p>在站点的根目录下执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>启用搜索</p>
<p>编辑 站点配置文件<code>_config.yml</code>，新增以下内容到任意位置：</p>
<pre><code>search:
  path: search.xml
  field: post
  format: html
  limit: 10000
</code></pre>
<p>修改主题配置文件</p>
<p>我的路径：<code>/blog/themes/next</code>下的<code>_config.yml</code>文件，进行编辑。</p>
<pre><code>local_search:
    enable: true
</code></pre>
<p>最后部署到github、coding，打开网页就可以看到搜索功能了。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>博客框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac端本地服务搭建</title>
    <url>/2018/06/11/other/Mac%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="方案名称"><a href="#方案名称" class="headerlink" title="方案名称"></a>方案名称</h3><p>Mac 系统 - 启用 Mac 本地 Web 服务器<br>关键字</p>
<p>Mac 系统 \ Web 服务器</p>
<h3 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h3><ol>
<li><p>局域网搭建 Web 服务器测试环境<br>参考链接</p>
</li>
<li><p>简书 - Mac OS X 启用 Web 服务器(推荐)<br>详细内容 <a href="https://www.jianshu.com/p/d006a34a343f">https://www.jianshu.com/p/d006a34a343f</a></p>
</li>
</ol>
<h3 id="启动-Apache"><a href="#启动-Apache" class="headerlink" title="启动 Apache"></a>启动 Apache</h3><p>终端输入<br>$ sudo apachectl start<br>可启动 Apache，打开浏览器，输入 <a href="http://localhost/">http://localhost/</a> 看到如下页面证明本地 Web 服务器启动成功</p>
<p>可启动 Apache，默认站点的根目录为系统级根目录<br>/Library/WebServer/Documents<br>更多信息，可参考 简书 - Mac OS X 启用 Web 服务器(推荐)</p>
<ul>
<li>创建用户级根目录</li>
<li>启动 PHP</li>
<li>安装 MySQL</li>
<li>开启 HTTPS</li>
</ul>
<p><a href="https://github.com/viktyz/iosnotebook/blob/master/Notes/Note_00222_20170601.md">https://github.com/viktyz/iosnotebook/blob/master/Notes/Note_00222_20170601.md</a></p>
<h3 id="关闭和重启"><a href="#关闭和重启" class="headerlink" title="关闭和重启"></a>关闭和重启</h3><p>Mac OS 终端起动、关闭、重启apache的方</p>
<p>Mac OS 终端起动、关闭、重启apache的方法</p>
<p>打开终端<br>重启apache：sudo /usr/sbin/apachectl restart<br>关闭apache：sudo /usr/sbin/apachectl stop<br>开启apache：sudo /usr/sbin/apachectl start</p>
<h3 id="Mac下如何修改apache根目录"><a href="#Mac下如何修改apache根目录" class="headerlink" title="Mac下如何修改apache根目录"></a>Mac下如何修改apache根目录</h3><p><a href="https://www.cnblogs.com/chuangshaogreat/p/7821407.html">Mac下如何修改apache根目录</a> </p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>启动本地服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 编辑器语法指南</title>
    <url>/2018/06/11/other/Markdown/</url>
    <content><![CDATA[<p><a href="https://segmentfault.com/markdown/">Markdown 编辑器语法指南</a></p>
<p><a href="http://macdown.uranusjr.com/">MacDown</a></p>
<h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>如果你只想高亮语句中的某个函数名或关键字，可以使用 <code>function_name()</code> 实现<br>通常编辑器根据代码片段适配合适的高亮方法，但你也可以用 以下方式 包裹一段代码，并指定一种语言</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<p>支持的语言：1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir</p>
<h2 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span> Markdown 在此处同样适用，如 <span class="emphasis">*加粗*</span> <span class="xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 列表文本前使用 [减号+空格]</span><br><span class="line"><span class="bullet">+</span> 列表文本前使用 [加号+空格]</span><br><span class="line"><span class="bullet">*</span> 列表文本前使用 [星号+空格]</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 引用文本前使用 [大于号+空格]</span></span><br><span class="line"><span class="quote">&gt; 折行可以不加，新起一行都要加上哦</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; &gt; 最外层引用</span></span><br><span class="line"><span class="quote">&gt; &gt; 多一个 &gt; 嵌套一层引用</span></span><br><span class="line"><span class="quote">&gt; &gt; &gt; 可以嵌套很多层</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![<span class="string">图片名称</span>](<span class="link">http://图片网址</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><hr>
<p>如果你有写分割线的习惯，可以新起一行输入三个减号-。前后都有段落时，请空出一行：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">前面的段落</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">后面的段落</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>md</tag>
      </tags>
  </entry>
  <entry>
    <title>OmniGraffle 五步绘制流程图</title>
    <url>/2018/06/11/other/OmniGraffle%20%E4%BA%94%E6%AD%A5%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/cca7ce55aee1">OmniGraffle 五步绘制流程图</a></p>
<p><a href="https://sspai.com/post/41950">OmniGraffle 基础入门（一）：从工具栏开始</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>OmniGraffle</tag>
      </tags>
  </entry>
  <entry>
    <title>docsify</title>
    <url>/2018/06/11/other/docsify%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="使用前操作"><a href="#使用前操作" class="headerlink" title="使用前操作"></a>使用前操作</h4><ul>
<li>安装<br><code>npm i docsify-cli -g</code></li>
<li>然后创建目录<br>首先在 Desktop 创建一个文件夹：cloud-doc<br>cd 到当前目录</li>
<li>初始化项目</li>
</ul>
<p>如果想在项目的 ./docs 目录里写文档，直接通过 init 初始化项目。<br>docsify init ./docs</p>
<ul>
<li>启动服务 （默认3000端口号）可以修改<br><code>docsify serve docs</code>  <code>docsify serve docs -p 4001</code></li>
</ul>
<p><a href="https://www.jianshu.com/p/cfd0d4009cff">docsify（和 gitbook 一样的好东西)</a><br><a href="https://www.jianshu.com/p/62405ab3c186">docsify轻量级文档系统</a><br><a href="https://docsify.js.org/#/zh-cn/">中文文档</a><br><a href="https://github.com/docsifyjs/docsify/">docsify项目地址</a></p>
<h4 id="内网搭建"><a href="#内网搭建" class="headerlink" title="内网搭建"></a>内网搭建</h4><p><a href="https://www.jianshu.com/p/56b8a31bbcbb">Docsify文档管理平台 内网搭建</a></p>
<h4 id="优秀使用者"><a href="#优秀使用者" class="headerlink" title="优秀使用者"></a>优秀使用者</h4><p><a href="https://doc.xiaoz.me/#/">小z博客文档管理系统</a><br><a href="https://mao.sh/archives/122.html">使用docsify快速生成在线文档</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docsify</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat</title>
    <url>/2018/06/11/other/tomcat%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u012661010/article/details/73381599">Tomcat的目录结构详细介绍</a></p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>切换到<code>tomcat</code>所在的目录在终端执行如下命令：<br><code>bash bin/startup.sh</code> 用来启动<code>tomcat</code> </p>
<p>然后直接<code>localhost:8080/</code> 就可以访问了</p>
<h4 id="文件放置"><a href="#文件放置" class="headerlink" title="文件放置"></a>文件放置</h4><p>webapps目录用来存放应用程序，当tomcat启动时会去加载webapps目录下的应用程序。可以以文件夹、war包、jar包的形式发布应用</p>
<h4 id="修改http访问端口（默认为8080端口），将8080修改为tomcat不在使用的端口号"><a href="#修改http访问端口（默认为8080端口），将8080修改为tomcat不在使用的端口号" class="headerlink" title="修改http访问端口（默认为8080端口），将8080修改为tomcat不在使用的端口号"></a>修改http访问端口（默认为8080端口），将8080修改为tomcat不在使用的端口号</h4><p>1、安装目录下的<code>conf</code>子目录中的<code>server.xml</code>文件 修改位置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">           connectionTimeout=&quot;20000&quot;</span><br><span class="line">           redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>2、然后在关闭和重启操作</p>
<p><code>bash bin/shutdown.sh</code> 用来关闭<code>tomcat</code><br><code>bash bin/startup.sh</code> 用来启动<code>tomcat</code> </p>
<h4 id="启动tomcat-服务报-The-file-is-absent-or-does-not-have-execute-permission"><a href="#启动tomcat-服务报-The-file-is-absent-or-does-not-have-execute-permission" class="headerlink" title="启动tomcat 服务报 The file is absent or does not have execute permission"></a>启动tomcat 服务报 The file is absent or does not have execute permission</h4><p>1、在<code>linu</code>上部署好<code>tomcat</code>后，准备启动时报错：</p>
<p>Cannot find bin/catalina.sh<br>The file is absent or does not have execute permission </p>
<p>This file is needed to run this program </p>
<p>2、解决办法：</p>
<p>对启动脚本添加执行权限</p>
<p><code>chmod 777  *.sh</code></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>vim修改的撤销、重做和保存</title>
    <url>/2018/06/11/other/vim%E4%BF%AE%E6%94%B9%E7%9A%84%E6%92%A4%E9%94%80%E3%80%81%E9%87%8D%E5%81%9A%E5%92%8C%E4%BF%9D%E5%AD%98/</url>
    <content><![CDATA[<h4 id="vim修改的撤销、重做和保存"><a href="#vim修改的撤销、重做和保存" class="headerlink" title="vim修改的撤销、重做和保存"></a>vim修改的撤销、重做和保存</h4><ul>
<li><p>u:撤销上一步的操作</p>
</li>
<li><p>ctrl+r：将原来的撤销重做一遍</p>
</li>
<li><p>U：恢复一整行原来的面貌（文本打开时的状态）</p>
</li>
<li><p>:wq 保存退出</p>
</li>
<li><p>:e!  放弃修改，重新回到文件打开时的状态</p>
</li>
</ul>
<h4 id="linux命令中-wq和-wq！区别"><a href="#linux命令中-wq和-wq！区别" class="headerlink" title="linux命令中:wq和:wq！区别"></a>linux命令中:wq和:wq！区别</h4><ul>
<li>首先使用esc(键退出)-&gt;:(符号输入)-&gt;wq(保存退出)</li>
<li>:wq(保存编辑操作退出)</li>
<li>:wq!(保存编辑强制退出)</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim修改的撤销、重做和保存</tag>
      </tags>
  </entry>
  <entry>
    <title>办公软件的使用</title>
    <url>/2018/06/11/other/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="矢量图素材"><a href="#矢量图素材" class="headerlink" title="矢量图素材"></a>矢量图素材</h4><p><a href="https://www.iconfont.cn/?spm=a313x.7781069.1998910419.d4d0a486a">www.iconfont.cn 图片库</a></p>
<h4 id="PPT模板库"><a href="#PPT模板库" class="headerlink" title="PPT模板库"></a>PPT模板库</h4><p><a href="https://www.free-powerpoint-templates-design.com/clean-energy-powerpoint-templates/">free-powerpoint-templates-design 需要vpn</a> </p>
<h4 id="扁平颜色"><a href="#扁平颜色" class="headerlink" title="扁平颜色"></a>扁平颜色</h4><p><a href="https://flatuicolors.com/">扁平颜色</a> </p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>办公软件的使用</tag>
      </tags>
  </entry>
  <entry>
    <title>终极 Shell</title>
    <url>/2018/06/11/other/%E7%BB%88%E6%9E%81%20Shell/</url>
    <content><![CDATA[<h3 id="方案名称"><a href="#方案名称" class="headerlink" title="方案名称"></a>方案名称</h3><p>在开始今天的 MacTalk 之前，先问两个问题吧：<br>来自：<a href="https://zhuanlan.zhihu.com/p/19556676?columnSlug=mactalk">https://zhuanlan.zhihu.com/p/19556676?columnSlug=mactalk</a></p>
<blockquote>
<p>相对于其他系统，Mac 的主要优势是什么？<br>你们平时用哪种 Shell？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">第一个童靴可以坐下了，Mac 的最大优势是 GUI 和命令行的完美结合，不要把所有注意力放在 Mac 性感的腰身和明媚的显示屏上好吧，这不是妹纸！第二个童靴你可以出去面壁了，讲了这么多期 MacTalk 你告诉我还在用 Windows 的 cmd， 你让 Mac 君情何以堪？哪怕你就说在用 Linux 的 Bash 我也就原谅你了，踢飞！</span><br><span class="line">上次在「如何学习一门编程语言」里提到了 Shell，也有读者问到 Shell 的问题，所以这次给大家说说 Shell 的事。</span><br><span class="line">我在「趣谈个人建站」里介绍过一点 Shell，自己的东西借用下不丢人，把扯淡的拿掉，干货留下，就是如下内容：</span><br><span class="line">Shell是Linux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。</span><br><span class="line">Linux/Unix提供了很多种Shell，为毛要这么多Shell？难道用来炒着吃么？那我问你，你同类型的衣服怎么有那么多件？花色，质地还不一样。写程序比买衣服复杂多了，而且程序员往往负责把复杂的事情搞简单，简单的事情搞复杂。牛程序员看到不爽的Shell，就会自己重新写一套，慢慢形成了一些标准，常用的Shell有这么几种，sh、bash、csh等，想知道你的系统有几种shell，可以通过以下命令查看：</span><br><span class="line">cat /etc/shells</span><br><span class="line">显示如下：</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br><span class="line">在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh，这是个神马 Shell 呢？</span><br><span class="line">目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：https://github.com/robbyrussell/oh-my-zsh。这玩意就像「X天叫你学会 C++」系列，可以让你神功速成，而且是真的。</span><br><span class="line">好，下面我们看看如何安装、配置和使用 zsh。</span><br><span class="line">安装zsh</span><br><span class="line">如果你用 Mac，就可以直接看下一节</span><br><span class="line">如果你用 Redhat Linux，执行：sudo yum install zsh</span><br><span class="line">如果你用 Ubuntu Linux，执行：sudo apt-get install zsh</span><br><span class="line">如果你用 Windows……去洗洗睡吧。</span><br><span class="line">安装完成后设置当前用户使用 zsh：chsh -s /bin/zsh，根据提示输入当前用户的密码就可以了。</span><br><span class="line">安装oh my zsh</span><br><span class="line">首先安装 git，安装方式同上，把 zsh 换成 git 即可。</span><br><span class="line">安装「oh my zsh」可以自动安装也可以手动安装。</span><br><span class="line">自动安装：</span><br><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br><span class="line">手动安装：</span><br><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br><span class="line">都不复杂，安装完成之后退出当前会话重新打开一个终端窗口，你就可以见到这个彩色的提示了：</span><br><span class="line"></span><br><span class="line">配置</span><br><span class="line">zsh 的配置主要集中在用户当前目录的.zshrc里，用 vim 或你喜欢的其他编辑器打开.zshrc，在最下面会发现这么一行字：</span><br></pre></td></tr></table></figure>
<h2 id="Customize-to-your-needs…"><a href="#Customize-to-your-needs…" class="headerlink" title="Customize to your needs…"></a>Customize to your needs…</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以在此处定义自己的环境变量和别名，当然，oh my zsh 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量。</span><br><span class="line">接下来进行别名的设置，我自己的部分配置如下：</span><br><span class="line">alias cls=&#x27;clear&#x27;</span><br><span class="line">alias ll=&#x27;ls -l&#x27;</span><br><span class="line">alias la=&#x27;ls -a&#x27;</span><br><span class="line">alias vi=&#x27;vim&#x27;</span><br><span class="line">alias javac=&quot;javac -J-Dfile.encoding=utf8&quot;</span><br><span class="line">alias grep=&quot;grep --color=auto&quot;</span><br><span class="line">alias -s html=mate   # 在命令行直接输入后缀为 html 的文件名，会在 TextMate 中打开</span><br><span class="line">alias -s rb=mate     # 在命令行直接输入 ruby 文件，会在 TextMate 中打开</span><br><span class="line">alias -s py=vi       # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似</span><br><span class="line">alias -s js=vi</span><br><span class="line">alias -s c=vi</span><br><span class="line">alias -s java=vi</span><br><span class="line">alias -s txt=vi</span><br><span class="line">alias -s gz=&#x27;tar -xzvf&#x27;</span><br><span class="line">alias -s tgz=&#x27;tar -xzvf&#x27;</span><br><span class="line">alias -s zip=&#x27;unzip&#x27;</span><br><span class="line">alias -s bz2=&#x27;tar -xjvf&#x27;</span><br><span class="line">zsh 的牛粪之处在于不仅可以设置通用别名，还能针对文件类型设置对应的打开程序，比如：</span><br><span class="line">alias -s html=mate，意思就是你在命令行输入 hello.html，zsh会为你自动打开 TextMat 并读取 hello.html； alias -s gz=&#x27;tar -xzvf&#x27;，表示自动解压后缀为 gz 的压缩包。</span><br><span class="line">总之，只有想不到，木有做不到。</span><br><span class="line">设置完环境变量和别名之后，基本上就可以用了，如果你是个主题控，还可以玩玩 zsh 的主题。在 .zshrc 里找到ZSH_THEME，就可以设置主题了，默认主题是：</span><br><span class="line">ZSH_THEME=”robbyrussell”</span><br><span class="line">oh my zsh 提供了数十种主题，相关文件在~/.oh-my-zsh/themes目录下，你可以随意选择，也可以编辑主题满足自己的变态需求，我采用了默认主题robbyrussell，不过做了一点小小的改动：</span><br><span class="line">PROMPT=&#x27;%&#123;$fg_bold[red]%&#125;➜ %&#123;$fg_bold[green]%&#125;%p%&#123;$fg[cyan]%&#125;%d %&#123;$fg_bold[blue]%&#125;$(git_prompt_info)%&#123;$fg_bold[blue]%&#125;% %&#123;$reset_color%&#125;&gt;&#x27;</span><br><span class="line">#PROMPT=&#x27;%&#123;$fg_bold[red]%&#125;➜ %&#123;$fg_bold[green]%&#125;%p %&#123;$fg[cyan]%&#125;%c %&#123;$fg_bold[blue]%&#125;$(git_prompt_info)%&#123;$fg_bold[blue]%&#125; % %&#123;$reset_color%&#125;&#x27;</span><br><span class="line">对照原来的版本，我把 c 改为 d，c 表示当前目录，d 表示绝对路径，另外在末尾增加了一个「 &gt; 」，改完之后的效果是这样的：</span><br><span class="line">大家可以尝试进行改造，也算个趣事。</span><br><span class="line">最后我们来说说插件。</span><br></pre></td></tr></table></figure>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>oh my zsh 项目提供了完善的插件体系，相关的文件在~/.oh-my-zsh/plugins目录下，默认提供了100多种，大家可以根据自己的实际学习和工作环境采用，想了解每个插件的功能，只要打开相关目录下的 zsh 文件看一下就知道了。插件也是在.zshrc里配置，找到plugins关键字，你就可以加载自己的插件了，系统默认加载 git ，你可以在后面追加内容，如下：<br>plugins=(git textmate ruby autojump osx mvn gradle)<br>下面简单介绍几个：</p>
<ol>
<li>git：当你处于一个 git 受控的目录下时，Shell 会明确显示 「git」和 branch，如上图所示，另外对 git 很多命令进行了简化，例如 gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’等等，熟练使用可以大大减少 git 的命令长度，命令内容可以参考~/.oh-my-zsh/plugins/git/git.plugin.zsh</li>
<li>textmate：mr可以创建 ruby 的框架项目，tm finename 可以用 textmate 打开指定文件。</li>
<li>osx：tab 增强，quick-look filename 可以直接预览文件，man-preview grep 可以生成 grep手册 的pdf 版本等。</li>
<li>autojump：zsh 和 autojump 的组合形成了 zsh 下最强悍的插件，今天我们主要说说这货。</li>
</ol>

<p>首先安装autojump，如果你用 Mac，可以使用 brew 安装：<br>brew install autojump<br>如果是 Linux，去下载 autojump 的最新版本，比如：<br>wget <a href="https://github.com/downloads/joelthelion/autojump/autojump_v21.1.2.tar.gz">https://github.com/downloads/joelthelion/autojump/autojump_v21.1.2.tar.gz</a><br>解压缩后进入目录，执行<br>./install.sh<br>最后把以下代码加入.zshrc：<br>[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh<br>至此，安装、配置、插件三位一体，终极 Shell 全面登场。退出终端会话重新登录，开始感受 zsh 的训疾如风！</p>
<h2 id="使用-zsh"><a href="#使用-zsh" class="headerlink" title="使用 zsh"></a>使用 zsh</h2><ol>
<li>兼容 bash，原来使用 bash 的兄弟切换过来毫无压力，该咋用咋用。</li>
<li>强大的历史纪录功能，输入 grep 然后用上下箭头可以翻阅你执行的所有 grep 命令。</li>
<li>智能拼写纠正，输入gtep mactalk * -R，系统会提示：zsh: correct ‘gtep’ to ‘grep’ [nyae]? 比妹纸贴心吧，她们向来都是让你猜的……</li>
<li>各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下 tab 键，补全项可以使用 ctrl+n/p/f/b上下左右切换。比如你想杀掉 java 的进程，只需要输入 kill java + tab键，如果只有一个 java 进程，zsh 会自动替换为进程的 pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个tab键，zsh会列出所有访问过的主机和用户名进行补全</li>
<li>智能跳转，安装了autojump之后，zsh 会自动记录你访问过的目录，通过 j + 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过hadoop-1.0.0目录，输入j hado 即可正确跳转。j –stat 可以看你的历史路径库。</li>
<li>目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。</li>
<li>在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。</li>
<li>通配符搜索：ls -l **/*.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find，文件太多就歇菜了。</li>
<li>更强的别名：请参考配置一节。</li>
<li>插件支持：请参考插件一节。</li>
</ol>

<p>看完这篇文章，你就知道，zsh一出，无人再与争锋！终极二字不是盖的。<br>如果你是个正在使用 shell程序员，如果你依然准备使用 bash，那就去面壁和忏悔吧，别说你订阅过 MacTalk！<br>感谢那位开发了 oh my zsh 的无聊程序员，他可能没有因此收获物质上的利益，但是他的代码提升了无数程序员的效率，节省了大量的时间，我们说，程序员改变世界！<br>MacTalk 写的多了，朋友和家人都不太理解，这玩意赚不了钱争不了名，写来何用？我想，能够学习、编码、写作，并做出一点帮助别人的东西，总好过炒股炒房的价值吧……
 </p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>统一建模语言UML</title>
    <url>/2018/06/11/other/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>UML系统开发中有三个主要的模型：</p>
<ul>
<li>功能模型：从用户的角度展示系统的功能，包括用例图。 </li>
<li>对象模型：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类别图、对象图。</li>
<li>动态模型：展现系统的内部行为。包括序列图，活动图，状态图。 </li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>统一建模语言</tag>
      </tags>
  </entry>
  <entry>
    <title>二十四节气</title>
    <url>/2018/06/11/%E6%88%91%E7%9A%84%E6%97%A5%E5%B8%B8%E5%85%B4%E8%B6%A3/%E4%B8%AD%E5%9B%BD%E8%8A%82%E6%B0%94/</url>
    <content><![CDATA[<h2 id="二十四节气"><a href="#二十四节气" class="headerlink" title="二十四节气"></a>二十四节气</h2><p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=5157a451be096b63951456026d5aec21/b03533fa828ba61ef3c2ab514134970a304e599b.jpg" alt="二十四节气"></p>
<p>二十四节气是根据地球在黄道（即地球绕太阳公转的轨道）上的位置来划分的。视太阳从春分点（黄经零度，此刻太阳垂直照射赤道）出发，每前进15度为一个节气；运行一周又回到春分点，为一回归年，合360度，因此分为24个节气。</p>
<h2 id="节与气"><a href="#节与气" class="headerlink" title="节与气"></a>节与气</h2><p>一年有二十四个节气，计十二个节和十二个气。即一个月之内有一节一气，每两节气相距，平均约三十天又十分之四，而阴历每月之日数．则为二十九天半，故约每三十四个月，必遇有两月仅有节而无气、及有气而无节者。有节无气之月，即农历之闰月，有气无节之月不为闰月，兹将节气与农历月份关系表列于后：</p>
<h3 id="季月节气表"><a href="#季月节气表" class="headerlink" title="季月节气表"></a>季月节气表</h3><table log-set-param="table_view" data-sort="sortDisabled"><tbody><tr><th height="37">季</th><th height="37" colspan="3"><div class="para" label-module="para">春</div>
</th><th height="37" colspan="3">夏</th><th height="37" colspan="3">秋</th><th height="37" colspan="3"><div class="para" label-module="para">冬</div>
</th></tr><tr><td valign="top">月</td><td valign="top">正月</td><td valign="top">二月</td><td valign="top">三月</td><td valign="top">四月</td><td valign="top">五月</td><td valign="top">六月</td><td valign="top">七月</td><td valign="top">八月</td><td valign="top">九月</td><td valign="top">十月</td><td valign="top">冬月</td><td valign="top">腊月</td></tr><tr><td valign="top">节</td><td valign="top">立春</td><td valign="top">惊蛰</td><td valign="top">清明</td><td valign="top">立夏</td><td valign="top">芒种</td><td valign="top">小暑</td><td valign="top">立秋</td><td valign="top">白露</td><td valign="top">寒露</td><td valign="top">立冬</td><td valign="top">大雪</td><td valign="top">小寒</td></tr><tr><td valign="top">气</td><td valign="top">雨水</td><td valign="top">春分</td><td valign="top">谷雨</td><td valign="top">小满</td><td valign="top">夏至</td><td valign="top">大暑</td><td valign="top">处暑</td><td valign="top">秋分</td><td valign="top">霜降</td><td valign="top">小雪</td><td valign="top">冬至</td><td valign="top">大寒</td></tr></tbody></table>

<h2 id="二十四节气歌"><a href="#二十四节气歌" class="headerlink" title="二十四节气歌"></a>二十四节气歌</h2><p>春雨惊春清谷天，夏满芒夏暑相连。<br>秋处露秋寒霜降，冬雪雪冬小大寒。<br>上半年逢六廿一，下半年逢八廿三。<br>每月两节不变更，最多相差一两天。</p>
<h2 id="九九歌"><a href="#九九歌" class="headerlink" title="九九歌"></a>九九歌</h2><p>一九二九不出手；<br>三九四九冰上走； 五九六九沿河看柳；<br>七九河开八九燕来； 九九加一九，耕牛遍地走；  </p>
<p>我国阴历有“九九”的说法，用来计算时令。计算的方法是从冬天的冬至日算起，第一个九天叫“一九”。第二个九天叫“二九”，依此类推，一直到“九九”。即第九个九天，这时冬天已过完，春天来到了。</p>
<h2 id="三伏"><a href="#三伏" class="headerlink" title="三伏"></a>三伏</h2><p>伏日宜吃面，北方有句俚语，叫做“头伏饺子二伏面，三伏烙饼摊鸡蛋”。<br><a href="https://baike.baidu.com/item/%E5%A4%B4%E4%BC%8F%E9%A5%BA%E5%AD%90%E4%BA%8C%E4%BC%8F%E9%9D%A2/1113695?fr=aladdin">头伏饺子二伏面百科</a>  </p>
<p><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8D%81%E5%9B%9B%E8%8A%82%E6%B0%94/191597">二十四节气百科</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>六十甲子</title>
    <url>/2018/06/11/%E6%88%91%E7%9A%84%E6%97%A5%E5%B8%B8%E5%85%B4%E8%B6%A3/%E5%85%AD%E5%8D%81%E7%94%B2%E5%AD%90/</url>
    <content><![CDATA[<h2 id="六十甲子"><a href="#六十甲子" class="headerlink" title="六十甲子"></a>六十甲子</h2><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=d4374fbf8d1001e94a3c130d880f7b06/9d82d158ccbf6c81f7f12abebc3eb13532fa40a5.jpg" alt="六十甲子"></p>
<p>天干地支与六十甲子<br>在中国古代的历法中，甲、乙、丙、丁、戊、己、庚、辛、壬、癸被称为“十天干”，子、丑、寅、卯、辰、巳、午、未、申、酉、戌、亥叫作“十二地支”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">天干：甲jiǎ、乙yǐ、丙bǐng、丁dīng、戊wù、己jǐ、庚gēng、辛xīn、壬rén、癸guǐ</span><br><span class="line">地支：子zǐ、丑chǒu、寅yín、卯mǎo、辰chén、巳sì、午wǔ、未wèi、申shēn、酉yǒu、戌xū、亥hài</span><br></pre></td></tr></table></figure>

<h2 id="释义"><a href="#释义" class="headerlink" title="释义"></a>释义</h2><ul>
<li>天干地支<br>以天干和地支按顺序相配﹐即甲、乙、丙、丁、戊、己、庚、辛、壬、癸与子、丑、寅、卯、辰、巳、午、未、申、酉、戌、亥相组合，从”甲子”起﹐到”癸亥”止﹐满六十为一周﹐称为”六十甲子”。亦称”六十花甲子”。 又因起头是“甲”字的有六组，所以也叫“六甲”。</li>
<li>年龄<br>指人满六十岁。</li>
<li>道家星宿神<br>六十甲子神<br>六十甲子神<br>道家信奉的六十个星宿神﹐即六十甲子日值日的六十位神。用天干和地支循环相配作为称呼这些神的名字。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01 甲子	11甲戌	21甲申	31 甲午	41甲辰	51甲寅</span><br><span class="line">02 乙丑	12 乙亥	22乙酉	32 乙未	42乙巳	52 乙卯</span><br><span class="line">03 丙寅	13丙子	23 丙戌	33丙申	43丙午	53丙辰</span><br><span class="line">04丁卯	14丁丑	24丁亥	34丁酉	44丁未	54丁巳</span><br><span class="line">05戊辰	15戊寅	25戊子	35戊戌	45戊申	55 戊午</span><br><span class="line">06己巳	16己卯	26己丑	36 己亥	46 己酉	56 己未</span><br><span class="line">07庚午	17 庚辰	27庚寅	37 庚子	47 庚戌	57 庚申</span><br><span class="line">08辛未	18 辛巳	28 辛卯	38 辛丑	48 辛亥	58 辛酉</span><br><span class="line">09壬申	19壬午	29 壬辰	39 壬寅	49 壬子	59 壬戌</span><br><span class="line">10癸酉	20癸未	30 癸巳	40 癸卯	50 癸丑	60 癸亥</span><br></pre></td></tr></table></figure>


<p><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8D%81%E5%9B%9B%E8%8A%82%E6%B0%94/191597">二十四节气百科</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>商丘历史变迁</title>
    <url>/2018/06/11/%E6%88%91%E7%9A%84%E6%97%A5%E5%B8%B8%E5%85%B4%E8%B6%A3/%E5%95%86%E4%B8%98%E5%8E%86%E5%8F%B2%E5%8F%98%E8%BF%81/</url>
    <content><![CDATA[<h2 id="三皇五帝时期"><a href="#三皇五帝时期" class="headerlink" title="三皇五帝时期"></a>三皇五帝时期</h2><p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=ed322f188194a4c21e2eef796f9d70b0/4e4a20a4462309f7abe86305740e0cf3d7cad626.jpg" alt="燧皇陵中的天皇燧人氏青铜像"></p>
<p>旧石器时代，三皇之首的燧人氏出生于商丘并在这一带建立燧明国<br>8500年前，栗陆氏建都于栗（今商丘夏邑县）<br>6000年前，炎帝朱襄氏建都于朱（今商丘柘城县）。<br>葛天氏建都于葛（今商丘宁陵县）。<br>4500年前，颛顼由穷桑迁都于商丘（今商丘睢阳区）。<br>帝喾高辛氏出生并封于高辛（今商丘高辛镇），成为天下共主后，定都亳（今商丘谷熟镇）。<br>帝喾死后，长子帝挚受禅接帝位，在位九年，因未能妥善管理国家，挚禅位于唐尧，帝尧封挚于高辛。<br>帝尧时代，商丘为后羿的封地。<br>帝舜时代，帝喾之<br>（睢阳区）帝喾陵<br>（睢阳区）帝喾陵<br>子契（阏伯）辅佐禹治水有功，被虞舜封于商（今睢阳区）做火正，为商族人的始祖，<br>深受人民的爱戴，故人们尊他为“火神”<br>阏伯死后葬于封地，由于阏伯的封号为“商”，他的墓冢被称为“商丘”</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>把json写入本地文件</title>
    <url>/2017/05/19/python/python%20%E5%86%99%E5%85%A5json%E6%96%87%E4%BB%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h2 id="json中文ASCII乱码问题的解决"><a href="#json中文ASCII乱码问题的解决" class="headerlink" title="json中文ASCII乱码问题的解决"></a>json中文ASCII乱码问题的解决</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">* json中文ASCII乱码问题的解决</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding( <span class="string">&quot;utf-8&quot;</span> )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="判断路径是否存在-存在-True-不存在-False"><a href="#判断路径是否存在-存在-True-不存在-False" class="headerlink" title="判断路径是否存在(存在:True,不存在:False)"></a>判断路径是否存在(存在:True,不存在:False)</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_dir</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="comment"># 去除首位空格</span></span><br><span class="line">    path = path.strip()</span><br><span class="line">    <span class="comment"># 去除尾部 \ 符号</span></span><br><span class="line">    path = path.rstrip(<span class="string">&quot;\\&quot;</span>)</span><br><span class="line">    isExists = os.path.exists(path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">        os.makedirs(path)</span><br><span class="line">        <span class="built_in">print</span> path + <span class="string">&#x27; good 创建成功&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> path + <span class="string">&#x27; 该目录已存在拉&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_file</span>(<span class="params">path</span>):</span></span><br><span class="line">    isExists = os.path.exists(path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    ls = os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ls:</span><br><span class="line">        c_path = os.path.join(path, i)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(c_path):</span><br><span class="line">            del_file(c_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            os.remove(c_path)</span><br><span class="line"></span><br><span class="line">    shutil.rmtree(path)</span><br></pre></td></tr></table></figure>

<h2 id="将数据转换成字符串"><a href="#将数据转换成字符串" class="headerlink" title="将数据转换成字符串"></a>将数据转换成字符串</h2><pre><code class="py">def test():
    test_dict = &#123;&#39;one&#39;: [&#39;你好&#39;, &#123;1: [[&#39;jd&#39;, &#39;hello&#39;], [&#39;cmo&#39;, &#39;china&#39;], [&#39;shanghai&#39;, &#39;mjgc&#39;]]&#125;]&#125;
    print(test_dict)
    print(type(test_dict))
    # dumps 将数据转换成字符串
    json_str = json.dumps(test_dict)
    print(json_str)
    print(type(json_str))
</code></pre>
<h2 id="os模块popen方法"><a href="#os模块popen方法" class="headerlink" title="os模块popen方法"></a>os模块popen方法</h2><blockquote>
<p>可以直接使用终端的命令 例如：# 打开目录 open_path = ‘open ‘ + output_dir_name<br>    os.popen(open_path)<br><a href="https://www.cnblogs.com/yangykaifa/p/7127776.html">python调用shell命令</a>    </p>
</blockquote>
<pre><code class="py">popen方法可以得到shell命令的返回值。os.popen(cmd)后，
须要再调用read()或者readlines()这两个命令。输出结果。

 os.popen(&quot;ls&quot;)  
</code></pre>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>json文件中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>python工具介绍</title>
    <url>/2020/03/09/python/python%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="视频学习"><a href="#视频学习" class="headerlink" title="视频学习"></a>视频学习</h2><p><a href="https://www.bilibili.com/video/av75855831?from=search&seid=5506272193310743526">python教程2019版</a>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">TABLE OF CONTENT</span><br><span class="line"></span><br><span class="line">00:00:00 Introduction</span><br><span class="line">00:01:49 Installing Python 3</span><br><span class="line">00:06:10 Your First Python Program</span><br><span class="line">00:08:11 How Python Code Gets Executed </span><br><span class="line">00:11:24 How Long It Takes To Learn Python </span><br><span class="line">00:13:03 Variables</span><br><span class="line">00:18:21 Receiving Input</span><br><span class="line">00:22:16 Python Cheat Sheet</span><br><span class="line">00:22:46 Type Conversion</span><br><span class="line">00:29:31 Strings</span><br><span class="line">00:37:36 Formatted Strings</span><br><span class="line">00:40:50 String Methods</span><br><span class="line">00:48:33 Arithmetic Operations</span><br><span class="line">00:51:33 Operator Precedence</span><br><span class="line">00:55:04 Math Functions</span><br><span class="line">00:58:17 If Statements</span><br><span class="line">01:06:32 Logical Operators</span><br><span class="line">01:11:25 Comparison Operators</span><br><span class="line">01:16:17 Weight Converter Program </span><br><span class="line">01:20:43 While Loops</span><br><span class="line">01:24:07 Building a Guessing Game</span><br><span class="line">01:30:51 Building the Car Game</span><br><span class="line">01:41:48 For Loops</span><br><span class="line">01:47:46 Nested Loops</span><br><span class="line">01:55:50 Lists</span><br><span class="line">02:01:45 2D Lists</span><br><span class="line">02:05:11 My Complete Python Course </span><br><span class="line">02:06:00 List Methods</span><br><span class="line">02:13:25 Tuples</span><br><span class="line">02:15:34 Unpacking</span><br><span class="line">02:18:21 Dictionaries</span><br><span class="line">02:26:21 Emoji Converter</span><br><span class="line">02:30:31 Functions</span><br><span class="line">02:35:21 Parameters</span><br><span class="line">02:39:24 Keyword Arguments </span><br><span class="line">02:44:45 Return Statement</span><br><span class="line">02:48:55 Creating a Reusable Function </span><br><span class="line">02:53:42 Exceptions</span><br><span class="line">02:59:14 Comments</span><br><span class="line">03:01:46 Classes</span><br><span class="line">03:07:46 Constructors</span><br><span class="line">03:14:41 Inheritance</span><br><span class="line">03:19:33 Modules</span><br><span class="line">03:30:12 Packages</span><br><span class="line">03:36:22 Generating Random Values</span><br><span class="line">03:44:37 Working with Directories </span><br><span class="line">03:50:47 Pypi and Pip</span><br><span class="line">03:55:34 Project 1: Automation with Python</span><br><span class="line">04:10:22 Project 2: Machine Learning with Python </span><br><span class="line">04:58:37 Project 3: Building a Website with Django </span><br></pre></td></tr></table></figure>

<h2 id="安装和切换python3"><a href="#安装和切换python3" class="headerlink" title="安装和切换python3"></a>安装和切换python3</h2><p><a href="https://www.cnblogs.com/cynthia-wuqian/p/9303514.html">mac下 将python2.7改为python3</a></p>
<p>执行<br>bash 环境： <code>source ~/.bashrc</code></p>
<p>zsh 环境： <code>source ~/.zshrc</code></p>
<h2 id="pyenv"><a href="#pyenv" class="headerlink" title="pyenv"></a>pyenv</h2><p>Mac系统自带的Python是2.7.10，自己需要Python 3.x,此时需要在系统中安装多个Python，但又不能影响系统自带的Python,即需要实现Python的多版本共存,pyenv就是这样一个Python版本管理器 。<br><a href="https://www.cnblogs.com/kumufengchun/p/10986498.html">Mac安装pyenv及pyenv的使用</a><br>1.查看pyenv安装的版本<br><code>pyenv versions</code><br>2.  后边括号中内容表示这个版本是由哪条途径激活的（global、local、shell）<br><code>pyenv global &lt;version&gt;</code>  # 全局设置python版本为指定版本，设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。<br><code>pyenv local &lt;version&gt;</code>   # 设置当前路径下python版本为指定版本，设置 Python 本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。<br>通过这种方式设置的 Python 版本优先级较 global 高。<br><code>pyenv shell &lt;version&gt;</code>   # 设置当前shell窗口使用的python版本为指定版本，设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式。<br>这个版本的优先级比 local 和 global 都要高。–unset 参数可以用于取消当前 shell 设定的版本。<br>3.查看当前的python 版本<br><code>pyenv version</code></p>
<p>4.切换版本<br>[root@localhost ~]# <code>pyenv global 3.6.4</code><br>[root@localhost ~]# <code>pyenv version</code><br>3.6.4 (set by /root/.pyenv/version)  </p>
<p><strong>安装的zsh遇到问题</strong><br>zsh: command not found: pyenv<br><a href="https://www.jianshu.com/p/3e93311fe6cb">解决路径</a></p>
<h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h2><h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><p>Django是一个开放源代码的Web应用框架，由Python写成。采用了MTV的框架模式，即模型M，模板T和视图V，重点就是基于Python并且是一个大而全的Web应用框架，什么都替你考虑好了.<br><a href="https://www.jianshu.com/p/b019496ccbee">Mac下Django学习</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习</title>
    <url>/2017/05/19/python/python%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Python基础知识总结"><a href="#Python基础知识总结" class="headerlink" title="Python基础知识总结"></a>Python基础知识总结</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--&gt;首先python是用缩进来解读程序的，所以缩进很重要</span><br><span class="line">--&gt;%d %s 分别表示打印整数和字符串</span><br><span class="line">--&gt;print 直接打印</span><br><span class="line">--&gt;def 方法名:  声明方法</span><br><span class="line">--&gt;if __name__ == &#x27;__main__&#x27;: 这个感觉想是主方法</span><br><span class="line">--&gt;r或R 字符串前缀加上r或R表示自然字符串</span><br><span class="line">    打印输出一下就明白意思了</span><br><span class="line">    print &quot;============Newlines are indicated by \n&quot;</span><br><span class="line">    print r&quot;============Newlines are indicated by \n&quot;</span><br><span class="line">--&gt;列表</span><br><span class="line">    空列表：a=[]</span><br><span class="line">    函数方法：a.append(3)     　　&gt;&gt;&gt;[3]</span><br><span class="line">          a.extend([3,4,5])     　　&gt;&gt;&gt;[3,3,4,5]    添加一个列表序列</span><br><span class="line">          a.insert(1,&#x27;hello&#x27;)    　　  &gt;&gt;&gt;[3,&#x27;hello&#x27;,3,4,5]</span><br><span class="line">          a.remove(3)        　　　  &gt;&gt;&gt;[&#x27;hello&#x27;,3,4,5] 删除第一个出现的3，没有3则报错</span><br><span class="line">          a.pop()        　　　　　　&gt;&gt;&gt;[&#x27;hello&#x27;,3,4]</span><br><span class="line">          a.pop(0)        　　　　　　&gt;&gt;&gt;[3,4]</span><br><span class="line">          a.index(4)       　　 &gt;&gt;&gt;1    返回出现的第一个4的下标</span><br><span class="line">          a.count(3)        　　&gt;&gt;&gt;1    列表中元素3的个数</span><br><span class="line">          a.sort        &gt;&gt;&gt;[3,4]    排序</span><br><span class="line">          a.reverse()        &gt;&gt;&gt;[4,3]    反序</span><br><span class="line">    删除元素的方法</span><br><span class="line">        a.remove(3)    通过值删除元素，删除第一个为参数值得元素</span><br><span class="line">        a.pop()       通过下标删除元素，默认删除列表最后一个值，带参数则删除下标为参数值的元素</span><br><span class="line">        del a[0]       通过下标删除元素，</span><br><span class="line">            del a[2:4] 删除a表下标为2,3的元素</span><br><span class="line">        del a[:]   删除a列表所有元素</span><br><span class="line">        del a       删除列表</span><br><span class="line">--&gt;元组</span><br><span class="line">    空元组：t = ()</span><br><span class="line">    元组赋值： t = (123,345)</span><br><span class="line">           t[0]         &gt;&gt;&gt;123</span><br><span class="line"></span><br><span class="line">--&gt;字典</span><br><span class="line">    d = &#123;&#x27;Jack&#x27;:&#x27;jack@mail.com&#x27;,&#x27;Tom&#x27;:&#x27;Tom@main.com&#x27;&#125;</span><br><span class="line">    d[&#x27;Jack&#x27;]    　　　　　　　　&gt;&gt;&gt;&#x27;jack@mail.com</span><br><span class="line">    d[&#x27;Jim&#x27;] = &#x27;Jim@sin.com&#x27;    &gt;&gt;&gt;&#123;&#x27;Jim&#x27;: &#x27;Jim@sin.com&#x27;, &#x27;Jack&#x27;: &#x27;jack@mail.com&#x27;, &#x27;Tom&#x27;: &#x27;Tom@main.com&#x27;&#125;</span><br><span class="line"></span><br><span class="line">　 del d[&#x27;Jim&#x27;]    &gt;&gt;&gt;&#123;&#x27;Jack&#x27;: &#x27;jack@mail.com&#x27;, &#x27;Tom&#x27;: &#x27;Tom@main.com&#x27;&#125;</span><br><span class="line">    list(d.keys())    将返回一个字典中所有关键字组成的无序列表</span><br><span class="line">    sorted(d.keys()) 将返回一个字典中所有关键字组成的排序列表</span><br><span class="line">    dict()    构造函数可以直接从key-value对中创建字典</span><br><span class="line">    dict([(&#x27;Tim&#x27;,123),(&#x27;Tiny&#x27;,234)])    &gt;&gt;&gt;&#123;&#x27;Tiny&#x27;: 234, &#x27;Tim&#x27;: 123&#125;</span><br><span class="line"></span><br><span class="line">--&gt;字符串相关知识</span><br><span class="line">    addressStr = &quot;%s%s%s&quot; %(village_name,village_period,build_number)</span><br><span class="line"></span><br><span class="line">    特殊字符的删除</span><br><span class="line">    identify = string.maketrans(&#x27;&#x27;, &#x27;&#x27;)</span><br><span class="line">    delEStr = string.punctuation + &#x27; &#x27; + string.digits  #ASCII 标点符号，空格和数字</span><br><span class="line"></span><br><span class="line">    s = s.translate(identify, delEStr) #去掉ASCII 标点符号和空格</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="4种类型的数"><a href="#4种类型的数" class="headerlink" title="4种类型的数"></a>4种类型的数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、在Python中有4种类型的数——整数、长整数、浮点数和复数。</span><br><span class="line"></span><br><span class="line">2是一个整数的例子。</span><br><span class="line">长整数不过是大一些的整数。</span><br><span class="line">3.23和52.3E-4是浮点数的例子。E标记表示10的幂。在这里，52.3E-4表示52.3 * 10-4。</span><br><span class="line">(-5+4j)和(2.3-4.6j)是复数的例子。</span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">字符串是 字符的序列 。字符串基本上就是一组单词。</span><br><span class="line"></span><br><span class="line">我几乎可以保证你在每个Python程序中都要用到字符串，所以请特别留心下面这部分的内容。下面告诉你如何在Python中使用字符串。</span><br><span class="line"></span><br><span class="line">使用单引号（&#x27;）</span><br><span class="line">你可以用单引号指示字符串，就如同&#x27;Quote me on this&#x27;这样。所有的空白，即空格和制表符都照原样保留。</span><br><span class="line"></span><br><span class="line">使用双引号（&quot;）</span><br><span class="line">在双引号中的字符串与单引号中的字符串的使用完全相同，例如&quot;What&#x27;s your name?&quot;。</span><br><span class="line"></span><br><span class="line">使用三引号（&#x27;&#x27;&#x27;或&quot;&quot;&quot;）</span><br><span class="line">利用三引号，你可以指示一个多行的字符串。你可以在三引号中自由的使用单引号和双引号。例如：</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;This is a multi-line string. This is the first line.</span><br><span class="line">This is the second line.</span><br><span class="line">&quot;What&#x27;s your name?,&quot; I asked.</span><br><span class="line">He said &quot;Bond, James Bond.&quot;</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">转义符</span><br><span class="line">假设你想要在一个字符串中包含一个单引号（&#x27;），那么你该怎么指示这个字符串？例如，这个字符串是What&#x27;s your name?。你肯定不会用&#x27;What&#x27;s your name?&#x27;来指示它，因为Python会弄不明白这个字符串从何处开始，何处结束。所以，你需要指明单引号而不是字符串的结尾。可以通过 转义符 来完成这个任务。你用\&#x27;来指示单引号——注意这个反斜杠。现在你可以把字符串表示为&#x27;What\&#x27;s your name?&#x27;。</span><br><span class="line"></span><br><span class="line">另一个表示这个特别的字符串的方法是&quot;What&#x27;s your name?&quot;，即用双引号。类似地，要在双引号字符串中使用双引号本身的时候，也可以借助于转义符。另外，你可以用转义符\\来指示反斜杠本身。</span><br><span class="line"></span><br><span class="line">值得注意的一件事是，在一个字符串中，行末的单独一个反斜杠表示字符串在下一行继续，而不是开始一个新的行。例如：</span><br><span class="line"></span><br><span class="line">&quot;This is the first sentence.\</span><br><span class="line">This is the second sentence.&quot;</span><br><span class="line">等价于&quot;This is the first sentence. This is the second sentence.&quot;</span><br><span class="line"></span><br><span class="line">自然字符串</span><br><span class="line">如果你想要指示某些不需要如转义符那样的特别处理的字符串，那么你需要指定一个自然字符串。自然字符串通过给字符串加上前缀r或R来指定。例如r&quot;Newlines are indicated by \n&quot;。</span><br><span class="line"></span><br><span class="line">Unicode字符串</span><br><span class="line">Unicode是书写国际文本的标准方法。如果你想要用你的母语如北印度语或阿拉伯语写文本，那么你需要有一个支持Unicode的编辑器。类似地，Python允许你处理Unicode文本——你只需要在字符串前加上前缀u或U。例如，u&quot;This is a Unicode string.&quot;。</span><br><span class="line"></span><br><span class="line">记住，在你处理文本文件的时候使用Unicode字符串，特别是当你知道这个文件含有用非英语的语言写的文本。</span><br><span class="line"></span><br><span class="line">字符串是不可变的</span><br><span class="line">这意味着一旦你创造了一个字符串，你就不能再改变它了。虽然这看起来像是一件坏事，但实际上它不是。我们将会在后面的程序中看到为什么我们说它不是一个缺点。</span><br><span class="line"></span><br><span class="line">按字面意义级连字符串</span><br><span class="line">如果你把两个字符串按字面意义相邻放着，他们会被Python自动级连。例如，&#x27;What\&#x27;s&#x27; &#x27;your name?&#x27;会被自动转为&quot;What&#x27;s your name?&quot;。</span><br></pre></td></tr></table></figure>

<h1 id="标识符的命名"><a href="#标识符的命名" class="headerlink" title="标识符的命名"></a>标识符的命名</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">变量是标识符的例子。 标识符 是用来标识 某样东西 的名字。在命名标识符的时候，你要遵循这些规则：</span><br><span class="line"></span><br><span class="line">标识符的第一个字符必须是字母表中的字母（大写或小写）或者一个下划线（‘ _ ’）。</span><br><span class="line"></span><br><span class="line">标识符名称的其他部分可以由字母（大写或小写）、下划线（‘ _ ’）或数字（0-9）组成。</span><br><span class="line"></span><br><span class="line">标识符名称是对大小写敏感的。例如，myname和myName不是一个标识符。注意前者中的小写n和后者中的大写N。</span><br><span class="line"></span><br><span class="line">有效 标识符名称的例子有i、__my_name、name_23和a1b2_c3。</span><br><span class="line"></span><br><span class="line">无效 标识符名称的例子有2things、this is spaced out和my-name。</span><br></pre></td></tr></table></figure>
<h1 id="关于模块主方法的使用"><a href="#关于模块主方法的使用" class="headerlink" title="关于模块主方法的使用"></a>关于模块主方法的使用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模块的__name__</span><br><span class="line"></span><br><span class="line">每个模块都有一个名称，在模块中可以通过语句来找出模块的名称。这在一个场合特别有用——就如前面所提到的，当一个模块被第一次输入的时候，这个模块的主块将被运行。假如我们只想在程序本身被使用的时候运行主块，而在它被别的模块输入的时候不运行主块，我们该怎么做呢？这可以通过模块的__name__属性完成。</span><br><span class="line"></span><br><span class="line">使用模块的__name__</span><br><span class="line"></span><br><span class="line">例8.2 使用模块的__name__</span><br></pre></td></tr></table></figure>

<h1 id="usr-bin-python-Filename-using-name-py"><a href="#usr-bin-python-Filename-using-name-py" class="headerlink" title="!/usr/bin/python Filename: using_name.py"></a>!/usr/bin/python Filename: using_name.py</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print &#x27;This program is being run by itself&#x27;</span><br><span class="line">else:</span><br><span class="line">    print &#x27;I am being imported from another module&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="python中切片的学习"><a href="#python中切片的学习" class="headerlink" title="python中切片的学习"></a>python中切片的学习</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">切片操作符是序列名后跟一个方括号，方括号中有一对可选的数字，并用冒号分割。注意这与你使用的索引操作符十分相似。记住数是可选的，而冒号是必须的。</span><br><span class="line"></span><br><span class="line">切片操作符中的第一个数（冒号之前）表示切片开始的位置，第二个数（冒号之后）表示切片到哪里结束。如果不指定第一个数，Python就从序列首开始。如果没有指定第二个数，则Python会停止在序列尾。注意，返回的序列从开始位置 开始 ，刚好在 结束 位置之前结束。即开始位置是包含在序列切片中的，而结束位置被排斥在切片外。</span><br></pre></td></tr></table></figure>
<h1 id="正则表达式的学习"><a href="#正则表达式的学习" class="headerlink" title="正则表达式的学习"></a>正则表达式的学习</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正则表达式的学习 http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html</span><br><span class="line">  ①一般字符：</span><br><span class="line">   . 匹配任意除换行符“\n”外的字符 例如：a.c -&gt; abc,acc,adc...等与之匹配</span><br><span class="line">   \ 转义字符，使后一个字符改变原来的意思 例如：a\.c,a\\c 与之匹配的则是a.c,a\c</span><br><span class="line">   [...] 字符集（字符类） 对应的位置可以是字符集中任意字符，字符集中得字符可以逐个列出，也可以给出范围，如</span><br><span class="line">          [abc]或[a-c],第一个字符如果是^ 则表示取反，如[^abc]表示不是abc的其他字符，所有的特殊字符在字符集中都</span><br><span class="line">          失去其原有的特殊含义。</span><br><span class="line">  ②预定义字符集 -&gt; 在字符集表示方式</span><br><span class="line">    \d  -&gt; 表示数字：[0-9]</span><br><span class="line">    \D  -&gt; 表示非数字：[^\d]</span><br><span class="line">    \s  -&gt; 表示空白字符：[&lt;空格&gt;\t\r\n\f\v]</span><br><span class="line">    \S  -&gt; 表示非空白符：[^\s]</span><br><span class="line">    \w  -&gt; 表示单词字符: [A-Za-z0-9_]</span><br><span class="line">    \W  -&gt; 表示非单词字符：[^\w]</span><br><span class="line">  ③数量词（用在字符或（...）之后）</span><br><span class="line">     * -&gt; 表示：匹配前一个字符0或无限次 例如：abc* 表示ab、abcccccc等</span><br><span class="line">     + -&gt; 表示：匹配前一个字符一次或无限次 例如 abc+ 表示abc、abcccccc等</span><br><span class="line">     ？ -&gt; 表示：匹配前一个字符0次或一次。例如：abc？ 表示ab、abc</span><br><span class="line">     &#123;m&#125; -&gt; 表示：匹配前一个字符m次。 例如：ab&#123;2&#125;c 表示abbc</span><br><span class="line">     &#123;m,n&#125; -&gt; 表示：匹配前一个字符m至n次。m和n可以省略：若省略m则匹配0至n次，反之则匹配m至无限次。例如：ab&#123;1,2&#125; 表示abb、ab</span><br><span class="line">  ④边界匹配（不消耗待匹配字符串中得字符）</span><br><span class="line">     ^ -&gt; 表示：匹配字符串开头。在多行模式中匹配每一行的开头 例如：^abc 表示abc</span><br><span class="line">     $ -&gt; 表示：匹配字符串末尾。在多行模式中匹配每一行的末尾 例如：abc$ 表示abc</span><br><span class="line">     \A -&gt; 表示：仅匹配字符串开头。例如：\Aabc 表示abc</span><br><span class="line">     \Z -&gt; 表示：仅匹配字符串末尾。例如：\Zabc 表示abc</span><br><span class="line">     \b -&gt; 表示：匹配\w和\W之间。例如：a\b!bc 表示a!bc</span><br><span class="line">     \B -&gt; 表示：[^\b]。例如：a\Bbc 表示abc</span><br><span class="line">  ⑤逻辑、分组</span><br><span class="line">     | -&gt; 表示左右表达式任意匹配一个。它总是先尝试匹配左边的表达式，一旦成功匹配则跳过匹配右边的表达式。如果|没有别包括在（）中，则它的范围是整个正则表达式 例如：abc|def</span><br><span class="line">     (...) -&gt; 被括起来的表达式将作为分组，从表达式的左边开始每遇到一个分组的左括号‘（’，编号+1. 另外，分组表达式作为一个整体，可以后接数量词。表达式|仅在该组中有效：（abc）&#123;2&#125; abcabc</span><br><span class="line">     (?P&lt;name&gt;...) -&gt; 分组，除了原有的编号外在指定一个额外的别名。 例如：(?P&lt;id&gt;abc)&#123;2&#125;   abcabc</span><br><span class="line">     \&lt;number&gt; -&gt; 表示 引用编号为&lt;number&gt;的分组匹配到得字符串。例如：(\d)abc\1 则可表：2abc2、4abc4</span><br><span class="line">     (?P=name) -&gt; 表示 引用别名为&lt;name&gt;的分组匹配到得字符串。(?P&lt;id&gt;\d)abc(?P=id) 则可表：2abc2、4abc4</span><br><span class="line">  ⑥特殊构造（不作为分组）</span><br><span class="line">     (?:...) -&gt; 表（...）的不分组版本，用于使用‘|’或后接数量词。 例如：(?:abc)&#123;2&#125;  abcabc</span><br><span class="line">     (?:iLmsux) -&gt; 表 iLmsux的每一个字符代表一个匹配模式，只能用在正则表达式的开头，可选多个。 例如：(?iabc)  Abc</span><br><span class="line">     (?#...) -&gt; 表 #后的内容将作为注释被忽略。 例如：abc(?#comment)123  abc123</span><br><span class="line">     (?=...) -&gt; 表 之后的字符串内容需要匹配表达式才能成功匹配。不消耗字符串内容 例如：a(?=\d) 后面是数字的a</span><br><span class="line">     (?!...) -&gt; 表 之后的字符串内容需要不匹配表达式才能成功匹配。不消耗字符串内容 例如：a(?!\d) 后面不是数字的a</span><br><span class="line">     (?&lt;=...) -&gt; 表 之前的字符串内容需要匹配表达式才能成功匹配。不消耗字符串内容 例如：(&lt;=\d)a 前面是数字的a</span><br><span class="line">     (?&lt;!...) -&gt; 表 之前的字符串内容需要不匹配表达式才能成功匹配。不消耗字符串内容 例如：(&lt;=\d)a 前面不是数字的a</span><br></pre></td></tr></table></figure>

<h1 id="grep的使用"><a href="#grep的使用" class="headerlink" title="grep的使用"></a>grep的使用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep的使用：</span><br><span class="line">  1、使用正则表达式的一个多用途文本搜索工具.</span><br><span class="line">  2,grep的选项</span><br><span class="line">  -c 只输出匹配行的计数</span><br><span class="line">  -i 不区分大小写（用于单字符）</span><br><span class="line">  -n 显示匹配的行号</span><br><span class="line">  -v 不显示不包含匹配文本的所以有行</span><br><span class="line">  -s 不显示错误信息</span><br><span class="line">  -E 使用扩展正则表达式</span><br><span class="line">  更多的选项请查看：man grep</span><br><span class="line"></span><br><span class="line">  3,常用grep实例</span><br><span class="line"></span><br><span class="line">  (1)多个文件查询</span><br><span class="line">      grep &quot;sort&quot; *.doc       #见文件名的匹配</span><br><span class="line"></span><br><span class="line">  (2)行匹配:输出匹配行的计数</span><br><span class="line">      grep -c &quot;48&quot; data.doc   #输出文档中含有48字符的行数</span><br><span class="line"></span><br><span class="line">  (3)显示匹配行和行数</span><br><span class="line">      grep -n &quot;48&quot; data.doc       #显示所有匹配48的行和行号</span><br><span class="line"></span><br><span class="line">  (4)显示非匹配的行</span><br><span class="line">      grep -vn &quot;48&quot; data.doc      #输出所有不包含48的行</span><br><span class="line"></span><br><span class="line">  (4)显示非匹配的行</span><br><span class="line">      grep -vn &quot;48&quot; data.doc      #输出所有不包含48的行</span><br><span class="line"></span><br><span class="line">  (5)大小写敏感</span><br><span class="line">      grep -i &quot;ab&quot; data.doc       #输出所有含有ab或Ab的字符串的行</span><br><span class="line"></span><br><span class="line">  4, 正则表达式的应用</span><br><span class="line"></span><br><span class="line">  (1)正则表达式的应用 (注意：最好把正则表达式用单引号括起来)</span><br><span class="line">      grep &#x27;[239].&#x27; data.doc      #输出所有含有以2,3或9开头的，并且是两个数字的行</span><br><span class="line"></span><br><span class="line">  (2)不匹配测试</span><br><span class="line">      grep &#x27;^[^48]&#x27; data.doc      #不匹配行首是48的行</span><br><span class="line"></span><br><span class="line">  (3)使用扩展模式匹配</span><br><span class="line">      grep -E &#x27;219|216&#x27; data.doc</span><br><span class="line"></span><br><span class="line">  (4) ...</span><br><span class="line">      这需要在实践中不断应用和总结，熟练掌握正则表达式。</span><br><span class="line"></span><br><span class="line">  5, 使用类名</span><br><span class="line">  可以使用国际模式匹配的类名：</span><br><span class="line">  [[:upper:]]   [A-Z]</span><br><span class="line">  [[:lower:]]   [a-z]</span><br><span class="line">  [[:digit:]]   [0-9]</span><br><span class="line">  [[:alnum:]]   [0-9a-zA-Z]</span><br><span class="line">  [[:space:]]   空格或tab</span><br><span class="line">  [[:alpha:]]   [a-zA-Z]</span><br><span class="line"></span><br><span class="line">  (1)使用</span><br><span class="line">      grep &#x27;5[[:upper:]][[:upper:]]&#x27; data.doc     #查询以5开头以两个大写字母结尾的行</span><br></pre></td></tr></table></figure>
<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim的使用：</span><br><span class="line">      vim在保存之前不会对文件做实际的修改，只是加载到缓冲区中，对文件的编辑其实是对缓冲区的编辑，直到:w时才会存入物理文件。</span><br><span class="line">       ( 按 i 进入 insert 状态 即插入模式 ,按 Esc 退出插入模式</span><br><span class="line">               在非插入模式下按 dd 删除光标当前行,按 x 删除当前字,</span><br><span class="line">               按 j,n,l移动光标 )</span><br><span class="line"></span><br><span class="line">     :e file     把file加载到新的缓冲区中</span><br><span class="line">     :bn     跳转到下一个缓冲区</span><br><span class="line">     :bd     删除缓冲区(关闭文件)</span><br><span class="line">     :sp fn     分割窗口，并将fn加载到新的窗口中</span><br><span class="line"></span><br><span class="line">   退出编辑器</span><br><span class="line">     :w     将缓冲区写入文件，即保存修改</span><br><span class="line">     :wq     保存修改并退出</span><br><span class="line"></span><br><span class="line">     :x     保存修改并退出</span><br><span class="line"></span><br><span class="line">     :q     退出，如果对缓冲区进行过修改，则会提示</span><br><span class="line"></span><br><span class="line">     :q!     强制退出，放弃修改</span><br><span class="line"></span><br><span class="line">移动的使用：mv [选项] 源文件或目录 目标目录</span><br><span class="line">拷贝的使用： cp [选项] 源文件或目录 目标文件或目录</span><br><span class="line">删除的使用： rm</span><br><span class="line">           rm -r vv</span><br><span class="line">         但是这样会询问你是否真的要删除vv目录  输入y 确认删除</span><br><span class="line">         为了不让系统询问，可以强制删除 rm之后加上f就行了</span><br><span class="line">         rm -rf vv</span><br><span class="line">         这样就强制删除目录vv  如果目录下还有其他文佳 也一同删除了</span><br><span class="line"></span><br><span class="line">cat的使用：（concatenate）</span><br><span class="line">    cat主要有三大功能：</span><br><span class="line">     1.一次显示整个文件。$ cat filename</span><br><span class="line">     2.从键盘创建一个文件。$ cat &gt; filename</span><br><span class="line">        只能创建新文件,不能编辑已有文件.</span><br><span class="line">         1、键入cat &gt; filename.txt 后回车</span><br><span class="line">         2、录入文本内容；</span><br><span class="line">         3、键入回车；</span><br><span class="line">         4、在键盘上按下Ctrl+D (或者键入Control－D)。</span><br><span class="line">         5、 文本被存盘，shell提示符重新出现</span><br><span class="line"></span><br><span class="line">     3.将几个文件合并为一个文件： $cat file1 file2 &gt; file</span><br><span class="line">     参数：</span><br><span class="line">     -n 或 --number 由 1 开始对所有输出的行数编号</span><br><span class="line">     -b 或 --number-nonblank 和 -n 相似，只不过对于空白行不编号</span><br><span class="line">     -s 或 --squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行</span><br><span class="line">     -v 或 --show-nonprinting</span><br><span class="line">     例：</span><br><span class="line">     把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里</span><br><span class="line">     cat -n textfile1 &gt; textfile2</span><br><span class="line"></span><br><span class="line">     把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。</span><br><span class="line">     cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br><span class="line"></span><br><span class="line">     cat /dev/null &gt; /etc/test.txt  把test.txt文件扔进垃圾箱</span><br><span class="line"></span><br><span class="line"> mkdir的使用:</span><br><span class="line">     linux mkdir 命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。</span><br><span class="line">     1．命令格式：</span><br><span class="line">     mkdir [选项] 目录...</span><br><span class="line">     2．命令功能：</span><br><span class="line">     通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。</span><br><span class="line">     并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。</span><br><span class="line">     3．命令参数：</span><br><span class="line">       -m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask</span><br><span class="line">       -p, --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录;</span><br><span class="line">       -v, --verbose  每次创建新目录都显示信息</span><br><span class="line">           --help   显示此帮助信息并退出</span><br><span class="line">           --version  输出版本信息并退出</span><br><span class="line"></span><br><span class="line"> rmdir的使用:</span><br><span class="line">     rmdir是一个与mkdir相对应的命令。mkdir是建立目录，而rmdir是删除命令。rm命令可以同时删除文件或目录</span><br><span class="line">     rmdir命令介绍</span><br><span class="line">     1.名称：rmdir</span><br><span class="line">     2.适用对象：具有当前目录操作权限的所有使用者</span><br><span class="line">     3.命令格式：rmdir [-p -v] [dirName]</span><br><span class="line">     4.作用：删除空目录</span><br><span class="line">     5.参数详解：</span><br><span class="line">     -p 当子目录被删除后如果父目录也变成空目录的话，就连带父目录一起删除。</span><br><span class="line">     -v 上次讲过，这里不再叙述，具体参见</span><br><span class="line"></span><br><span class="line"> chmod的使用:</span><br><span class="line"></span><br><span class="line">     指令名称 : chmod</span><br><span class="line">     使用权限 : 所有使用者</span><br><span class="line">     使用方式 : chmod [-cfvR] [--help] [--version] mode file...</span><br><span class="line">     说明 : Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以藉以控制档案如何被他人所调用。</span><br><span class="line">     参数 :</span><br><span class="line">     mode : 权限设定字串，格式如下 : [ugoa...][[+-=][rwxX]...][,...]，其中</span><br><span class="line">     u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</span><br><span class="line">     + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</span><br><span class="line">     r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。</span><br><span class="line">     -c : 若该档案权限确实已经更改，才显示其更改动作</span><br><span class="line">     -f : 若该档案权限无法被更改也不要显示错误讯息</span><br><span class="line">     -v : 显示权限变更的详细资料</span><br><span class="line">     -R : 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)</span><br><span class="line">     --help : 显示辅助说明</span><br><span class="line">     --version : 显示版本</span><br><span class="line"></span><br><span class="line">     例子： chmod 755 a.txt</span><br><span class="line"></span><br><span class="line">     (你必须是文件a.txt的拥有者才能运行此命令。或者以$sudo chmod 755 a.txt的方式，以超级用户的身份运行该命令。)</span><br><span class="line"></span><br><span class="line">     change mode 改变a.txt的读、写以及执行权限。还记得每个文件都有九位的读写执行权限(参看 Linux文件管理背景知识)，</span><br><span class="line">     分为三组，分别对应拥有者(owner)，拥有组(owner group)中的用户和所有其他用户(other)。在这里，我们也有三个数字，755，对应三个组。</span><br><span class="line">     7被分配给拥有者，5被分配给拥有组，最后一个5分配给其它用户。Linux规定: 4为有读取的权利，2为有写入的权利，</span><br><span class="line">     1为有执行的权利。我们看到的7实际上是4 + 2 + 1，表示拥有者有读、写、执行三项权利。</span><br><span class="line"></span><br><span class="line">  ln的使用:</span><br><span class="line">         ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同不的链接，这个命令最常用的参数是-s，具体用法是：ln –s 源文件 目标文件。</span><br><span class="line">         　　当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。例如：ln –s /bin/less /usr/local/bin/less</span><br><span class="line">         　　-s 是代号（symbolic）的意思。</span><br><span class="line">         　　这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接又 软链接和硬链接两种，</span><br><span class="line">         软链接就是ln –s ** **，它只会在你选定的位置上生成一个文件的镜像，</span><br><span class="line">         不会占用磁盘空间，硬链接ln ** **，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</span><br><span class="line"></span><br><span class="line">  ping的使用：（control + c  停止ping）</span><br><span class="line">  惯用的关机指令：shutdown  ,shutdown -h now</span><br><span class="line"></span><br><span class="line">  重新开机，关机：reboot, halt, poweroff</span><br><span class="line">  clear的使用：清空终端信息</span><br><span class="line">  history的使用：查看输入的历史命令</span><br><span class="line"></span><br><span class="line">  touch的使用:</span><br><span class="line">   touch a.txt</span><br><span class="line"></span><br><span class="line">   如果a.txt不存在，生成一个新的空文档a.txt。如果a.txt存在，那么只更改该文档的时间信息。(这个命令实际上用得并不广泛，但可以帮我们创建一个空文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索并替换</title>
    <url>/2017/05/19/python/python%E6%90%9C%E7%B4%A2%E5%B9%B6%E6%9B%BF%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="搜索并替换"><a href="#搜索并替换" class="headerlink" title="搜索并替换"></a>搜索并替换</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> imghdr</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">suffix_list = [<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;h&#x27;</span>]</span><br><span class="line">g_totalCount = <span class="number">0</span></span><br><span class="line">image_name = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace_in_path</span>(<span class="params">filepath</span>):</span></span><br><span class="line">    <span class="keyword">global</span> g_totalCount, image_name</span><br><span class="line">    <span class="comment"># print(&quot;Operation with : &quot; + filepath)</span></span><br><span class="line">    <span class="comment"># open_file = open(filepath, &#x27;r+&#x27;) #用此种打开读写方式无效</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filepath, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> r:</span><br><span class="line">        lines = r.readlines()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filepath, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> w:</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lines:</span><br><span class="line">            r_pattern = <span class="string">r&quot;\[\[Resources sharedResources\] getImageWithImageName:(.+?)\]&quot;</span></span><br><span class="line">            <span class="comment"># if re.search(r_pattern, l):</span></span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;*******find*******&#x27;</span></span><br><span class="line">            image_name_list = re.findall(r_pattern, l)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(image_name_list):</span><br><span class="line">                image_name = image_name_list[<span class="number">0</span>]</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;image_name:%s&quot;</span> % image_name)</span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            replace_reg = re.<span class="built_in">compile</span>(r_pattern)</span><br><span class="line">            new_str = <span class="string">&quot;JDImg(%s)&quot;</span> % image_name</span><br><span class="line">            have_replace_string = replace_reg.sub(new_str, l)</span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            w.write(have_replace_string)</span><br><span class="line">    w.close()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_from_dir</span>(<span class="params"><span class="built_in">dir</span></span>):</span></span><br><span class="line">    <span class="keyword">global</span> g_totalCount</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="built_in">dir</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> files:</span><br><span class="line">            filepath = os.path.join(root, item)</span><br><span class="line">            <span class="comment"># print &#x27;filepath------%s&#x27; % filepath</span></span><br><span class="line">            extension = os.path.splitext(filepath)[<span class="number">1</span>][<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> extension <span class="keyword">in</span> suffix_list:</span><br><span class="line">                replace_in_path(filepath)</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;找到了------后缀为：[h or m]&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;###############结束##############&#x27;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;当前目录:%s&quot;</span> % os.getcwd()</span><br><span class="line">    <span class="comment"># 递归遍历目录下所有文件</span></span><br><span class="line">    get_file_from_dir(<span class="string">&#x27;/Users/wenyongjun/JD/JDiPad_git/JDiPad&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>搜索并替换</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬取网站内容</title>
    <url>/2017/05/19/python/python%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E5%B0%8F%E8%AF%B4%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h2 id="需要的库"><a href="#需要的库" class="headerlink" title="需要的库"></a>需要的库</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">requests</span><br><span class="line">BeautifulSoup</span><br></pre></td></tr></table></figure>

<h2 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br></pre></td></tr></table></figure>
<p><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html">Requests快速上手</a><br><a href="https://www.crummy.com/software/BeautifulSoup/bs3/documentation.zh.html">Beautiful Soup 中文文档</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫-scarpy</title>
    <url>/2017/05/19/python/python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<blockquote>
<p>scrapy基础实例，爬取zhipin网站信息</p>
<p>scarpy的新建 + scarpy模拟登录 + 在pipeline中存取信息到sqlite3 +xpath解析页面</p>
</blockquote>
<ul>
<li>文档<ul>
<li><a href="https://docs.scrapy.org/en/latest/index.html">Scrapy Documentation</a></li>
<li><a href="http://scrapy-chs.readthedocs.io/zh_CN/latest/">Scrapy 0.25 中文翻译</a></li>
</ul>
</li>
<li>环境 python3.5.2 + scrapy1.3</li>
</ul>
<span id="more"></span>

<h2 id="scrapy新建工程"><a href="#scrapy新建工程" class="headerlink" title="scrapy新建工程"></a>scrapy新建工程</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">scrapy startproject projectName</span><br></pre></td></tr></table></figure>

<p>具体可以查看 <a href="/Python3/Python3/python3%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/">python3爬虫学习</a></p>
<p>发现 <strong>parse</strong> 或者 <strong>start_requests</strong>是爬虫的入口</p>
<h2 id="解析html"><a href="#解析html" class="headerlink" title="解析html"></a>解析html</h2><p>scrapy支持xpath 和 css 两种选择器。这里使用xpath。</p>
<p>比如 <a href="https://www.zhipin.com/job_detail/?query=iOS&scity=101210100&source=2">这个页面</a> 我们要获取页面上帖子的链接：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse_page</span>(<span class="params">self, response</span>):</span></span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;\n 开始 解析版面上的具体招聘帖子的链接\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">       selector = scrapy.Selector(response)</span><br><span class="line">       job_list = selector.xpath(<span class="string">&quot;//div[@class=&#x27;job-list&#x27;]/ul[1]/li/a&quot;</span>)</span><br><span class="line">       <span class="keyword">for</span> job_list_content <span class="keyword">in</span> job_list:</span><br><span class="line">           url = self.host + job_list_content.xpath(<span class="string">&quot;@href&quot;</span>).extract_first()</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot;\n帖子 链接是:  &quot;</span>+url+<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这样就或获取到帖子的链接</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>如何解析帖子链接的内容，并且递归到下一页呢？这里需要使用yield：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> scrapy.Request(url=url, callback=self.parse_page)</span><br></pre></td></tr></table></figure>
<p>scrapy会自行调度，并访问该url然后把内容拿回来</p>
<p>具体代码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestZhiPinSpider2</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&quot;TestZhiPinSpider2&quot;</span></span><br><span class="line">    host = <span class="string">&quot;https://www.zhipin.com&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这个例子中只指定了一个页面作为爬取的起始url</span></span><br><span class="line">    <span class="comment"># 当然从数据库或者文件或者什么其他地方读取起始url也是可以的</span></span><br><span class="line">    start_urls = [</span><br><span class="line">        <span class="string">&quot;https://www.zhipin.com/job_detail/?query=iOS&amp;scity=101210100&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 爬虫的入口，可以在此进行一些初始化工作，比如从某个文件或者数据库读入起始url</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; 开始解析url ----------------------------------------------------------------------------------------&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> self.start_urls:</span><br><span class="line">            <span class="comment"># 此处将起始url加入scrapy的待爬取队列，并指定解析函数</span></span><br><span class="line">            <span class="comment"># scrapy会自行调度，并访问该url然后把内容拿回来</span></span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url=url, callback=self.parse_page)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 版面解析函数，解析一个版面上的帖子的标题和地址</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_page</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;解析  parse_page ----------------------------------------------------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">        selector = scrapy.Selector(response)</span><br><span class="line">        job_list = selector.xpath(<span class="string">&quot;//div[@class=&#x27;job-list&#x27;]/ul[1]/li/a&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> job_list_content <span class="keyword">in</span> job_list:</span><br><span class="line">            url = self.host + job_list_content.xpath(<span class="string">&quot;@href&quot;</span>).extract_first()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;帖子 链接是:  &quot;</span>+url)</span><br><span class="line">            <span class="comment"># 此处，将解析出的帖子地址加入待爬取队列，并指定解析函数</span></span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url=url, callback=self.parse_job_detail)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在此处解析翻页信息，从而实现爬取版区的多个页面</span></span><br><span class="line">        next_page_url = selector.xpath(<span class="string">&quot;//a[@ka=&#x27;page-next&#x27;]&quot;</span>).xpath(<span class="string">&quot;@href&quot;</span>).extract_first()</span><br><span class="line">        next_page_class = selector.xpath(<span class="string">&quot;//a[@ka=&#x27;page-next&#x27;]&quot;</span>).xpath(<span class="string">&quot;@class&quot;</span>).extract_first()</span><br><span class="line">        <span class="keyword">if</span> next_page_class == <span class="string">&quot;next&quot;</span>:</span><br><span class="line">             next_page_full_url = self.host + next_page_url</span><br><span class="line">             <span class="keyword">yield</span> scrapy.Request(url=next_page_full_url, callback=self.parse_page)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">             <span class="built_in">print</span>(<span class="string">&quot;没有下一页了----------------------------------------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#具体的招聘信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_job_detail</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        selector = scrapy.Selector(response)</span><br><span class="line"></span><br><span class="line">        job_url = response.request.url</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; 解析 具体的招聘信息  --------url:&quot;</span>+job_url)        </span><br></pre></td></tr></table></figure>
<p>这个爬虫会将zhipin网站iOS招聘的信息都爬取一遍</p>
<h2 id="Pipelines"><a href="#Pipelines" class="headerlink" title="Pipelines"></a>Pipelines</h2><p>可以看到新建工程后会生成一个pipelines.py的文件，可以在这里处理抓取的内容，存入数据库什么的。</p>
<h3 id="1-在items-py中定义抓取的内容"><a href="#1-在items-py中定义抓取的内容" class="headerlink" title="1.在items.py中定义抓取的内容"></a>1.在items.py中定义抓取的内容</h3><p>这里简单写一个</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestJobDetailItem</span>(<span class="params">Item</span>):</span></span><br><span class="line">    url = Field()</span><br></pre></td></tr></table></figure>

<h3 id="2-在pipelines中处理"><a href="#2-在pipelines中处理" class="headerlink" title="2.在pipelines中处理"></a>2.在pipelines中处理</h3><p>在pipelines.py中新建Sqlite3Pipeline方法，原来可能有个FilePipeline不理它。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jobSpider.items <span class="keyword">import</span> JobDetailItem</span><br><span class="line"><span class="keyword">from</span> jobSpider.items <span class="keyword">import</span> TestJobDetailItem</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sqlite3Pipeline</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, sqlite_file, sqlite_base_file, sqlite_ZhiPin_table, sqlite_Test_ZhiPin_table</span>):</span></span><br><span class="line">        self.sqlite_file = sqlite_file</span><br><span class="line">        self.sqlite_base_file = sqlite_base_file</span><br><span class="line">        self.sqlite_ZhiPin_table = sqlite_ZhiPin_table</span><br><span class="line">        self.sqlite_Test_ZhiPin_table = sqlite_Test_ZhiPin_table</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span>(<span class="params">cls, crawler</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls(</span><br><span class="line">            sqlite_file = crawler.settings.get(<span class="string">&#x27;SQLITE_FILE_PATH&#x27;</span>), <span class="comment"># 从 settings.py 提取</span></span><br><span class="line">            sqlite_base_file=crawler.settings.get(<span class="string">&#x27;SQLITE_BASE_FILE_PATH&#x27;</span>),</span><br><span class="line">            sqlite_ZhiPin_table = crawler.settings.get(<span class="string">&#x27;SQLITE_ZHI_PIN_ITEM_TABLE&#x27;</span>),</span><br><span class="line">            sqlite_Test_ZhiPin_table=crawler.settings.get(<span class="string">&#x27;SQLITE_TEST_ZHI_PIN_ITEM_TABLE&#x27;</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n 连接数据库 \n&quot;</span>)</span><br><span class="line">        self.create_sql_db()</span><br><span class="line">        self.conn = sqlite3.connect(self.sqlite_file)</span><br><span class="line">        self.cur = self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n  关闭数据库 \n&quot;</span>)</span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n Sqlite3Pipeline process_item\n&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(item, TestJobDetailItem):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; sqlite3 处理 TestJobDetailItem &quot;</span>)</span><br><span class="line"></span><br><span class="line">            orderedDict = OrderedDict(<span class="built_in">sorted</span>(item.items(), key=<span class="keyword">lambda</span> t: t[<span class="number">0</span>]))</span><br><span class="line">            keys = <span class="built_in">list</span>(orderedDict.keys())</span><br><span class="line">            values = <span class="built_in">list</span>(orderedDict.values())</span><br><span class="line">            insert_sql = <span class="string">&quot;insert into &#123;0&#125;(&#123;1&#125;) values (&#123;2&#125;)&quot;</span>.<span class="built_in">format</span>(self.sqlite_ZhiPin_table,</span><br><span class="line">                                                                <span class="string">&#x27;, &#x27;</span>.join(keys),</span><br><span class="line">                                                                <span class="string">&#x27;, &#x27;</span>.join([<span class="string">&#x27;?&#x27;</span>] * <span class="built_in">len</span>(keys)))</span><br><span class="line"></span><br><span class="line">            self.cur.execute(insert_sql, values)</span><br><span class="line">            self.conn.commit()</span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; item 类型不对 sqlite3不处理&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_sql_db</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment">#复制原始数据库，（也可以直接新建一个，只不过懒得写SQL……</span></span><br><span class="line">        sql_db_path = os.path.abspath(self.sqlite_file)</span><br><span class="line">        sql_base_db_path = os.path.abspath(self.sqlite_base_file)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n create_sql_db  \n  &quot;</span>, sql_db_path, sql_base_db_path)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(sql_db_path):</span><br><span class="line">            shutil.copyfile(sql_base_db_path, sql_db_path)</span><br></pre></td></tr></table></figure>
<p>这里例子详细写了将抓取数据写入数据库，这里用的是sqlite3。可以换成文件csv，mysql什么的。</p>
<h3 id="3-在Setting中配置一下"><a href="#3-在Setting中配置一下" class="headerlink" title="3.在Setting中配置一下"></a>3.在Setting中配置一下</h3><p>找到settings.py 写入：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据库信息</span></span><br><span class="line">SQLITE_FILE_PATH = <span class="string">&#x27;/Users/sts/Desktop/github/pythonWorkSapce/jobSpider/jobSpider/sqlite/Item_use.sqlite&#x27;</span></span><br><span class="line">SQLITE_BASE_FILE_PATH = <span class="string">&#x27;/Users/sts/Desktop/github/pythonWorkSapce/jobSpider/jobSpider/sqlite/Item_base.sqlite&#x27;</span></span><br><span class="line">SQLITE_ZHI_PIN_ITEM_TABLE = <span class="string">&#x27;ZhiPinJobDetail&#x27;</span></span><br><span class="line">SQLITE_TEST_ZHI_PIN_ITEM_TABLE = <span class="string">&#x27;TestZhiPin&#x27;</span></span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置pipeline</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">&#x27;jobSpider.pipelines.Sqlite3Pipeline&#x27;</span>: <span class="number">400</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以配置多个pipeline，后面的数字表示优先级。scrapy会根据优先级，把item依次交给各个pipeline来处理。</p>
<h3 id="4-在爬虫中调用这个pipeline"><a href="#4-在爬虫中调用这个pipeline" class="headerlink" title="4.在爬虫中调用这个pipeline"></a>4.在爬虫中调用这个pipeline</h3><p>在上面递归例子中，加入 yield item</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jobSpider.items <span class="keyword">import</span> JobDetailItem</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">#具体的招聘信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_job_detail</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        selector = scrapy.Selector(response)</span><br><span class="line"></span><br><span class="line">        job_url = response.request.url</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; 解析 具体的招聘信息  --------url:&quot;</span>+job_url)  </span><br><span class="line">        item = TestJobDetailItem()      </span><br><span class="line">        item[<span class="string">&quot;url&quot;</span>] = job_url</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>
<p>scrapy会把这个item交给我们刚刚写的FilePipeline来处理.</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><blockquote>
<p>很多爬虫信息都要登录后才能抓取，这里也将登录模拟一遍，还是用 zhipin 网站。<br>使用zhipin网站的账号密码登陆模式</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 测试登录</span></span><br><span class="line">   login_url = <span class="string">&quot;https://www.zhipin.com/user/login.html?ka=header-login&quot;</span></span><br><span class="line">   login_post_url = <span class="string">&quot;https://www.zhipin.com/login/account.json&quot;</span></span><br><span class="line">   host = <span class="string">&quot;https://www.zhipin.com&quot;</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="keyword">yield</span> scrapy.Request(url=self.login_url,</span><br><span class="line">                            meta=&#123;<span class="string">&#x27;cookiejar&#x27;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">                            callback=self.request_captcha)</span><br><span class="line"></span><br><span class="line">   <span class="comment">#获取验证码 这里简单使用手动输验证码</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">request_captcha</span>(<span class="params">self, response</span>):</span></span><br><span class="line">       selector = scrapy.Selector(response)</span><br><span class="line">       captcha_url = selector.xpath(<span class="string">&quot;//img[@class=&#x27;verifyimg&#x27;]&quot;</span>).xpath(<span class="string">&quot;./@src&quot;</span>).extract_first()</span><br><span class="line">       randomKey = selector.xpath(<span class="string">&quot;//input[@class=&#x27;randomkey&#x27;]&quot;</span>).xpath(<span class="string">&quot;./@value&quot;</span>).extract_first()</span><br><span class="line"></span><br><span class="line">       full_captcha_url = self.host + captcha_url</span><br><span class="line">       fileName = self.captcha_file_path()</span><br><span class="line">       urlretrieve(full_captcha_url, fileName)</span><br><span class="line"></span><br><span class="line">       open_image_command = <span class="string">&quot;open &quot;</span>+fileName</span><br><span class="line">       os.system(open_image_command)</span><br><span class="line"></span><br><span class="line">       captcha_str = <span class="built_in">input</span>(<span class="string">&quot;请输入验证码:&quot;</span>)</span><br><span class="line">       <span class="keyword">return</span> scrapy.FormRequest.from_response(</span><br><span class="line">           response,</span><br><span class="line">           formdata=&#123;<span class="string">&quot;regionCode&quot;</span>: <span class="string">&quot;+86&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;account&quot;</span>: <span class="string">&quot;手机号&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;password&quot;</span>: <span class="string">&quot;密码&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;captcha&quot;</span>: captcha_str,</span><br><span class="line">                     <span class="string">&quot;randomKey&quot;</span>: randomKey&#125;,</span><br><span class="line">           meta=&#123;<span class="string">&#x27;cookiejar&#x27;</span>: response.meta[<span class="string">&#x27;cookiejar&#x27;</span>]&#125;,</span><br><span class="line">           callback=self.after_login</span><br><span class="line">       )</span><br><span class="line"></span><br><span class="line"><span class="comment"># self.open_host_page 就是开始爬的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">after_login</span>(<span class="params">self, response</span>):</span></span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;after_login&quot;</span>)</span><br><span class="line">       <span class="keyword">yield</span> scrapy.Request(url=self.host,</span><br><span class="line">                            meta=&#123;<span class="string">&#x27;cookiejar&#x27;</span>: response.meta[<span class="string">&#x27;cookiejar&#x27;</span>]&#125;,</span><br><span class="line">                            callback=self.open_host_page)</span><br><span class="line">                            </span><br><span class="line">   <span class="comment">#验证码图片保存路径</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">captcha_file_path</span>(<span class="params">self</span>):</span></span><br><span class="line">       captcha_file_name = <span class="string">&quot;./image/captcha.jpg&quot;</span></span><br><span class="line">       directory = os.path.dirname(captcha_file_name)</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(directory):</span><br><span class="line">           os.makedirs(directory)</span><br><span class="line">       <span class="keyword">return</span> captcha_file_name</span><br></pre></td></tr></table></figure>

<h2 id="setting的一些配置"><a href="#setting的一些配置" class="headerlink" title="setting的一些配置"></a>setting的一些配置</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 间隔时间，单位秒。指明scrapy每两个请求之间的间隔。</span></span><br><span class="line">DOWNLOAD_DELAY = <span class="number">5</span></span><br><span class="line"><span class="comment"># 对一个网站的最大并发数</span></span><br><span class="line">CONCURRENT_REQUESTS_PER_DOMAIN = <span class="number">16</span></span><br><span class="line"><span class="comment"># 对一个IP的最大并发数</span></span><br><span class="line">CONCURRENT_REQUESTS_PER_IP = <span class="number">16</span></span><br><span class="line"><span class="comment"># 请求头</span></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.8,en;q=0.6&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Encoding&#x27;</span>:<span class="string">&#x27;gzip, deflate, sdch, br&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>就可以爬取到所需要的招聘信息了：<br><img src="/myImage/python%E7%88%AC%E8%99%AB.png"></p>
<p>具体代码查看： <a href="https://github.com/sunyanyan/jobSpider">https://github.com/sunyanyan/jobSpider</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫</title>
    <url>/2020/03/09/python/%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="视频学习"><a href="#视频学习" class="headerlink" title="视频学习"></a>视频学习</h2><p><a href="https://www.bilibili.com/video/bv1z541167mu/?spm_id_from=333.788.b_636f6d6d656e74.49">python爬虫</a>  </p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Workbench使用</title>
    <url>/2018/06/11/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%20Workbench%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="MySQL-Workbench-安装使用"><a href="#MySQL-Workbench-安装使用" class="headerlink" title="MySQL Workbench 安装使用"></a>MySQL Workbench 安装使用</h4><p>  MySQL Workbench为数据库架构师，开发人员和DBA提供统一的可视化工具。MySQL Workbench为服务器配置，用户管理，备份等提供了数据建模，SQL开发以及全面的管理工具。  </p>
<p><a href="http://www.runoob.com/sql/sql-tutorial.html">SQL 教程</a><br><a href="https://blog.csdn.net/jiankeufo/article/details/79650576">MySQL Workbench</a></p>
<h4 id="Mac下MySQL与MySQLWorkbench的安装-和-关联"><a href="#Mac下MySQL与MySQLWorkbench的安装-和-关联" class="headerlink" title="Mac下MySQL与MySQLWorkbench的安装 和 关联"></a>Mac下MySQL与MySQLWorkbench的安装 和 关联</h4><p><a href="https://www.cnblogs.com/libiyangblog/p/5186904.html">Mac下MySQL与MySQLWorkbench的安装</a></p>
<h4 id="布局介绍"><a href="#布局介绍" class="headerlink" title="布局介绍"></a>布局介绍</h4><p><img src="https://img2018.cnblogs.com/blog/1291389/201810/1291389-20181025144539718-212029353.png"></p>
<p><a href="https://www.cnblogs.com/hahayixiao/p/9849742.html">MySQL Workbench布局介绍</a></p>
]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>MySQL Workbench使用</tag>
      </tags>
  </entry>
  <entry>
    <title>堆栈</title>
    <url>/2018/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<p>在计算机领域，堆栈是一个不容忽视的概念，堆栈是两种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。要点：堆，队列优先,先进先出（FIFO—first in first out） 。栈，先进后出(FILO—First-In/Last-Out)。</p>
<h3 id="堆栈空间分配"><a href="#堆栈空间分配" class="headerlink" title="堆栈空间分配"></a>堆栈空间分配</h3><p>栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</p>
<h3 id="堆栈缓存方式"><a href="#堆栈缓存方式" class="headerlink" title="堆栈缓存方式"></a>堆栈缓存方式</h3><p>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。<br>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p>
<h3 id="堆栈数据结构区别"><a href="#堆栈数据结构区别" class="headerlink" title="堆栈数据结构区别"></a>堆栈数据结构区别</h3><p>堆（数据结构）：堆可以被看成是一棵树，如：堆排序。<br>栈（数据结构）：一种先进后出的数据结构。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2018/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%A0%91/</url>
    <content><![CDATA[<p>定义：n个节点构成的有序集合。<br>1、顺序查找<br>2、二分查找<br>    二分查找判定树，ASL，<br>3、树<br>4、二叉树    </p>
<p>第一章 绪论<br>（a）计算<br>（b）计算模型<br>（c）大O记号<br>（d）算法分析<br>（e）迭代与递归<br>（xc）动态规划<br>第二章 向量<br>（a）接口与实现<br>（b）可扩充向量<br>（c）无序向量<br>（d1）有序向量：唯一化<br>（d2）有序向量：二分查找<br>（d3）有序向量：Fibonacci查找<br>（d4）有序向量：二分查找（改进）<br>（d5）有序向量：插值查找<br>（e）起泡排序<br>（f）归并排序<br>第三章 列表<br>（a）接口与实现<br>（b）无序列表<br>（c）有序列表<br>（d）选择排序<br>（e）插入排序<br>第四章 栈与队列<br>（a）栈接口与实现<br>（c1）栈应用：进制转换<br>（c2）栈应用：括号匹配<br>（c3）栈应用：栈混洗<br>（c4）栈应用：中缀表达式求值<br>（c5）栈应用：逆波兰表达式<br>（d）队列接口与实现<br>第五章 二叉树<br>（a）树<br>（b）树的表示<br>（c）二叉树<br>（d）二叉树实现<br>（e1）先序遍历<br>（e2）中序遍历<br>（e4）层次遍历<br>（e5）重构<br>第六章 图<br>（a）概述<br>（b1）邻接矩阵<br>（c）广度优先搜索<br>（d）深度优先搜索<br>第七章 二叉搜索树<br>（a）概述<br>（b1）BST：查找<br>（b2）BST：插入<br>（b3）BST：删除<br>（c）平衡与等价<br>（d1）AVL树：重平衡<br>（d2）AVL树：插入<br>（d3）AVL树：删除<br>（d4）AVL树：(3+4)-重构<br>第八章 高级搜索树<br>(a1)伸展树：逐层伸展<br>(a2)伸展树：双层伸展<br>(a3)伸展树：算法实现<br>(b1)B-树：动机<br>(b2)B-树：结构<br>(b3)B-树：查找<br>(b4)B-树： 插入<br>(b5)B-树： 删除<br>(xa1)红黑树：动机<br>(xa2)红黑树：结构<br>(xa3)红黑树：插入<br>(xa4)红黑树：删除</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转数据结构</title>
    <url>/2018/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problemset/all/">leetcode-cn.com</a></p>
<h3 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h3><ul>
<li>数组：</li>
<li>栈： （push、pop、peek、getSize、isEmpty）</li>
<li>队列：（enqueue、dequeue、size、head、tail）  LoopQueue</li>
<li>链表（动态数据结构） ：(node、nextNode、head、previous、size、dummyHead) <ul>
<li>优势：</li>
<li>对链表头部的增删 时间复杂度 O(1)</li>
<li>只查找链表头部的元素 时间负责度 O(1)</li>
</ul>
</li>
</ul>
<p>题目：分别用数组和链表 去实现栈和队列   对比时间负责度。</p>
<h3 id="非线性数据结构"><a href="#非线性数据结构" class="headerlink" title="非线性数据结构"></a>非线性数据结构</h3><ul>
<li>二叉树</li>
<li>二分搜索树（动态数据结构）：前序、中序、后序 遍历</li>
<li>平衡二叉树 ：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 （AVL、红黑树）</li>
</ul>
<h3 id="集合和映射（set-和-map）"><a href="#集合和映射（set-和-map）" class="headerlink" title="集合和映射（set 和 map）"></a>集合和映射（set 和 map）</h3><h3 id="优先队列和堆"><a href="#优先队列和堆" class="headerlink" title="优先队列和堆"></a>优先队列和堆</h3><ul>
<li>满二叉树：除了叶子节点，都有左右孩子节点。</li>
<li>完全二叉树：不一定是满二叉树，从左到右的盛放节点，不满的地方肯定在右下方。</li>
<li>二叉堆：是一颗完全二叉树。</li>
<li>最大堆：堆中的某个节点值总是不大于其父亲节点的值。（添加元素、sift up、取出元素、sift down、replace、heapify）</li>
<li>最小堆：父结点的键值总是小于或等于任何一个子节点的键值。</li>
</ul>
<h3 id="线段树-（区间树）segment-tree"><a href="#线段树-（区间树）segment-tree" class="headerlink" title="线段树 （区间树）segment tree"></a>线段树 （区间树）segment tree</h3><table>
<thead>
<tr>
<th align="center">操作\复杂度</th>
<th align="center">使用数组</th>
<th align="center">使用线段树</th>
</tr>
</thead>
<tbody><tr>
<td align="center">更新</td>
<td align="center">O(n)</td>
<td align="center">O(logn)</td>
</tr>
<tr>
<td align="center">查询</td>
<td align="center">O(n)</td>
<td align="center">O(logn)</td>
</tr>
</tbody></table>
<h3 id="Trie-（多叉树）"><a href="#Trie-（多叉树）" class="headerlink" title="Trie （多叉树）"></a>Trie （多叉树）</h3><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p> 由孩子指向父节点</p>
<h3 id="平衡树-和-AVL"><a href="#平衡树-和-AVL" class="headerlink" title="平衡树 和 AVL"></a>平衡树 和 AVL</h3><p>平衡二叉树 ：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。（标注节点的高度、计算平衡因子）</p>
<h3 id="红黑树-和-2-3树"><a href="#红黑树-和-2-3树" class="headerlink" title="红黑树 和 2-3树"></a>红黑树 和 2-3树</h3><p> 2-3树： 绝对平衡的树</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>玩转数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表用顺序和链表来实现方式</title>
    <url>/2018/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8(%E6%95%B0%E7%BB%84%E6%88%96%E8%80%85%E9%93%BE%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0)/</url>
    <content><![CDATA[<p><strong>线性表：</strong>是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。</p>
<h2 id="顺序存储实现"><a href="#顺序存储实现" class="headerlink" title="顺序存储实现"></a>顺序存储实现</h2><p>通常用到的比如：数组。   利用数组的连续存储空间顺序存放线性表的各元素。</p>
<p>顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，称为线性表的顺序存储结构或顺序映像（sequential mapping）。它以“物理位置相邻”来表示线性表中数据元素间的逻辑关系，可随机存取表中任一元素。</p>
<h2 id="链式存储实现"><a href="#链式存储实现" class="headerlink" title="链式存储实现"></a>链式存储实现</h2><p>不需要逻辑上相邻的两个元素物理上也相邻，通过“链”建立起数据元素之间的逻辑关系。</p>
<p>插入、删除不需要移动数据元素，需要修改“链”。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表顺序和链存储</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2018/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
<p><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=35768ebb0ff3d7ca18fb37249376d56c/cdbf6c81800a19d8116a4d8030fa828ba71e46ce.jpg"></p>
<p>队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>swift初体验</title>
    <url>/2019/11/15/iOS/swift/swift%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<p><a href="https://www.cnswift.org/a-swift-tour">www.cnswift.org</a></p>
<h4 id="你好，世界"><a href="#你好，世界" class="headerlink" title="你好，世界"></a>你好，世界</h4><p><code>print(&quot;Hello, world!&quot;)</code></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
</search>
